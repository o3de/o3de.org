<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine GameState Gem API Reference: GameState::GameStateRequests Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Open 3D Engine GameState Gem API Reference<span id="projectnumber">&#160;23.10.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_game_state_1_1_game_state_requests.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_game_state_1_1_game_state_requests-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">GameState::GameStateRequests Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>EBus interface used to submit requests related to game state management.  
 <a href="class_game_state_1_1_game_state_requests.html#details">More...</a></p>

<p><code>#include &lt;GameStateRequestBus.h&gt;</code></p>

<p>Inherits AZ::EBusTraits.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae2f111a587732dd67fbd7fb6eeaf6470"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#ae2f111a587732dd67fbd7fb6eeaf6470">UpdateActiveGameState</a> ()=0</td></tr>
<tr class="separator:ae2f111a587732dd67fbd7fb6eeaf6470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0883169a1365be23bc7c6427c34f893d"><td class="memItemLeft" align="right" valign="top">virtual AZStd::shared_ptr&lt; <a class="el" href="class_game_state_1_1_i_game_state.html">IGameState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#a0883169a1365be23bc7c6427c34f893d">GetActiveGameState</a> ()=0</td></tr>
<tr class="separator:a0883169a1365be23bc7c6427c34f893d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c7fe1334b6a87b90c43a20ddc3f2d3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#a83c7fe1334b6a87b90c43a20ddc3f2d3">PushGameState</a> (AZStd::shared_ptr&lt; <a class="el" href="class_game_state_1_1_i_game_state.html">IGameState</a> &gt; newGameState)=0</td></tr>
<tr class="separator:a83c7fe1334b6a87b90c43a20ddc3f2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dfedbab60147e7967cd135aa374ab0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#ad1dfedbab60147e7967cd135aa374ab0">PopActiveGameState</a> ()=0</td></tr>
<tr class="separator:ad1dfedbab60147e7967cd135aa374ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a394d40961c7d21f97a09ddade8ad06"><td class="memItemLeft" align="right" valign="top"><a id="a5a394d40961c7d21f97a09ddade8ad06" name="a5a394d40961c7d21f97a09ddade8ad06"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>PopAllGameStates</b> ()=0</td></tr>
<tr class="memdesc:a5a394d40961c7d21f97a09ddade8ad06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop all game states from the stack, leaving it empty. <br /></td></tr>
<tr class="separator:a5a394d40961c7d21f97a09ddade8ad06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9ef814c4443bf7b614bf7d45285b92"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#a4e9ef814c4443bf7b614bf7d45285b92">ReplaceActiveGameState</a> (AZStd::shared_ptr&lt; <a class="el" href="class_game_state_1_1_i_game_state.html">IGameState</a> &gt; newGameState)=0</td></tr>
<tr class="separator:a4e9ef814c4443bf7b614bf7d45285b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4cc9cc5b89f31668d1524560408522"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#aec4cc9cc5b89f31668d1524560408522">DoesStackContainGameStateOfTypeId</a> (const AZ::TypeId &amp;gameStateTypeId)=0</td></tr>
<tr class="separator:aec4cc9cc5b89f31668d1524560408522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043d451e973e62f98d9b559ecbb53b82"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#a043d451e973e62f98d9b559ecbb53b82">AddGameStateFactoryOverrideForTypeId</a> (const AZ::TypeId &amp;gameStateTypeId, GameStateFactory factory)=0</td></tr>
<tr class="separator:a043d451e973e62f98d9b559ecbb53b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace37cb09b5e6c05dd8587ab4e28f1f08"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#ace37cb09b5e6c05dd8587ab4e28f1f08">RemoveGameStateFactoryOverrideForTypeId</a> (const AZ::TypeId &amp;gameStateTypeId)=0</td></tr>
<tr class="separator:ace37cb09b5e6c05dd8587ab4e28f1f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c8cb7f41635e259be3a1e342b4742a"><td class="memItemLeft" align="right" valign="top">virtual GameStateFactory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#ac6c8cb7f41635e259be3a1e342b4742a">GetGameStateFactoryOverrideForTypeId</a> (const AZ::TypeId &amp;gameStateTypeId)=0</td></tr>
<tr class="separator:ac6c8cb7f41635e259be3a1e342b4742a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad8f04f7285226607324fab2a9eff658c"><td class="memTemplParams" colspan="2">template&lt;class GameStateType &gt; </td></tr>
<tr class="memitem:ad8f04f7285226607324fab2a9eff658c"><td class="memTemplItemLeft" align="right" valign="top">static AZStd::shared_ptr&lt; <a class="el" href="class_game_state_1_1_i_game_state.html">IGameState</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#ad8f04f7285226607324fab2a9eff658c">CreateNewOverridableGameStateOfType</a> (bool checkForOverride=true)</td></tr>
<tr class="separator:ad8f04f7285226607324fab2a9eff658c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab139c55ec3886b764eff00f92bbd0b96"><td class="memTemplParams" colspan="2">template&lt;class GameStateType &gt; </td></tr>
<tr class="memitem:ab139c55ec3886b764eff00f92bbd0b96"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#ab139c55ec3886b764eff00f92bbd0b96">CreateAndPushNewOverridableGameStateOfType</a> (bool checkForOverride=true)</td></tr>
<tr class="separator:ab139c55ec3886b764eff00f92bbd0b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99034839a3f483f5b960e33f088dcc98"><td class="memTemplParams" colspan="2">template&lt;class GameStateType &gt; </td></tr>
<tr class="memitem:a99034839a3f483f5b960e33f088dcc98"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#a99034839a3f483f5b960e33f088dcc98">PopActiveGameStateUntilOfType</a> ()</td></tr>
<tr class="separator:a99034839a3f483f5b960e33f088dcc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e03f14aed46eda39ef79420ef6feac"><td class="memTemplParams" colspan="2">template&lt;class GameStateType &gt; </td></tr>
<tr class="memitem:a67e03f14aed46eda39ef79420ef6feac"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#a67e03f14aed46eda39ef79420ef6feac">IsActiveGameStateOfType</a> ()</td></tr>
<tr class="separator:a67e03f14aed46eda39ef79420ef6feac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3720699eb1da48926e530e73aab1276b"><td class="memTemplParams" colspan="2">template&lt;class GameStateType &gt; </td></tr>
<tr class="memitem:a3720699eb1da48926e530e73aab1276b"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#a3720699eb1da48926e530e73aab1276b">DoesStackContainGameStateOfType</a> ()</td></tr>
<tr class="separator:a3720699eb1da48926e530e73aab1276b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c0f6d56cc4cd16f01e08ae97629726"><td class="memTemplParams" colspan="2">template&lt;class GameStateType &gt; </td></tr>
<tr class="memitem:af2c0f6d56cc4cd16f01e08ae97629726"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#af2c0f6d56cc4cd16f01e08ae97629726">AddGameStateFactoryOverrideForType</a> (GameStateFactory factory)</td></tr>
<tr class="separator:af2c0f6d56cc4cd16f01e08ae97629726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f2b7d2981270ee5e423f7e23d8c0ad"><td class="memTemplParams" colspan="2">template&lt;class GameStateType &gt; </td></tr>
<tr class="memitem:a58f2b7d2981270ee5e423f7e23d8c0ad"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#a58f2b7d2981270ee5e423f7e23d8c0ad">RemoveGameStateFactoryOverrideForType</a> ()</td></tr>
<tr class="separator:a58f2b7d2981270ee5e423f7e23d8c0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9a04b30648d6232f282b9197fbcbd4"><td class="memTemplParams" colspan="2">template&lt;class GameStateType &gt; </td></tr>
<tr class="memitem:a2a9a04b30648d6232f282b9197fbcbd4"><td class="memTemplItemLeft" align="right" valign="top">static GameStateFactory&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#a2a9a04b30648d6232f282b9197fbcbd4">GetGameStateFactoryOverrideForType</a> ()</td></tr>
<tr class="separator:a2a9a04b30648d6232f282b9197fbcbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae6cbd76c6b38684a7ea7fbd0b237b37d"><td class="memItemLeft" align="right" valign="top">static const AZ::EBusAddressPolicy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_game_state_1_1_game_state_requests.html#ae6cbd76c6b38684a7ea7fbd0b237b37d">AddressPolicy</a> = AZ::EBusAddressPolicy::Single</td></tr>
<tr class="separator:ae6cbd76c6b38684a7ea7fbd0b237b37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c668972b21e587d42ff483d70539ccd"><td class="memItemLeft" align="right" valign="top"><a id="a4c668972b21e587d42ff483d70539ccd" name="a4c668972b21e587d42ff483d70539ccd"></a>
static const AZ::EBusHandlerPolicy&#160;</td><td class="memItemRight" valign="bottom"><b>HandlerPolicy</b> = AZ::EBusHandlerPolicy::Single</td></tr>
<tr class="separator:a4c668972b21e587d42ff483d70539ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>EBus interface used to submit requests related to game state management. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af2c0f6d56cc4cd16f01e08ae97629726" name="af2c0f6d56cc4cd16f01e08ae97629726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c0f6d56cc4cd16f01e08ae97629726">&#9670;&#160;</a></span>AddGameStateFactoryOverrideForType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GameStateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GameState::GameStateRequests::AddGameStateFactoryOverrideForType </td>
          <td>(</td>
          <td class="paramtype">GameStateFactory&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a game state override so that a request to push a new game state of a certain type will result in pushing a new game state of a different type instead. This is useful for situations where we want to use a set of default game states but override some (or all) of them with custom versions which satisfy the requirements of a specific game project. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GameStateType</td><td>The original game state type to be overridden </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">factory</td><td>The factory function that will create the game state override </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the game state override was successfully added, false otherwise </dd></dl>

</div>
</div>
<a id="a043d451e973e62f98d9b559ecbb53b82" name="a043d451e973e62f98d9b559ecbb53b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043d451e973e62f98d9b559ecbb53b82">&#9670;&#160;</a></span>AddGameStateFactoryOverrideForTypeId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GameState::GameStateRequests::AddGameStateFactoryOverrideForTypeId </td>
          <td>(</td>
          <td class="paramtype">const AZ::TypeId &amp;&#160;</td>
          <td class="paramname"><em>gameStateTypeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GameStateFactory&#160;</td>
          <td class="paramname"><em>factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a game state override so that a request to push a new game state of a certain type will result in pushing a new game state of a derived type instead. This is useful for situations where we want to use a set of default game states but override some (or all) of them with custom versions which satisfy the requirements of a specific game project. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gameStateTypeId</td><td>The original game state type id to be overridden </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factory</td><td>The factory function that will create the game state override </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the game state override was successfully added, false otherwise </dd></dl>

</div>
</div>
<a id="ab139c55ec3886b764eff00f92bbd0b96" name="ab139c55ec3886b764eff00f92bbd0b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab139c55ec3886b764eff00f92bbd0b96">&#9670;&#160;</a></span>CreateAndPushNewOverridableGameStateOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GameStateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GameState::GameStateRequests::CreateAndPushNewOverridableGameStateOfType </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkForOverride</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new game state and push it onto the stack to make it the active game state. New game states are created and stored in the stack using a shared_ptr, so they will be destroyed automatically once they are popped off the stack (assuming that nothing else retains a reference, say via <a class="el" href="class_game_state_1_1_game_state_notifications.html#abd887c0089286acef211d71929a6becc">GameStateNotifications::OnActiveGameStateChanged</a>). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GameStateType</td><td>The game state type to create and activate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">checkForOverrides</td><td>True if we should check for an override, false otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8f04f7285226607324fab2a9eff658c" name="ad8f04f7285226607324fab2a9eff658c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f04f7285226607324fab2a9eff658c">&#9670;&#160;</a></span>CreateNewOverridableGameStateOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GameStateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AZStd::shared_ptr&lt; <a class="el" href="class_game_state_1_1_i_game_state.html">IGameState</a> &gt; GameState::GameStateRequests::CreateNewOverridableGameStateOfType </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkForOverride</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new game state </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GameStateType</td><td>The game state type to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">checkForOverrides</td><td>True if we should check for an override, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the new game state that was created </dd></dl>

</div>
</div>
<a id="a3720699eb1da48926e530e73aab1276b" name="a3720699eb1da48926e530e73aab1276b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3720699eb1da48926e530e73aab1276b">&#9670;&#160;</a></span>DoesStackContainGameStateOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GameStateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GameState::GameStateRequests::DoesStackContainGameStateOfType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether the game state stack contains a game state of the specified type </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GameStateType</td><td>The game state type to check whether is in the stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stack contains a game state of the specified type, false otherwise </dd></dl>

</div>
</div>
<a id="aec4cc9cc5b89f31668d1524560408522" name="aec4cc9cc5b89f31668d1524560408522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4cc9cc5b89f31668d1524560408522">&#9670;&#160;</a></span>DoesStackContainGameStateOfTypeId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GameState::GameStateRequests::DoesStackContainGameStateOfTypeId </td>
          <td>(</td>
          <td class="paramtype">const AZ::TypeId &amp;&#160;</td>
          <td class="paramname"><em>gameStateTypeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether the game state stack contains a game state of the specified type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gameStateTypeId</td><td>The game state type to check whether is in the stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stack contains a game state of the specified type, false otherwise </dd></dl>

</div>
</div>
<a id="a0883169a1365be23bc7c6427c34f893d" name="a0883169a1365be23bc7c6427c34f893d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0883169a1365be23bc7c6427c34f893d">&#9670;&#160;</a></span>GetActiveGameState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AZStd::shared_ptr&lt; <a class="el" href="class_game_state_1_1_i_game_state.html">IGameState</a> &gt; GameState::GameStateRequests::GetActiveGameState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Request the active game state (if any) </p><dl class="section return"><dt>Returns</dt><dd>A shared pointer to the active game state (will be empty if there is none) </dd></dl>

</div>
</div>
<a id="a2a9a04b30648d6232f282b9197fbcbd4" name="a2a9a04b30648d6232f282b9197fbcbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9a04b30648d6232f282b9197fbcbd4">&#9670;&#160;</a></span>GetGameStateFactoryOverrideForType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GameStateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GameStateFactory GameState::GameStateRequests::GetGameStateFactoryOverrideForType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve a game state override that was added using AddGameStateFactoryOverrideForType. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GameStateType</td><td>The original game state type that was overridden </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The factory function used to create the game state override, nullptr otherwise </dd></dl>

</div>
</div>
<a id="ac6c8cb7f41635e259be3a1e342b4742a" name="ac6c8cb7f41635e259be3a1e342b4742a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c8cb7f41635e259be3a1e342b4742a">&#9670;&#160;</a></span>GetGameStateFactoryOverrideForTypeId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual GameStateFactory GameState::GameStateRequests::GetGameStateFactoryOverrideForTypeId </td>
          <td>(</td>
          <td class="paramtype">const AZ::TypeId &amp;&#160;</td>
          <td class="paramname"><em>gameStateTypeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve a game state override that was added using AddGameStateFactoryOverrideForTypeId. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gameStateTypeId</td><td>The original game state type id that was overridden </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The factory function used to create the game state override, nullptr otherwise </dd></dl>

</div>
</div>
<a id="a67e03f14aed46eda39ef79420ef6feac" name="a67e03f14aed46eda39ef79420ef6feac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e03f14aed46eda39ef79420ef6feac">&#9670;&#160;</a></span>IsActiveGameStateOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GameStateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GameState::GameStateRequests::IsActiveGameStateOfType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether the active game state is of the specified type </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GameStateType</td><td>The game state type to check whether is active </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the active game state is of the specified type, false otherwise </dd></dl>

</div>
</div>
<a id="ad1dfedbab60147e7967cd135aa374ab0" name="ad1dfedbab60147e7967cd135aa374ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1dfedbab60147e7967cd135aa374ab0">&#9670;&#160;</a></span>PopActiveGameState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GameState::GameStateRequests::PopActiveGameState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pop the active game state from the stack, which will result in it being deactivated and the game state below it in the stack (if any) becoming the active game state again. </p><dl class="section return"><dt>Returns</dt><dd>True if the active game state was successfully popped, false otherwise </dd></dl>

</div>
</div>
<a id="a99034839a3f483f5b960e33f088dcc98" name="a99034839a3f483f5b960e33f088dcc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99034839a3f483f5b960e33f088dcc98">&#9670;&#160;</a></span>PopActiveGameStateUntilOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GameStateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GameState::GameStateRequests::PopActiveGameStateUntilOfType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pop game states from the stack until the active game state is of the specified type. If no game state of the specified type exists in the game state stack it will be left empty. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GameStateType</td><td>The game state type in the stack that we want to be active </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the active game state is now of the specified type, false otherwise </dd></dl>

</div>
</div>
<a id="a83c7fe1334b6a87b90c43a20ddc3f2d3" name="a83c7fe1334b6a87b90c43a20ddc3f2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c7fe1334b6a87b90c43a20ddc3f2d3">&#9670;&#160;</a></span>PushGameState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GameState::GameStateRequests::PushGameState </td>
          <td>(</td>
          <td class="paramtype">AZStd::shared_ptr&lt; <a class="el" href="class_game_state_1_1_i_game_state.html">IGameState</a> &gt;&#160;</td>
          <td class="paramname"><em>newGameState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Push a game state onto the stack, which will result in it becoming the active game state. If newGameState is already found in the stack this will fail and return false, however it is possible for multiple instances of the same game state type to occupy the stack. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newGameState</td><td>The new game state to push onto the stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the game state was successfully pushed onto the stack, false otherwise </dd></dl>

</div>
</div>
<a id="a58f2b7d2981270ee5e423f7e23d8c0ad" name="a58f2b7d2981270ee5e423f7e23d8c0ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f2b7d2981270ee5e423f7e23d8c0ad">&#9670;&#160;</a></span>RemoveGameStateFactoryOverrideForType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GameStateType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GameState::GameStateRequests::RemoveGameStateFactoryOverrideForType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove a game state override that was added using AddGameStateFactoryOverrideForType. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GameStateType</td><td>The original game state type that was overridden </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the game state override was successfully removed, false otherwise </dd></dl>

</div>
</div>
<a id="ace37cb09b5e6c05dd8587ab4e28f1f08" name="ace37cb09b5e6c05dd8587ab4e28f1f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace37cb09b5e6c05dd8587ab4e28f1f08">&#9670;&#160;</a></span>RemoveGameStateFactoryOverrideForTypeId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GameState::GameStateRequests::RemoveGameStateFactoryOverrideForTypeId </td>
          <td>(</td>
          <td class="paramtype">const AZ::TypeId &amp;&#160;</td>
          <td class="paramname"><em>gameStateTypeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove a game state override that was added using AddGameStateFactoryOverrideForTypeId. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gameStateTypeId</td><td>The original game state type id that was overridden </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the game state override was successfully removed, false otherwise </dd></dl>

</div>
</div>
<a id="a4e9ef814c4443bf7b614bf7d45285b92" name="a4e9ef814c4443bf7b614bf7d45285b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9ef814c4443bf7b614bf7d45285b92">&#9670;&#160;</a></span>ReplaceActiveGameState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GameState::GameStateRequests::ReplaceActiveGameState </td>
          <td>(</td>
          <td class="paramtype">AZStd::shared_ptr&lt; <a class="el" href="class_game_state_1_1_i_game_state.html">IGameState</a> &gt;&#160;</td>
          <td class="paramname"><em>newGameState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace the active game state with another game state that will become the active state. If the stack is currently empty, newGameState will be pushed to become the active state. If newGameState is already found in the stack this will fail and return false, however it is possible for multiple instances of the same game state type to occupy the stack. This differs from calling PopActiveGameState followed by PushGameState(newGameState), which would result in the state below the currently active state being activated then immediately deactivated when newGameState is pushed onto the stack; calling this will the state below the currently active state unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newGameState</td><td>The new game state with which to replace the active game state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the active game state was successfully replaced, false otherwise </dd></dl>

</div>
</div>
<a id="ae2f111a587732dd67fbd7fb6eeaf6470" name="ae2f111a587732dd67fbd7fb6eeaf6470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f111a587732dd67fbd7fb6eeaf6470">&#9670;&#160;</a></span>UpdateActiveGameState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GameState::GameStateRequests::UpdateActiveGameState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the active game state. This is called during the AZ::ComponentTickBus::TICK_GAME priority update of the AZ::TickBus, but can be called independently any time if needed. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae6cbd76c6b38684a7ea7fbd0b237b37d" name="ae6cbd76c6b38684a7ea7fbd0b237b37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6cbd76c6b38684a7ea7fbd0b237b37d">&#9670;&#160;</a></span>AddressPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const AZ::EBusAddressPolicy GameState::GameStateRequests::AddressPolicy = AZ::EBusAddressPolicy::Single</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>EBus Trait: requests can only be sent to and addressed by a single instance (singleton) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Gems/GameState/Code/Include/GameState/GameStateRequestBus.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>GameState</b></li><li class="navelem"><a class="el" href="class_game_state_1_1_game_state_requests.html">GameStateRequests</a></li>
    <li class="footer">Generated on Mon Oct 9 2023 13:49:21 for Open 3D Engine GameState Gem API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
