<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine EMotionFX Gem API Reference: MCore::DualQuaternion Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Open 3D Engine EMotionFX Gem API Reference<span id="projectnumber">&#160;24.09</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_m_core_1_1_dual_quaternion.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_m_core_1_1_dual_quaternion-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">MCore::DualQuaternion Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;DualQuaternion.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a58b5361170af9050353d95ebce681e73" id="r_a58b5361170af9050353d95ebce681e73"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58b5361170af9050353d95ebce681e73">DualQuaternion</a> ()</td></tr>
<tr class="separator:a58b5361170af9050353d95ebce681e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c1ae3b00a259c14da072e030007d6e" id="r_a63c1ae3b00a259c14da072e030007d6e"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63c1ae3b00a259c14da072e030007d6e">DualQuaternion</a> (const <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;other)</td></tr>
<tr class="separator:a63c1ae3b00a259c14da072e030007d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae68397ef5b09de93af7f58b3b0f0b27" id="r_aae68397ef5b09de93af7f58b3b0f0b27"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae68397ef5b09de93af7f58b3b0f0b27">DualQuaternion</a> (const AZ::Quaternion &amp;real, const AZ::Quaternion &amp;dual)</td></tr>
<tr class="separator:aae68397ef5b09de93af7f58b3b0f0b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45804ed7d50727634e149877ab2ea955" id="r_a45804ed7d50727634e149877ab2ea955"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45804ed7d50727634e149877ab2ea955">DualQuaternion</a> (const AZ::Transform &amp;transform)</td></tr>
<tr class="separator:a45804ed7d50727634e149877ab2ea955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5aea917d4c6b5e49cfc1134f46bef3a" id="r_aa5aea917d4c6b5e49cfc1134f46bef3a"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5aea917d4c6b5e49cfc1134f46bef3a">DualQuaternion</a> (const AZ::Quaternion &amp;rotation, const AZ::Vector3 &amp;translation)</td></tr>
<tr class="separator:aa5aea917d4c6b5e49cfc1134f46bef3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a97df76cb4193649df36b07b2499432" id="r_a7a97df76cb4193649df36b07b2499432"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a97df76cb4193649df36b07b2499432">Set</a> (const AZ::Quaternion &amp;real, const AZ::Quaternion &amp;dual)</td></tr>
<tr class="separator:a7a97df76cb4193649df36b07b2499432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b42957cb44d032ea661f52cb41311d" id="r_ae7b42957cb44d032ea661f52cb41311d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7b42957cb44d032ea661f52cb41311d">Normalize</a> ()</td></tr>
<tr class="separator:ae7b42957cb44d032ea661f52cb41311d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813fc0c5e0eb9fd55523797e6e60d274" id="r_a813fc0c5e0eb9fd55523797e6e60d274"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a813fc0c5e0eb9fd55523797e6e60d274">Normalized</a> () const</td></tr>
<tr class="separator:a813fc0c5e0eb9fd55523797e6e60d274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c39edb29b0eb713d6ad1563958ee767" id="r_a5c39edb29b0eb713d6ad1563958ee767"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c39edb29b0eb713d6ad1563958ee767">Identity</a> ()</td></tr>
<tr class="separator:a5c39edb29b0eb713d6ad1563958ee767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf99501ec46fa2a7dc53acaae459671" id="r_a1cf99501ec46fa2a7dc53acaae459671"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE AZ::Vector2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cf99501ec46fa2a7dc53acaae459671">Dot</a> (const <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;other) const</td></tr>
<tr class="separator:a1cf99501ec46fa2a7dc53acaae459671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa481538fce4112591122dc7a6760d9c2" id="r_aa481538fce4112591122dc7a6760d9c2"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE AZ::Vector2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa481538fce4112591122dc7a6760d9c2">Length</a> () const</td></tr>
<tr class="separator:aa481538fce4112591122dc7a6760d9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3d25bb9edec55e21ed533bc591baf7" id="r_a2c3d25bb9edec55e21ed533bc591baf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c3d25bb9edec55e21ed533bc591baf7">Inverse</a> ()</td></tr>
<tr class="separator:a2c3d25bb9edec55e21ed533bc591baf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f3b8b6b3d544cb6c9662f0af837192" id="r_af6f3b8b6b3d544cb6c9662f0af837192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6f3b8b6b3d544cb6c9662f0af837192">Inversed</a> () const</td></tr>
<tr class="separator:af6f3b8b6b3d544cb6c9662f0af837192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675f7f76e1eb0833c21acfb4b3f0651b" id="r_a675f7f76e1eb0833c21acfb4b3f0651b"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a675f7f76e1eb0833c21acfb4b3f0651b">Conjugate</a> ()</td></tr>
<tr class="separator:a675f7f76e1eb0833c21acfb4b3f0651b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bdcab90eb00af57482c4f1a3861292" id="r_a88bdcab90eb00af57482c4f1a3861292"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88bdcab90eb00af57482c4f1a3861292">Conjugated</a> () const</td></tr>
<tr class="separator:a88bdcab90eb00af57482c4f1a3861292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680aed54daf0bfec883a1f5e0eda25d4" id="r_a680aed54daf0bfec883a1f5e0eda25d4"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a680aed54daf0bfec883a1f5e0eda25d4">FromTransform</a> (const AZ::Transform &amp;transform)</td></tr>
<tr class="separator:a680aed54daf0bfec883a1f5e0eda25d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a1f062315f173101633a4aae9c3df5" id="r_a21a1f062315f173101633a4aae9c3df5"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21a1f062315f173101633a4aae9c3df5">FromRotationTranslation</a> (const AZ::Quaternion &amp;rot, const AZ::Vector3 &amp;pos)</td></tr>
<tr class="separator:a21a1f062315f173101633a4aae9c3df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e05184e54232c6f3607480f673cd6f" id="r_a55e05184e54232c6f3607480f673cd6f"><td class="memItemLeft" align="right" valign="top">AZ::Transform&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55e05184e54232c6f3607480f673cd6f">ToTransform</a> () const</td></tr>
<tr class="separator:a55e05184e54232c6f3607480f673cd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10f68bc361a42141f1ab8d83c6f3fce" id="r_ae10f68bc361a42141f1ab8d83c6f3fce"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE AZ::Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae10f68bc361a42141f1ab8d83c6f3fce">TransformPoint</a> (const AZ::Vector3 &amp;point) const</td></tr>
<tr class="separator:ae10f68bc361a42141f1ab8d83c6f3fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa053df65df94a1e48cea12ec4ff185ac" id="r_aa053df65df94a1e48cea12ec4ff185ac"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE AZ::Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa053df65df94a1e48cea12ec4ff185ac">TransformVector</a> (const AZ::Vector3 &amp;v) const</td></tr>
<tr class="separator:aa053df65df94a1e48cea12ec4ff185ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b778b9922e3c5e61c2ddd9fb18b75bc" id="r_a2b778b9922e3c5e61c2ddd9fb18b75bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b778b9922e3c5e61c2ddd9fb18b75bc">ToRotationTranslation</a> (AZ::Quaternion *outRot, AZ::Vector3 *outPos) const</td></tr>
<tr class="separator:a2b778b9922e3c5e61c2ddd9fb18b75bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301e059189f106d81e0cee75cbb25365" id="r_a301e059189f106d81e0cee75cbb25365"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a301e059189f106d81e0cee75cbb25365">NormalizedToRotationTranslation</a> (AZ::Quaternion *outRot, AZ::Vector3 *outPos) const</td></tr>
<tr class="separator:a301e059189f106d81e0cee75cbb25365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad042667f44a0d09321639ecefbaff637" id="r_ad042667f44a0d09321639ecefbaff637"><td class="memItemLeft" align="right" valign="top"><a id="ad042667f44a0d09321639ecefbaff637" name="ad042667f44a0d09321639ecefbaff637"></a>
MCORE_INLINE const <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const AZ::Transform &amp;transform)</td></tr>
<tr class="separator:ad042667f44a0d09321639ecefbaff637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0408749b701b1a5d85d75384af0602ba" id="r_a0408749b701b1a5d85d75384af0602ba"><td class="memItemLeft" align="right" valign="top"><a id="a0408749b701b1a5d85d75384af0602ba" name="a0408749b701b1a5d85d75384af0602ba"></a>
MCORE_INLINE const <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;other)</td></tr>
<tr class="separator:a0408749b701b1a5d85d75384af0602ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d5dbd0391ac0b484eea2ec1874dc51" id="r_ad8d5dbd0391ac0b484eea2ec1874dc51"><td class="memItemLeft" align="right" valign="top"><a id="ad8d5dbd0391ac0b484eea2ec1874dc51" name="ad8d5dbd0391ac0b484eea2ec1874dc51"></a>
MCORE_INLINE <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> () const</td></tr>
<tr class="separator:ad8d5dbd0391ac0b484eea2ec1874dc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca857c834ae68523847db44bf9b9d79" id="r_abca857c834ae68523847db44bf9b9d79"><td class="memItemLeft" align="right" valign="top"><a id="abca857c834ae68523847db44bf9b9d79" name="abca857c834ae68523847db44bf9b9d79"></a>
MCORE_INLINE const <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;q)</td></tr>
<tr class="separator:abca857c834ae68523847db44bf9b9d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b397db01bc01bea60c7a755213a08d" id="r_a32b397db01bc01bea60c7a755213a08d"><td class="memItemLeft" align="right" valign="top"><a id="a32b397db01bc01bea60c7a755213a08d" name="a32b397db01bc01bea60c7a755213a08d"></a>
MCORE_INLINE const <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;q)</td></tr>
<tr class="separator:a32b397db01bc01bea60c7a755213a08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7715ae634558d027969b28ffbcfad9b1" id="r_a7715ae634558d027969b28ffbcfad9b1"><td class="memItemLeft" align="right" valign="top"><a id="a7715ae634558d027969b28ffbcfad9b1" name="a7715ae634558d027969b28ffbcfad9b1"></a>
MCORE_INLINE const <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;q)</td></tr>
<tr class="separator:a7715ae634558d027969b28ffbcfad9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4629960e8b4bf49171dfe6cbcfb3253d" id="r_a4629960e8b4bf49171dfe6cbcfb3253d"><td class="memItemLeft" align="right" valign="top"><a id="a4629960e8b4bf49171dfe6cbcfb3253d" name="a4629960e8b4bf49171dfe6cbcfb3253d"></a>
MCORE_INLINE const <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (float f)</td></tr>
<tr class="separator:a4629960e8b4bf49171dfe6cbcfb3253d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aae133b50d2267736ffc6e737aa5baec4" id="r_aae133b50d2267736ffc6e737aa5baec4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae133b50d2267736ffc6e737aa5baec4">ConvertFromTransform</a> (const AZ::Transform &amp;transform)</td></tr>
<tr class="separator:aae133b50d2267736ffc6e737aa5baec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47070d14757aa6848fa6698c17c2f3ac" id="r_a47070d14757aa6848fa6698c17c2f3ac"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47070d14757aa6848fa6698c17c2f3ac">ConvertFromRotationTranslation</a> (const AZ::Quaternion &amp;rotation, const AZ::Vector3 &amp;translation)</td></tr>
<tr class="separator:a47070d14757aa6848fa6698c17c2f3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a374ea64188a7bffdedfc217a0e3836e1" id="r_a374ea64188a7bffdedfc217a0e3836e1"><td class="memItemLeft" align="right" valign="top">AZ::Quaternion&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a374ea64188a7bffdedfc217a0e3836e1">m_real</a></td></tr>
<tr class="separator:a374ea64188a7bffdedfc217a0e3836e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001312034b0fb46bd7224b8027026b24" id="r_a001312034b0fb46bd7224b8027026b24"><td class="memItemLeft" align="right" valign="top">AZ::Quaternion&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a001312034b0fb46bd7224b8027026b24">m_dual</a></td></tr>
<tr class="separator:a001312034b0fb46bd7224b8027026b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The dual quaternion class. Dual quaternions contain two internal vectors. The real and dual part. They behave very similar to regular quaternions in usage. The difference is that the dual quaternion can represent both a rotation and translation or displacement. The dual quaternion consists of a real part, which you can see as the rotation quaternion, and a dual part, which you can see as the translation part. One of the advantages of dual quaternions is that they can be used to replace the linear skin deformations with a volume preserving method. Using dual quaternions in skinning fixes issues such as the famous candy-wrapper effect. It handles twisting of bones much nicer compared to the linear method. This is often referred to as dual quaternion skinning. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a58b5361170af9050353d95ebce681e73" name="a58b5361170af9050353d95ebce681e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b5361170af9050353d95ebce681e73">&#9670;&#160;</a></span>DualQuaternion() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE MCore::DualQuaternion::DualQuaternion </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default constructor. This automatically initializes the dual quaternion to identity. </p>

</div>
</div>
<a id="a63c1ae3b00a259c14da072e030007d6e" name="a63c1ae3b00a259c14da072e030007d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c1ae3b00a259c14da072e030007d6e">&#9670;&#160;</a></span>DualQuaternion() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE MCore::DualQuaternion::DualQuaternion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The dual quaternion to copy the data from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae68397ef5b09de93af7f58b3b0f0b27" name="aae68397ef5b09de93af7f58b3b0f0b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae68397ef5b09de93af7f58b3b0f0b27">&#9670;&#160;</a></span>DualQuaternion() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE MCore::DualQuaternion::DualQuaternion </td>
          <td>(</td>
          <td class="paramtype">const AZ::Quaternion &amp;</td>          <td class="paramname"><span class="paramname"><em>real</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Quaternion &amp;</td>          <td class="paramname"><span class="paramname"><em>dual</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extended constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">real</td><td>The real part, which is the rotation part. </td></tr>
    <tr><td class="paramname">dual</td><td>The dual part, which is you can see as the translation part. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not directly put in the translation into the dual part, if you want to convert from a rotation and translation, please use the other constructor or use the FromRotationTranslation method. </dd></dl>

</div>
</div>
<a id="a45804ed7d50727634e149877ab2ea955" name="a45804ed7d50727634e149877ab2ea955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45804ed7d50727634e149877ab2ea955">&#9670;&#160;</a></span>DualQuaternion() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE MCore::DualQuaternion::DualQuaternion </td>
          <td>(</td>
          <td class="paramtype">const AZ::Transform &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor which takes a matrix as input parameter. This converts the rotation of the specified matrix into a quaternion. Please keep in mind that the matrix may NOT contain any scaling, so if it does, please normalize your matrix first! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to initialize the quaternion from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5aea917d4c6b5e49cfc1134f46bef3a" name="aa5aea917d4c6b5e49cfc1134f46bef3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5aea917d4c6b5e49cfc1134f46bef3a">&#9670;&#160;</a></span>DualQuaternion() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE DualQuaternion::DualQuaternion </td>
          <td>(</td>
          <td class="paramtype">const AZ::Quaternion &amp;</td>          <td class="paramname"><span class="paramname"><em>rotation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;</td>          <td class="paramname"><span class="paramname"><em>translation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extended constructor, which initializes this dual quaternion from a rotation and translation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>The rotation quaternion, which does not need to be normalized, unless you want this to be a normalized dual quaternion. </td></tr>
    <tr><td class="paramname">translation</td><td>The translation vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a675f7f76e1eb0833c21acfb4b3f0651b" name="a675f7f76e1eb0833c21acfb4b3f0651b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675f7f76e1eb0833c21acfb4b3f0651b">&#9670;&#160;</a></span>Conjugate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp; MCore::DualQuaternion::Conjugate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Conjugate this dual quaternion. </p><dl class="section return"><dt>Returns</dt><dd>A reference to this dual quaternion, but now conjugaged. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you want to inverse a unit quaternion, you can use the conjugate instead, as that gives the same result, but is much faster to calculate. </dd></dl>

</div>
</div>
<a id="a88bdcab90eb00af57482c4f1a3861292" name="a88bdcab90eb00af57482c4f1a3861292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bdcab90eb00af57482c4f1a3861292">&#9670;&#160;</a></span>Conjugated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> MCore::DualQuaternion::Conjugated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate a conjugated version of this dual quaternion. </p><dl class="section return"><dt>Returns</dt><dd>A copy of this dual quaternion, but conjugated. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you want to inverse a unit quaternion, you can use the conjugate instead, as that gives the same result, but is much faster to calculate. </dd></dl>

</div>
</div>
<a id="a47070d14757aa6848fa6698c17c2f3ac" name="a47070d14757aa6848fa6698c17c2f3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47070d14757aa6848fa6698c17c2f3ac">&#9670;&#160;</a></span>ConvertFromRotationTranslation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> MCore::DualQuaternion::ConvertFromRotationTranslation </td>
          <td>(</td>
          <td class="paramtype">const AZ::Quaternion &amp;</td>          <td class="paramname"><span class="paramname"><em>rotation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;</td>          <td class="paramname"><span class="paramname"><em>translation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a rotation and translation into a dual quaternion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>The rotation quaternion, which does not need to be normalized. </td></tr>
    <tr><td class="paramname">translation</td><td>The translation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dual quaternion representing the same rotation and translation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If your input quaternion is not normalized, then the dual quaternion will also not be normalized. </dd></dl>

</div>
</div>
<a id="aae133b50d2267736ffc6e737aa5baec4" name="aae133b50d2267736ffc6e737aa5baec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae133b50d2267736ffc6e737aa5baec4">&#9670;&#160;</a></span>ConvertFromTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> MCore::DualQuaternion::ConvertFromTransform </td>
          <td>(</td>
          <td class="paramtype">const AZ::Transform &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a matrix into a quaternion. Please keep in mind that the specified matrix may NOT contain any scaling! So make sure the matrix has been normalized before, if it contains any scale. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to extract the rotation from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The quaternion, now containing the rotation of the given matrix, in quaternion form. </dd></dl>

</div>
</div>
<a id="a1cf99501ec46fa2a7dc53acaae459671" name="a1cf99501ec46fa2a7dc53acaae459671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf99501ec46fa2a7dc53acaae459671">&#9670;&#160;</a></span>Dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE AZ::Vector2 MCore::DualQuaternion::Dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the dot product between the two dual quaternions. This basically performs two dot products: One on the real part and one on the dual part. That means that it also results in two float values, which is why a Vector2 is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other dual quaternion to perform the dot product with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 2D vector containing the result of the dot products. The x component contains the result of the dot between the real part and the y component contains the result of the dot product between the dual parts. </dd></dl>

</div>
</div>
<a id="a21a1f062315f173101633a4aae9c3df5" name="a21a1f062315f173101633a4aae9c3df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a1f062315f173101633a4aae9c3df5">&#9670;&#160;</a></span>FromRotationTranslation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void MCore::DualQuaternion::FromRotationTranslation </td>
          <td>(</td>
          <td class="paramtype">const AZ::Quaternion &amp;</td>          <td class="paramname"><span class="paramname"><em>rot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Vector3 &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize this dual quaternion from a rotation and translation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rot</td><td>The rotation quaternion. </td></tr>
    <tr><td class="paramname">pos</td><td>The translation vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is allowed to pass an un-normalized quaternion to the rotation parameter. This however will also result in a non-normalized dual quaternion. </dd></dl>

</div>
</div>
<a id="a680aed54daf0bfec883a1f5e0eda25d4" name="a680aed54daf0bfec883a1f5e0eda25d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680aed54daf0bfec883a1f5e0eda25d4">&#9670;&#160;</a></span>FromTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void MCore::DualQuaternion::FromTransform </td>
          <td>(</td>
          <td class="paramtype">const AZ::Transform &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize the current quaternion from a specified matrix. Please note that the matrix may not contain any scaling! So make sure the matrix has been normalized before, if it contains any scale. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to initialize the quaternion from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c39edb29b0eb713d6ad1563958ee767" name="a5c39edb29b0eb713d6ad1563958ee767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c39edb29b0eb713d6ad1563958ee767">&#9670;&#160;</a></span>Identity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp; MCore::DualQuaternion::Identity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the dual quaternion to identity, so that it has basically no transform. The default constructor already puts the dual quaternion in its identity transform. </p><dl class="section return"><dt>Returns</dt><dd>A reference to this quaternion, but now having an identity transform. </dd></dl>

</div>
</div>
<a id="a2c3d25bb9edec55e21ed533bc591baf7" name="a2c3d25bb9edec55e21ed533bc591baf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3d25bb9edec55e21ed533bc591baf7">&#9670;&#160;</a></span>Inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp; MCore::DualQuaternion::Inverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inverse this dual quaternion. </p><dl class="section return"><dt>Returns</dt><dd>A reference to this dual quaternion, but now inversed. </dd></dl>

</div>
</div>
<a id="af6f3b8b6b3d544cb6c9662f0af837192" name="af6f3b8b6b3d544cb6c9662f0af837192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f3b8b6b3d544cb6c9662f0af837192">&#9670;&#160;</a></span>Inversed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> MCore::DualQuaternion::Inversed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate an inversed version of this dual quaternion. </p><dl class="section return"><dt>Returns</dt><dd>A copy of this dual quaternion, but then inversed. </dd></dl>

</div>
</div>
<a id="aa481538fce4112591122dc7a6760d9c2" name="aa481538fce4112591122dc7a6760d9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa481538fce4112591122dc7a6760d9c2">&#9670;&#160;</a></span>Length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE AZ::Vector2 MCore::DualQuaternion::Length </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the length of the dual quaternion. This results in a 2D vector, because it calculates the length for both the real and dual parts. The result of the real part will be stored in the x component of the 2D vector, and the result of the dual part will be stored in the y component. </p><dl class="section return"><dt>Returns</dt><dd>The 2D vector containing the length of the real and dual part. </dd></dl>

</div>
</div>
<a id="ae7b42957cb44d032ea661f52cb41311d" name="ae7b42957cb44d032ea661f52cb41311d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b42957cb44d032ea661f52cb41311d">&#9670;&#160;</a></span>Normalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> &amp; MCore::DualQuaternion::Normalize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Normalize the dual quaternion. </p><dl class="section return"><dt>Returns</dt><dd>A reference to this same quaternion, but now normalized. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Please keep in mind that zero length quaternions will result in a division by zero! </dd></dl>

</div>
</div>
<a id="a813fc0c5e0eb9fd55523797e6e60d274" name="a813fc0c5e0eb9fd55523797e6e60d274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813fc0c5e0eb9fd55523797e6e60d274">&#9670;&#160;</a></span>Normalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE <a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a> MCore::DualQuaternion::Normalized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the normalized version of this dual quaternion. </p><dl class="section return"><dt>Returns</dt><dd>A copy of this dual quaternion, but then normalized. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Please keep in mind that zero length quaternions will result in a division by zero! </dd></dl>

</div>
</div>
<a id="a301e059189f106d81e0cee75cbb25365" name="a301e059189f106d81e0cee75cbb25365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301e059189f106d81e0cee75cbb25365">&#9670;&#160;</a></span>NormalizedToRotationTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::DualQuaternion::NormalizedToRotationTranslation </td>
          <td>(</td>
          <td class="paramtype">AZ::Quaternion *</td>          <td class="paramname"><span class="paramname"><em>outRot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 *</td>          <td class="paramname"><span class="paramname"><em>outPos</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the rotation and translation from this dual normalized quaternion. This method assumes that this dual quaternion is normalized. If it isn't, the resulting output will be incorrect! If you are not sure this quaternion is not normalized, or if you know it is not, please use the ToRotationTranslation method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outRot</td><td>A pointer to the quaternion in which we will store the output rotation. </td></tr>
    <tr><td class="paramname">outPos</td><td>A pointer to the vector in which we will store the output translation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a97df76cb4193649df36b07b2499432" name="a7a97df76cb4193649df36b07b2499432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a97df76cb4193649df36b07b2499432">&#9670;&#160;</a></span>Set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void MCore::DualQuaternion::Set </td>
          <td>(</td>
          <td class="paramtype">const AZ::Quaternion &amp;</td>          <td class="paramname"><span class="paramname"><em>real</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Quaternion &amp;</td>          <td class="paramname"><span class="paramname"><em>dual</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the real and dual part of the dual quaternion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">real</td><td>The real part, which represents the rotation. </td></tr>
    <tr><td class="paramname">dual</td><td>The dual part, which represents the translation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Please keep in mind that you should not set the translation directly into the dual part. If you want to initialize the dual quaternion from a rotation and translation, please use the special constructor for this, or the FromRotationTranslation method. </dd></dl>

</div>
</div>
<a id="a2b778b9922e3c5e61c2ddd9fb18b75bc" name="a2b778b9922e3c5e61c2ddd9fb18b75bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b778b9922e3c5e61c2ddd9fb18b75bc">&#9670;&#160;</a></span>ToRotationTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::DualQuaternion::ToRotationTranslation </td>
          <td>(</td>
          <td class="paramtype">AZ::Quaternion *</td>          <td class="paramname"><span class="paramname"><em>outRot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 *</td>          <td class="paramname"><span class="paramname"><em>outPos</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the rotation and translation from this dual quaternion. This method handles non-unit dual quaternions fine. If you are sure your dual quaternion is normalized, you should use the faster version of this method, which is called NormalizedToRotationTranslation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outRot</td><td>A pointer to the quaternion in which we will store the output rotation. </td></tr>
    <tr><td class="paramname">outPos</td><td>A pointer to the vector in which we will store the output translation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55e05184e54232c6f3607480f673cd6f" name="a55e05184e54232c6f3607480f673cd6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e05184e54232c6f3607480f673cd6f">&#9670;&#160;</a></span>ToTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AZ::Transform MCore::DualQuaternion::ToTransform </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert this dual quaternion into a 4x4 matrix. </p><dl class="section return"><dt>Returns</dt><dd>A matrix, representing the same transformation as this dual quaternion. </dd></dl>

</div>
</div>
<a id="ae10f68bc361a42141f1ab8d83c6f3fce" name="ae10f68bc361a42141f1ab8d83c6f3fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10f68bc361a42141f1ab8d83c6f3fce">&#9670;&#160;</a></span>TransformPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE AZ::Vector3 DualQuaternion::TransformPoint </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform a 3D point with this dual quaternion. This applies both a rotation and possible translation to the point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The 3D point to transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed point. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you want to transform a vector instead of a point, please use the TransformVector method. </dd></dl>

</div>
</div>
<a id="aa053df65df94a1e48cea12ec4ff185ac" name="aa053df65df94a1e48cea12ec4ff185ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa053df65df94a1e48cea12ec4ff185ac">&#9670;&#160;</a></span>TransformVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE AZ::Vector3 DualQuaternion::TransformVector </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform a 3D vector with this dual quaternion. This will apply only the rotation part of this dual quaternion. So it will not apply any displacement caused by the dual part of this dual quaternion. You should use this method when transforming normals and tangents for example. You can use the TransformPoint method to transform 3D points. This vector transform is also faster than the TransformPoint method, as it has to do fewer calculations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed vector. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a001312034b0fb46bd7224b8027026b24" name="a001312034b0fb46bd7224b8027026b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001312034b0fb46bd7224b8027026b24">&#9670;&#160;</a></span>m_dual</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AZ::Quaternion MCore::DualQuaternion::m_dual</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The dual part, which you can see as the translation part. </p>

</div>
</div>
<a id="a374ea64188a7bffdedfc217a0e3836e1" name="a374ea64188a7bffdedfc217a0e3836e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374ea64188a7bffdedfc217a0e3836e1">&#9670;&#160;</a></span>m_real</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AZ::Quaternion MCore::DualQuaternion::m_real</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The real value, which you can see as the regular rotation quaternion. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Gems/EMotionFX/Code/MCore/Source/<b>DualQuaternion.h</b></li>
<li>Gems/EMotionFX/Code/MCore/Source/<b>DualQuaternion.inl</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>MCore</b></li><li class="navelem"><a class="el" href="class_m_core_1_1_dual_quaternion.html">DualQuaternion</a></li>
    <li class="footer">Generated on Mon Oct 7 2024 17:14:57 for Open 3D Engine EMotionFX Gem API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
