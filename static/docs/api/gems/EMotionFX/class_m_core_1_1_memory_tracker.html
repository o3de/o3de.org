<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine EMotionFX Gem API Reference: MCore::MemoryTracker Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Open 3D Engine EMotionFX Gem API Reference<span id="projectnumber">&#160;24.09</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_m_core_1_1_memory_tracker.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_m_core_1_1_memory_tracker-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">MCore::MemoryTracker Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;MemoryTracker.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_core_1_1_memory_tracker_1_1_allocation.html">Allocation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_core_1_1_memory_tracker_1_1_category_stats.html">CategoryStats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_core_1_1_memory_tracker_1_1_global_stats.html">GlobalStats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_core_1_1_memory_tracker_1_1_group.html">Group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_core_1_1_memory_tracker_1_1_group_stats.html">GroupStats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5ba5fd8fba6d8f29517703205c9caf01" id="r_a5ba5fd8fba6d8f29517703205c9caf01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ba5fd8fba6d8f29517703205c9caf01">MemoryTracker</a> ()</td></tr>
<tr class="separator:a5ba5fd8fba6d8f29517703205c9caf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde36bc51ba416d08b1cb71817e0d278" id="r_adde36bc51ba416d08b1cb71817e0d278"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adde36bc51ba416d08b1cb71817e0d278">~MemoryTracker</a> ()</td></tr>
<tr class="separator:adde36bc51ba416d08b1cb71817e0d278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5d9259bb2cdbb667b9fba05164f2a1" id="r_a4a5d9259bb2cdbb667b9fba05164f2a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a5d9259bb2cdbb667b9fba05164f2a1">RegisterAlloc</a> (void *memAddress, size_t numBytes, uint32 categoryID)</td></tr>
<tr class="separator:a4a5d9259bb2cdbb667b9fba05164f2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae824618bdaf8268501cdcc8156c893d" id="r_aae824618bdaf8268501cdcc8156c893d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae824618bdaf8268501cdcc8156c893d">RegisterRealloc</a> (void *oldAddress, void *newAddress, size_t numBytes, uint32 categoryID)</td></tr>
<tr class="separator:aae824618bdaf8268501cdcc8156c893d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99b45089567c4d3d2b38f0e226827fa" id="r_ad99b45089567c4d3d2b38f0e226827fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad99b45089567c4d3d2b38f0e226827fa">RegisterFree</a> (void *memAddress)</td></tr>
<tr class="separator:ad99b45089567c4d3d2b38f0e226827fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892e5663b8d9b60b1a44620ff99ffd02" id="r_a892e5663b8d9b60b1a44620ff99ffd02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a892e5663b8d9b60b1a44620ff99ffd02">RegisterCategory</a> (uint32 categoryID, const char *name)</td></tr>
<tr class="separator:a892e5663b8d9b60b1a44620ff99ffd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7042dab6f7dc3258050553c290dbe005" id="r_a7042dab6f7dc3258050553c290dbe005"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7042dab6f7dc3258050553c290dbe005">Clear</a> ()</td></tr>
<tr class="separator:a7042dab6f7dc3258050553c290dbe005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab578cb02ce453f75ddcacc2e8061b20d" id="r_ab578cb02ce453f75ddcacc2e8061b20d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_m_core_1_1_memory_tracker_1_1_global_stats.html">GlobalStats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab578cb02ce453f75ddcacc2e8061b20d">GetGlobalStats</a> () const</td></tr>
<tr class="separator:ab578cb02ce453f75ddcacc2e8061b20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1b7dc483b50f1e8a3000a0d1bbe38c" id="r_add1b7dc483b50f1e8a3000a0d1bbe38c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add1b7dc483b50f1e8a3000a0d1bbe38c">GetCategoryStatistics</a> (uint32 categoryID, <a class="el" href="struct_m_core_1_1_memory_tracker_1_1_category_stats.html">CategoryStats</a> *outStats)</td></tr>
<tr class="separator:add1b7dc483b50f1e8a3000a0d1bbe38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b818e961fd3f08ae6043fb0835ee8dc" id="r_a4b818e961fd3f08ae6043fb0835ee8dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b818e961fd3f08ae6043fb0835ee8dc">RegisterGroup</a> (uint32 groupID, const char *name, const std::vector&lt; uint32 &gt; &amp;categories)</td></tr>
<tr class="separator:a4b818e961fd3f08ae6043fb0835ee8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbca1004b52857f277a9985a617c5be" id="r_a3bbca1004b52857f277a9985a617c5be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bbca1004b52857f277a9985a617c5be">GetGroupStatistics</a> (uint32 groupID, <a class="el" href="struct_m_core_1_1_memory_tracker_1_1_group_stats.html">GroupStats</a> *outGroupStats)</td></tr>
<tr class="separator:a3bbca1004b52857f277a9985a617c5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6bf052819bb848627a3d19d0ba75f7" id="r_acb6bf052819bb848627a3d19d0ba75f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb6bf052819bb848627a3d19d0ba75f7">UpdateGroupStatistics</a> ()</td></tr>
<tr class="separator:acb6bf052819bb848627a3d19d0ba75f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5145c7b2bd1b4baec20ef3569f57b37f" id="r_a5145c7b2bd1b4baec20ef3569f57b37f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5145c7b2bd1b4baec20ef3569f57b37f">LogStatistics</a> (bool currentlyAllocatedOnly=true)</td></tr>
<tr class="separator:a5145c7b2bd1b4baec20ef3569f57b37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d2a63131cc3f293588cacd47416606" id="r_a33d2a63131cc3f293588cacd47416606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33d2a63131cc3f293588cacd47416606">LogLeaks</a> ()</td></tr>
<tr class="separator:a33d2a63131cc3f293588cacd47416606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466a87733919117f29d7a535703a3fb2" id="r_a466a87733919117f29d7a535703a3fb2"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; void *, <a class="el" href="struct_m_core_1_1_memory_tracker_1_1_allocation.html">Allocation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a466a87733919117f29d7a535703a3fb2">GetAllocations</a> () const</td></tr>
<tr class="separator:a466a87733919117f29d7a535703a3fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565cee0b21ecbeda61c48296b721eba1" id="r_a565cee0b21ecbeda61c48296b721eba1"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; uint32, <a class="el" href="struct_m_core_1_1_memory_tracker_1_1_group.html">Group</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a565cee0b21ecbeda61c48296b721eba1">GetGroups</a> () const</td></tr>
<tr class="separator:a565cee0b21ecbeda61c48296b721eba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af9a5903893001226caf8d776bb8f11" id="r_a2af9a5903893001226caf8d776bb8f11"><td class="memItemLeft" align="right" valign="top">const std::map&lt; uint32, <a class="el" href="struct_m_core_1_1_memory_tracker_1_1_category_stats.html">CategoryStats</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2af9a5903893001226caf8d776bb8f11">GetCategories</a> () const</td></tr>
<tr class="separator:a2af9a5903893001226caf8d776bb8f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace789a0cb9794041fa747b2c7bc19bcc" id="r_ace789a0cb9794041fa747b2c7bc19bcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace789a0cb9794041fa747b2c7bc19bcc">Lock</a> ()</td></tr>
<tr class="separator:ace789a0cb9794041fa747b2c7bc19bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39664798a8ddac0acc0704214df68a0f" id="r_a39664798a8ddac0acc0704214df68a0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39664798a8ddac0acc0704214df68a0f">Unlock</a> ()</td></tr>
<tr class="separator:a39664798a8ddac0acc0704214df68a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The memory tracker, used to track memory usage. This class can be used to get detailed information about memory usage on a per category or global basis. It can also be used to track memory leaks. Internally it does not use any of MCore's functionality so that it does not polute the memory usage statistics. The tracker is multithread safe, so you can call it in multiple threads. Also the RegisterAlloc, RegisterRealloc and RegisterFree functions do not actually perform the allocations or frees, but are purely there for statistical tracking. You can use the LogLeaks method at application shutdown to log memory leaks. To log current memory statistics you can call LogStatistics at any moment. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5ba5fd8fba6d8f29517703205c9caf01" name="a5ba5fd8fba6d8f29517703205c9caf01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba5fd8fba6d8f29517703205c9caf01">&#9670;&#160;</a></span>MemoryTracker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCore::MemoryTracker::MemoryTracker </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The constructor. </p>

</div>
</div>
<a id="adde36bc51ba416d08b1cb71817e0d278" name="adde36bc51ba416d08b1cb71817e0d278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde36bc51ba416d08b1cb71817e0d278">&#9670;&#160;</a></span>~MemoryTracker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCore::MemoryTracker::~MemoryTracker </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7042dab6f7dc3258050553c290dbe005" name="a7042dab6f7dc3258050553c290dbe005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7042dab6f7dc3258050553c290dbe005">&#9670;&#160;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::MemoryTracker::Clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the tracker, clearing any information about its allocations and memory categories. This clears all categories as well, so it will be like no categories have been registered or internally created. </p>

</div>
</div>
<a id="a466a87733919117f29d7a535703a3fb2" name="a466a87733919117f29d7a535703a3fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466a87733919117f29d7a535703a3fb2">&#9670;&#160;</a></span>GetAllocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt; void *, <a class="el" href="struct_m_core_1_1_memory_tracker_1_1_allocation.html">Allocation</a> &gt; &amp; MCore::MemoryTracker::GetAllocations </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current collection of allocations. The allocations are stored in an unordered map with the memory address as key. Keep in mind that for thread safety you should lock the memory tracker using the Lock method, while you read the returned data, after which you should call Unlock again. </p><dl class="section return"><dt>Returns</dt><dd>The unordered map that contains each allocation. </dd></dl>

</div>
</div>
<a id="a2af9a5903893001226caf8d776bb8f11" name="a2af9a5903893001226caf8d776bb8f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af9a5903893001226caf8d776bb8f11">&#9670;&#160;</a></span>GetCategories()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; uint32, <a class="el" href="struct_m_core_1_1_memory_tracker_1_1_category_stats.html">CategoryStats</a> &gt; &amp; MCore::MemoryTracker::GetCategories </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the collection of registered categories. The categories are stored in an ordered map, ordered on category ID, which is also the key. Keep in mind that for thread safety you should lock the memory tracker using the Lock method, while you read the returned data, after which you should call Unlock again. </p><dl class="section return"><dt>Returns</dt><dd>The ordered map that contains all categories. </dd></dl>

</div>
</div>
<a id="add1b7dc483b50f1e8a3000a0d1bbe38c" name="add1b7dc483b50f1e8a3000a0d1bbe38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1b7dc483b50f1e8a3000a0d1bbe38c">&#9670;&#160;</a></span>GetCategoryStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MCore::MemoryTracker::GetCategoryStatistics </td>
          <td>(</td>
          <td class="paramtype">uint32</td>          <td class="paramname"><span class="paramname"><em>categoryID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_core_1_1_memory_tracker_1_1_category_stats.html">CategoryStats</a> *</td>          <td class="paramname"><span class="paramname"><em>outStats</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get statistics about a given memory category. This is thread-safe and internally locks and unlocks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">categoryID</td><td>The memory category ID. </td></tr>
    <tr><td class="paramname">outStats</td><td>The statistics for this given memory category. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the category statistics have been found and output, or false when no such category currently exists. In the case it returns false the outStats parameter remains untouched. </dd></dl>

</div>
</div>
<a id="ab578cb02ce453f75ddcacc2e8061b20d" name="ab578cb02ce453f75ddcacc2e8061b20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab578cb02ce453f75ddcacc2e8061b20d">&#9670;&#160;</a></span>GetGlobalStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_m_core_1_1_memory_tracker_1_1_global_stats.html">GlobalStats</a> &amp; MCore::MemoryTracker::GetGlobalStats </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the global memory usage statistics. This gives information like the current memory usage in total. If you would like more detailed information about what categories use what amount of memory, use the GetCategoryStats method. </p><dl class="section return"><dt>Returns</dt><dd>The global memory statistics. </dd></dl>

</div>
</div>
<a id="a565cee0b21ecbeda61c48296b721eba1" name="a565cee0b21ecbeda61c48296b721eba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565cee0b21ecbeda61c48296b721eba1">&#9670;&#160;</a></span>GetGroups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt; uint32, <a class="el" href="struct_m_core_1_1_memory_tracker_1_1_group.html">Group</a> &gt; &amp; MCore::MemoryTracker::GetGroups </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the collection of registered groups. The groups are stored in an unordered map with the group ID as key. Keep in mind that for thread safety you should lock the memory tracker using the Lock method, while you read the returned data, after which you should call Unlock again. </p><dl class="section return"><dt>Returns</dt><dd>The unordered map that contains all groups. </dd></dl>

</div>
</div>
<a id="a3bbca1004b52857f277a9985a617c5be" name="a3bbca1004b52857f277a9985a617c5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbca1004b52857f277a9985a617c5be">&#9670;&#160;</a></span>GetGroupStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MCore::MemoryTracker::GetGroupStatistics </td>
          <td>(</td>
          <td class="paramtype">uint32</td>          <td class="paramname"><span class="paramname"><em>groupID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_core_1_1_memory_tracker_1_1_group_stats.html">GroupStats</a> *</td>          <td class="paramname"><span class="paramname"><em>outGroupStats</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the statistics for a given group. When the given groupID does not exist, this method will instantly return and outGroupStats will remain untouched. Please keep in mind that the group statistics are not actively tracked. You need to call UpdateGroupStatistics to refresh the statistics for all groups. You can call UpdateGroupStatistics once and then call GetGroupStatistics for each group. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupID</td><td>The unique ID of the group. </td></tr>
    <tr><td class="paramname">outGroupStats</td><td>A pointer to the group statistics struct that will contain the statistics for this group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace789a0cb9794041fa747b2c7bc19bcc" name="ace789a0cb9794041fa747b2c7bc19bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace789a0cb9794041fa747b2c7bc19bcc">&#9670;&#160;</a></span>Lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::MemoryTracker::Lock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock the contents of this memory tracker using a multithread mutex. </p>

</div>
</div>
<a id="a33d2a63131cc3f293588cacd47416606" name="a33d2a63131cc3f293588cacd47416606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d2a63131cc3f293588cacd47416606">&#9670;&#160;</a></span>LogLeaks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::MemoryTracker::LogLeaks </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log all current active allocations as leaks. This will log the leaking category stats as well as all individual allocations. This should be called at application shutdown. The logging will NOT output to a log file, but print the data to the debug output. This can be stdout, using printf or on Windows using OutputDebugString to display it inside the Visual Studio output window. This is thread-safe and internally locks and unlocks. </p>

</div>
</div>
<a id="a5145c7b2bd1b4baec20ef3569f57b37f" name="a5145c7b2bd1b4baec20ef3569f57b37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5145c7b2bd1b4baec20ef3569f57b37f">&#9670;&#160;</a></span>LogStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::MemoryTracker::LogStatistics </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>currentlyAllocatedOnly</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log information about all allocations that have been done and are currently active. The logging will NOT output to a log file, but print the data to the debug output. This can be stdout, using printf or on Windows using OutputDebugString to display it inside the Visual Studio output window. This is thread-safe and internally locks and unlocks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentlyAllocatedOnly</td><td>When set to true it will only log categories that currently have active allocations that haven't been freed yet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a5d9259bb2cdbb667b9fba05164f2a1" name="a4a5d9259bb2cdbb667b9fba05164f2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5d9259bb2cdbb667b9fba05164f2a1">&#9670;&#160;</a></span>RegisterAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::MemoryTracker::RegisterAlloc </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>memAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numBytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32</td>          <td class="paramname"><span class="paramname"><em>categoryID</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a given memory allocation. This does not perform the actual allocation but just updates the internal statistics inside the memory tracker. This is thread-safe and internally locks and unlocks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memAddress</td><td>The memory address of the memory that just has been allocated and you want to register inside the tracker. This could be the address returned by a malloc for example. </td></tr>
    <tr><td class="paramname">numBytes</td><td>The number of bytes that has been allocated. </td></tr>
    <tr><td class="paramname">categoryID</td><td>The category ID of the memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a892e5663b8d9b60b1a44620ff99ffd02" name="a892e5663b8d9b60b1a44620ff99ffd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892e5663b8d9b60b1a44620ff99ffd02">&#9670;&#160;</a></span>RegisterCategory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::MemoryTracker::RegisterCategory </td>
          <td>(</td>
          <td class="paramtype">uint32</td>          <td class="paramname"><span class="paramname"><em>categoryID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a memory category (optional). This method can be used to provide a user string based name to a given category ID. You can do this at any time. If the category does not exist, it will be automatically created. If it already exists because allocations have been done inside this category then it will simply update the existing name. This is thread-safe and internally locks and unlocks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">categoryID</td><td>The memory category identifier. </td></tr>
    <tr><td class="paramname">name</td><td>The name you would like this category to have. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad99b45089567c4d3d2b38f0e226827fa" name="ad99b45089567c4d3d2b38f0e226827fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99b45089567c4d3d2b38f0e226827fa">&#9670;&#160;</a></span>RegisterFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::MemoryTracker::RegisterFree </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>memAddress</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a free of a given memory address. This does not perform the release of the memory, but purely updates the statistics internally inside the tracker. This is thread-safe and internally locks and unlocks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memAddress</td><td>The memory address of the memory that is being freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b818e961fd3f08ae6043fb0835ee8dc" name="a4b818e961fd3f08ae6043fb0835ee8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b818e961fd3f08ae6043fb0835ee8dc">&#9670;&#160;</a></span>RegisterGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::MemoryTracker::RegisterGroup </td>
          <td>(</td>
          <td class="paramtype">uint32</td>          <td class="paramname"><span class="paramname"><em>groupID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint32 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>categories</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a group by providing a group ID and a list of categories that the group should track. If you make multiple calls to RegisterGroup, it will merge the categories if the same group ID is provided. So you can add new categories by caling this method as well. If the group already exists, the name will be overwritten with the one specified. This is thread-safe and internally locks and unlocks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupID</td><td>The ID of the group you wish to register or update. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the group. </td></tr>
    <tr><td class="paramname">categories</td><td>The list of categories that should be added to the group tracking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae824618bdaf8268501cdcc8156c893d" name="aae824618bdaf8268501cdcc8156c893d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae824618bdaf8268501cdcc8156c893d">&#9670;&#160;</a></span>RegisterRealloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::MemoryTracker::RegisterRealloc </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>oldAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>newAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numBytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32</td>          <td class="paramname"><span class="paramname"><em>categoryID</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a reallocation of a given piece of memory. This does not actually perform the realloc of the memory, but just updates the statistics inside the memory tracker. This is thread-safe and internally locks and unlocks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldAddress</td><td>The original address of the memory that is being reallocated. When this is nullptr it will internally call RegisterAlloc instead using the newAddress as memory address. </td></tr>
    <tr><td class="paramname">newAddress</td><td>The new address of the memory block after it has been reallocated. </td></tr>
    <tr><td class="paramname">numBytes</td><td>The new size, in number of bytes, of the memory block that has been reallocated. </td></tr>
    <tr><td class="paramname">categoryID</td><td>The category ID of the memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39664798a8ddac0acc0704214df68a0f" name="a39664798a8ddac0acc0704214df68a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39664798a8ddac0acc0704214df68a0f">&#9670;&#160;</a></span>Unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::MemoryTracker::Unlock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlock the contents of this memory tracker using a multithread mutex. </p>

</div>
</div>
<a id="acb6bf052819bb848627a3d19d0ba75f7" name="acb6bf052819bb848627a3d19d0ba75f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6bf052819bb848627a3d19d0ba75f7">&#9670;&#160;</a></span>UpdateGroupStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCore::MemoryTracker::UpdateGroupStatistics </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the internal statistics for all groups. This is thread-safe and internally locks and unlocks. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Gems/EMotionFX/Code/MCore/Source/<b>MemoryTracker.h</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>MCore</b></li><li class="navelem"><a class="el" href="class_m_core_1_1_memory_tracker.html">MemoryTracker</a></li>
    <li class="footer">Generated on Mon Oct 7 2024 17:14:57 for Open 3D Engine EMotionFX Gem API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
