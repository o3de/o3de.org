<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine EMotionFX Gem API Reference: EMotionFX::ActorInstance Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-placeholder-text"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine EMotionFX Gem API Reference
   &#160;<span id="projectnumber">24.09</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_e_motion_f_x_1_1_actor_instance.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_e_motion_f_x_1_1_actor_instance-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">EMotionFX::ActorInstance Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;ActorInstance.h&gt;</code></p>

<p>Inherits <a class="el" href="class_m_core_1_1_ref_counted.html">MCore::RefCounted</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a194a056f8a28e8d95c25ec527a05ff6c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6c">EBoundsType</a> : AZ::u8 { <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6ca88d7ab77f647de81bc31d7d99b0d0859">BOUNDS_NODE_BASED</a> = 0
, <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6caaf23dce4d6b4db9210686ae815f720c2">BOUNDS_MESH_BASED</a> = 1
, <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6cab5421859affaf084f4025dd8e9ed5152">BOUNDS_STATIC_BASED</a> = 5
 }</td></tr>
<tr class="separator:a194a056f8a28e8d95c25ec527a05ff6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a21c6284523805aad68afe69e35298951"><td class="memItemLeft" align="right" valign="top"><a id="a21c6284523805aad68afe69e35298951"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_RTTI</b> (<a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">EMotionFX::ActorInstance</a>, &quot;{280A0170-EB6A-4E90-B2F1-E18D8EAEFB36}&quot;)</td></tr>
<tr class="separator:a21c6284523805aad68afe69e35298951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfe1131dbbb09bb13ce6409a3036253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a1cfe1131dbbb09bb13ce6409a3036253">GetActor</a> () const</td></tr>
<tr class="separator:a1cfe1131dbbb09bb13ce6409a3036253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5354268118121b05ee43038b1afc3646"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a5354268118121b05ee43038b1afc3646">GetID</a> () const</td></tr>
<tr class="separator:a5354268118121b05ee43038b1afc3646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bad79f6be78fe9f43f72b9ff048794"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#af8bad79f6be78fe9f43f72b9ff048794">SetID</a> (uint32 id)</td></tr>
<tr class="separator:af8bad79f6be78fe9f43f72b9ff048794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a5f1785ea3ffe65ba1abf6f5aee094"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_motion_system.html">MotionSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a50a5f1785ea3ffe65ba1abf6f5aee094">GetMotionSystem</a> () const</td></tr>
<tr class="separator:a50a5f1785ea3ffe65ba1abf6f5aee094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b52a9e4e042ce6271d3ff6f246c4d9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a6b52a9e4e042ce6271d3ff6f246c4d9d">SetMotionSystem</a> (<a class="el" href="class_e_motion_f_x_1_1_motion_system.html">MotionSystem</a> *newSystem, bool delCurrentFromMem=true)</td></tr>
<tr class="separator:a6b52a9e4e042ce6271d3ff6f246c4d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9ca1afba039dcc21cfe90d52fcea2d"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_anim_graph_instance.html">AnimGraphInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#acb9ca1afba039dcc21cfe90d52fcea2d">GetAnimGraphInstance</a> () const</td></tr>
<tr class="separator:acb9ca1afba039dcc21cfe90d52fcea2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4528d9c1fe0c5dc2c429ccdcf077784d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a4528d9c1fe0c5dc2c429ccdcf077784d">SetAnimGraphInstance</a> (<a class="el" href="class_e_motion_f_x_1_1_anim_graph_instance.html">AnimGraphInstance</a> *instance)</td></tr>
<tr class="separator:a4528d9c1fe0c5dc2c429ccdcf077784d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8f70add2a14f1ac284916a8f083337"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_transform_data.html">TransformData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a8b8f70add2a14f1ac284916a8f083337">GetTransformData</a> () const</td></tr>
<tr class="separator:a8b8f70add2a14f1ac284916a8f083337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f282d0d3090bf4a696271548a330c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a16f282d0d3090bf4a696271548a330c4">SetIsEnabled</a> (bool enabled)</td></tr>
<tr class="separator:a16f282d0d3090bf4a696271548a330c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f38669804377de5851f367c770136b"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a85f38669804377de5851f367c770136b">GetIsEnabled</a> () const</td></tr>
<tr class="separator:a85f38669804377de5851f367c770136b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2ce5c1e9dac4bac2a4b04b8cd671cd"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a2e2ce5c1e9dac4bac2a4b04b8cd671cd">GetIsVisible</a> () const</td></tr>
<tr class="separator:a2e2ce5c1e9dac4bac2a4b04b8cd671cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7014d484d0638bfbbf1390d921d8fc3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a7014d484d0638bfbbf1390d921d8fc3d">SetIsVisible</a> (bool isVisible)</td></tr>
<tr class="separator:a7014d484d0638bfbbf1390d921d8fc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643466acb234aea5bd98771f52b0512e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a643466acb234aea5bd98771f52b0512e">RecursiveSetIsVisible</a> (bool isVisible)</td></tr>
<tr class="separator:a643466acb234aea5bd98771f52b0512e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac252e3183877a3d995fbb19ec16d300c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#ac252e3183877a3d995fbb19ec16d300c">RecursiveSetIsVisibleTowardsRoot</a> (bool isVisible)</td></tr>
<tr class="separator:ac252e3183877a3d995fbb19ec16d300c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4715b7d6dadec79ebd022047aa3095"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a8b4715b7d6dadec79ebd022047aa3095">UpdateSkeletalLODFlags</a> ()</td></tr>
<tr class="separator:a8b4715b7d6dadec79ebd022047aa3095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fd830c2a559c4482ba1c293bab0588"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a08fd830c2a559c4482ba1c293bab0588">CalcNumDisabledNodes</a> (size_t skeletalLODLevel) const</td></tr>
<tr class="separator:a08fd830c2a559c4482ba1c293bab0588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f16faf8c204f4d01c50eb2b3cd1da4b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a2f16faf8c204f4d01c50eb2b3cd1da4b">CalcNumSkeletalLODLevels</a> () const</td></tr>
<tr class="separator:a2f16faf8c204f4d01c50eb2b3cd1da4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3879c8de8e124ef331d8981122741137"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a3879c8de8e124ef331d8981122741137">GetLODLevel</a> () const</td></tr>
<tr class="separator:a3879c8de8e124ef331d8981122741137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbb5fabd3897360ded7ed2e2a936f21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a7bbb5fabd3897360ded7ed2e2a936f21">SetLODLevel</a> (size_t level)</td></tr>
<tr class="separator:a7bbb5fabd3897360ded7ed2e2a936f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d7059a10d57fb7cc107088a0ed2759"><td class="memItemLeft" align="right" valign="top">AZ::Entity *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a24d7059a10d57fb7cc107088a0ed2759">GetEntity</a> () const</td></tr>
<tr class="separator:a24d7059a10d57fb7cc107088a0ed2759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23663761ad5bc2dc0277d926c1dad224"><td class="memItemLeft" align="right" valign="top">AZ::EntityId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a23663761ad5bc2dc0277d926c1dad224">GetEntityId</a> () const</td></tr>
<tr class="separator:a23663761ad5bc2dc0277d926c1dad224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2354656fbe2463b54d2c61c3d469daae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a2354656fbe2463b54d2c61c3d469daae">SetCustomData</a> (void *customData)</td></tr>
<tr class="separator:a2354656fbe2463b54d2c61c3d469daae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b2c0bcbba4f28ff9ab3a363652aac4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a16b2c0bcbba4f28ff9ab3a363652aac4">GetCustomData</a> () const</td></tr>
<tr class="separator:a16b2c0bcbba4f28ff9ab3a363652aac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eada870f38c1e7e0aef4e7aaf5c728"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a39eada870f38c1e7e0aef4e7aaf5c728">ApplyMorphSetup</a> ()</td></tr>
<tr class="separator:a39eada870f38c1e7e0aef4e7aaf5c728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aaf4207fd64250a544548001b07646e"><td class="memItemLeft" align="right" valign="top"><a id="a0aaf4207fd64250a544548001b07646e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateWorldTransform</b> ()</td></tr>
<tr class="separator:a0aaf4207fd64250a544548001b07646e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075ad81858e945794b3fdcbaae1475dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a075ad81858e945794b3fdcbaae1475dc">UpdateSkinningMatrices</a> ()</td></tr>
<tr class="separator:a075ad81858e945794b3fdcbaae1475dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1dfeabc2fa88713c053b686e35749c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a5c1dfeabc2fa88713c053b686e35749c">UpdateAttachments</a> ()</td></tr>
<tr class="separator:a5c1dfeabc2fa88713c053b686e35749c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab739b25487943f4cce4b9b1ed458b1dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#ab739b25487943f4cce4b9b1ed458b1dd">UpdateTransformations</a> (float timePassedInSeconds, bool updateJointTransforms=true, bool sampleMotions=true)</td></tr>
<tr class="separator:ab739b25487943f4cce4b9b1ed458b1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61b7f8e2a25d9e0380eed7ca9855312"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#ab61b7f8e2a25d9e0380eed7ca9855312">UpdateMeshDeformers</a> (float timePassedInSeconds, bool processDisabledDeformers=false)</td></tr>
<tr class="separator:ab61b7f8e2a25d9e0380eed7ca9855312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef228ac0ff11f605818e46ac0e006c0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#aef228ac0ff11f605818e46ac0e006c0a">UpdateMorphMeshDeformers</a> (float timePassedInSeconds, bool processDisabledDeformers=false)</td></tr>
<tr class="separator:aef228ac0ff11f605818e46ac0e006c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3fe52440e4ca06ae76352a9e8781c2"><td class="memItemLeft" align="right" valign="top"><a id="a2a3fe52440e4ca06ae76352a9e8781c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PostPhysicsUpdate</b> (float timePassedInSeconds)</td></tr>
<tr class="separator:a2a3fe52440e4ca06ae76352a9e8781c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150e6f6be16d6c9653e1bc599b76d2c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a150e6f6be16d6c9653e1bc599b76d2c3">SetupAutoBoundsUpdate</a> (float updateFrequencyInSeconds, <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6c">EBoundsType</a> boundsType=<a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6ca88d7ab77f647de81bc31d7d99b0d0859">BOUNDS_NODE_BASED</a>, uint32 itemFrequency=1)</td></tr>
<tr class="separator:a150e6f6be16d6c9653e1bc599b76d2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74f5f182da685aea3c845f2dd74bee7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#af74f5f182da685aea3c845f2dd74bee7">GetBoundsUpdateEnabled</a> () const</td></tr>
<tr class="separator:af74f5f182da685aea3c845f2dd74bee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22bfcce7eebb32420faea6e8412cf70"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#af22bfcce7eebb32420faea6e8412cf70">GetBoundsUpdateFrequency</a> () const</td></tr>
<tr class="separator:af22bfcce7eebb32420faea6e8412cf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe010cc32f0e73cbf2c8aee416bc51d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a8fe010cc32f0e73cbf2c8aee416bc51d">GetBoundsUpdatePassedTime</a> () const</td></tr>
<tr class="separator:a8fe010cc32f0e73cbf2c8aee416bc51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a7ac7e9fb36be1006db11c2ef73e29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6c">EBoundsType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a43a7ac7e9fb36be1006db11c2ef73e29">GetBoundsUpdateType</a> () const</td></tr>
<tr class="separator:a43a7ac7e9fb36be1006db11c2ef73e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4d9d8e78734c375ccb3da344405434"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#abf4d9d8e78734c375ccb3da344405434">GetExpandBoundsBy</a> () const</td></tr>
<tr class="separator:abf4d9d8e78734c375ccb3da344405434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6263f5eb1ece7092ba92d7872440a18"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#ae6263f5eb1ece7092ba92d7872440a18">GetBoundsUpdateItemFrequency</a> () const</td></tr>
<tr class="separator:ae6263f5eb1ece7092ba92d7872440a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f30fa140e190496c96beddc7251e64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#af6f30fa140e190496c96beddc7251e64">SetBoundsUpdateFrequency</a> (float seconds)</td></tr>
<tr class="separator:af6f30fa140e190496c96beddc7251e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4188f42607a5c5efd4da362d60f66a0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a4188f42607a5c5efd4da362d60f66a0c">SetBoundsUpdatePassedTime</a> (float seconds)</td></tr>
<tr class="separator:a4188f42607a5c5efd4da362d60f66a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82e6fa2969ceb3f646af87581dfd9fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#ae82e6fa2969ceb3f646af87581dfd9fd">SetBoundsUpdateType</a> (<a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6c">EBoundsType</a> bType)</td></tr>
<tr class="separator:ae82e6fa2969ceb3f646af87581dfd9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af418a56d1de20f36c4cf95e3aaeea6bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#af418a56d1de20f36c4cf95e3aaeea6bc">SetExpandBoundsBy</a> (float expandBy)</td></tr>
<tr class="separator:af418a56d1de20f36c4cf95e3aaeea6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993a9ee25e9cef22f26414de820ae084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a993a9ee25e9cef22f26414de820ae084">SetBoundsUpdateItemFrequency</a> (uint32 freq)</td></tr>
<tr class="separator:a993a9ee25e9cef22f26414de820ae084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ab5a91e774eb3f9a37989df0cd1124"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a18ab5a91e774eb3f9a37989df0cd1124">SetBoundsUpdateEnabled</a> (bool enable)</td></tr>
<tr class="separator:a18ab5a91e774eb3f9a37989df0cd1124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0eb8c912a68fc4a9432402a7c07da6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#af0eb8c912a68fc4a9432402a7c07da6d">UpdateBounds</a> (size_t geomLODLevel, <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6c">EBoundsType</a> boundsType=<a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6ca88d7ab77f647de81bc31d7d99b0d0859">BOUNDS_NODE_BASED</a>, uint32 itemFrequency=1)</td></tr>
<tr class="separator:af0eb8c912a68fc4a9432402a7c07da6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af832651b8cf9a541f4968f1a10371711"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#af832651b8cf9a541f4968f1a10371711">UpdateStaticBasedAabbDimensions</a> ()</td></tr>
<tr class="separator:af832651b8cf9a541f4968f1a10371711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bd0c1ca26c2a42f8de4fcc74cd5caa"><td class="memItemLeft" align="right" valign="top"><a id="a90bd0c1ca26c2a42f8de4fcc74cd5caa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetStaticBasedAabb</b> (const AZ::Aabb &amp;aabb)</td></tr>
<tr class="separator:a90bd0c1ca26c2a42f8de4fcc74cd5caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9413af5f4b18a9640799337cc9f26413"><td class="memItemLeft" align="right" valign="top"><a id="a9413af5f4b18a9640799337cc9f26413"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GetStaticBasedAabb</b> (AZ::Aabb *outAabb)</td></tr>
<tr class="separator:a9413af5f4b18a9640799337cc9f26413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9b4901c1868d1cdaf2ab0f65e67037"><td class="memItemLeft" align="right" valign="top"><a id="a2e9b4901c1868d1cdaf2ab0f65e67037"></a>
const AZ::Aabb &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetStaticBasedAabb</b> () const</td></tr>
<tr class="separator:a2e9b4901c1868d1cdaf2ab0f65e67037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21795feb0dc740c52955df9c6a67121d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a21795feb0dc740c52955df9c6a67121d">CalcStaticBasedAabb</a> (AZ::Aabb *outResult)</td></tr>
<tr class="separator:a21795feb0dc740c52955df9c6a67121d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b6ebaabe9c047938866d159aa57b5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a03b6ebaabe9c047938866d159aa57b5c">CalcNodeBasedAabb</a> (AZ::Aabb *outResult, uint32 nodeFrequency=1)</td></tr>
<tr class="separator:a03b6ebaabe9c047938866d159aa57b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d79499e9d54e5d84e021f321a06b2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a64d79499e9d54e5d84e021f321a06b2e">CalcMeshBasedAabb</a> (size_t geomLODLevel, AZ::Aabb *outResult, uint32 vertexFrequency=1)</td></tr>
<tr class="separator:a64d79499e9d54e5d84e021f321a06b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c4fa4f70b8a1c9daebbae5ba03b781"><td class="memItemLeft" align="right" valign="top">const AZ::Aabb &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#aa0c4fa4f70b8a1c9daebbae5ba03b781">GetAabb</a> () const</td></tr>
<tr class="separator:aa0c4fa4f70b8a1c9daebbae5ba03b781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac654235fbf660ac22d2766c950ef8865"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#ac654235fbf660ac22d2766c950ef8865">SetAabb</a> (const AZ::Aabb &amp;aabb)</td></tr>
<tr class="separator:ac654235fbf660ac22d2766c950ef8865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46463a57b1c2d09d76b95214ac97a57b"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a46463a57b1c2d09d76b95214ac97a57b">SetLocalSpacePosition</a> (const AZ::Vector3 &amp;position)</td></tr>
<tr class="separator:a46463a57b1c2d09d76b95214ac97a57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44baacd12e3c6df7c1d2493ccad7dc9b"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a44baacd12e3c6df7c1d2493ccad7dc9b">SetLocalSpaceRotation</a> (const AZ::Quaternion &amp;rotation)</td></tr>
<tr class="separator:a44baacd12e3c6df7c1d2493ccad7dc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032ad8134717fbdc99b58ca21d17cc74"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a032ad8134717fbdc99b58ca21d17cc74">EMFX_SCALECODE</a> (MCORE_INLINE void SetLocalSpaceScale(const AZ::Vector3 &amp;scale) { m_localTransform.m_scale=scale;} MCORE_INLINE const AZ::Vector3 &amp;GetLocalSpaceScale() const { return m_localTransform.m_scale;}) MCORE_INLINE const AZ</td></tr>
<tr class="separator:a032ad8134717fbdc99b58ca21d17cc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f335cf387df7b37a6a540990252705"><td class="memItemLeft" align="right" valign="top"><a id="a47f335cf387df7b37a6a540990252705"></a>
MCORE_INLINE const Transform &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetLocalSpaceTransform</b> () const</td></tr>
<tr class="separator:a47f335cf387df7b37a6a540990252705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac401a2ebe0e16d68f79efafe636b4e"><td class="memItemLeft" align="right" valign="top"><a id="a8ac401a2ebe0e16d68f79efafe636b4e"></a>
MCORE_INLINE const Transform &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetWorldSpaceTransform</b> () const</td></tr>
<tr class="separator:a8ac401a2ebe0e16d68f79efafe636b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac014e0f2b694d1b01aad80abf876a4a7"><td class="memItemLeft" align="right" valign="top"><a id="ac014e0f2b694d1b01aad80abf876a4a7"></a>
MCORE_INLINE const Transform &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetWorldSpaceTransformInversed</b> () const</td></tr>
<tr class="separator:ac014e0f2b694d1b01aad80abf876a4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b28f71d5dcca3e92a9c7c868a5514c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a0b28f71d5dcca3e92a9c7c868a5514c2">CheckIfCanHandleAttachment</a> (const <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> *attachmentInstance) const</td></tr>
<tr class="separator:a0b28f71d5dcca3e92a9c7c868a5514c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6d3cc10985acd0070da8fefb6f5c93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a2a6d3cc10985acd0070da8fefb6f5c93">RecursiveHasAttachment</a> (const <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> *attachmentInstance) const</td></tr>
<tr class="separator:a2a6d3cc10985acd0070da8fefb6f5c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491bc00bf46223cb26c05d25ffcf52ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a491bc00bf46223cb26c05d25ffcf52ff">AddAttachment</a> (<a class="el" href="class_e_motion_f_x_1_1_attachment.html">Attachment</a> *attachment)</td></tr>
<tr class="separator:a491bc00bf46223cb26c05d25ffcf52ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a833d0a7b404789c9b93dabadd0e7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a01a833d0a7b404789c9b93dabadd0e7a">RemoveAttachment</a> (size_t nr, bool delFromMem=true)</td></tr>
<tr class="separator:a01a833d0a7b404789c9b93dabadd0e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada86767a29113acb688cd5f627c22f06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#ada86767a29113acb688cd5f627c22f06">RemoveAllAttachments</a> (bool delFromMem=true)</td></tr>
<tr class="separator:ada86767a29113acb688cd5f627c22f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c4e5308e0e2723d66768c150f50bdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a78c4e5308e0e2723d66768c150f50bdb">RemoveAttachment</a> (<a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> *actorInstance, bool delFromMem=true)</td></tr>
<tr class="separator:a78c4e5308e0e2723d66768c150f50bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab27d29c4b3c51252494069c8330dbd5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#aab27d29c4b3c51252494069c8330dbd5">FindAttachmentNr</a> (<a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> *actorInstance)</td></tr>
<tr class="separator:aab27d29c4b3c51252494069c8330dbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0670df127d147bf4d12b38d85734f830"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a0670df127d147bf4d12b38d85734f830">GetNumAttachments</a> () const</td></tr>
<tr class="separator:a0670df127d147bf4d12b38d85734f830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fc61a2ee0aad179387f18f52d8ee71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_attachment.html">Attachment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#af5fc61a2ee0aad179387f18f52d8ee71">GetAttachment</a> (size_t nr) const</td></tr>
<tr class="separator:af5fc61a2ee0aad179387f18f52d8ee71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f224608b82b7849de66d25325fa93e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a1f224608b82b7849de66d25325fa93e1">GetIsAttachment</a> () const</td></tr>
<tr class="separator:a1f224608b82b7849de66d25325fa93e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5dd86f5da8cca2d918e548e3e7b9f48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#ad5dd86f5da8cca2d918e548e3e7b9f48">GetAttachedTo</a> () const</td></tr>
<tr class="separator:ad5dd86f5da8cca2d918e548e3e7b9f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8ceae8b8cf2b7c6cf37e0eafe9e10d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a7b8ceae8b8cf2b7c6cf37e0eafe9e10d">FindAttachmentRoot</a> () const</td></tr>
<tr class="separator:a7b8ceae8b8cf2b7c6cf37e0eafe9e10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e979a2270b42e8af8e2b5e8920ad414"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_attachment.html">Attachment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a7e979a2270b42e8af8e2b5e8920ad414">GetSelfAttachment</a> () const</td></tr>
<tr class="separator:a7e979a2270b42e8af8e2b5e8920ad414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fab75bdf3227031f1995365f6154ea6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a3fab75bdf3227031f1995365f6154ea6">GetIsSkinAttachment</a> () const</td></tr>
<tr class="separator:a3fab75bdf3227031f1995365f6154ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b38bd4e21d3eae57a27f7f52a3f111e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a7b38bd4e21d3eae57a27f7f52a3f111e">UpdateDependencies</a> ()</td></tr>
<tr class="separator:a7b38bd4e21d3eae57a27f7f52a3f111e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7e03b04882dfb1ee7372902f278df3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a5a7e03b04882dfb1ee7372902f278df3">RecursiveAddDependencies</a> (<a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> *actor)</td></tr>
<tr class="separator:a5a7e03b04882dfb1ee7372902f278df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efc3a9653cae6d232d707d9cadf886f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a9efc3a9653cae6d232d707d9cadf886f">GetNumDependencies</a> () const</td></tr>
<tr class="separator:a9efc3a9653cae6d232d707d9cadf886f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953c9df054080a2b79354e2f771b8b0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_e_motion_f_x_1_1_actor_1_1_dependency.html">Actor::Dependency</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a953c9df054080a2b79354e2f771b8b0c">GetDependency</a> (size_t nr)</td></tr>
<tr class="separator:a953c9df054080a2b79354e2f771b8b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504ae9026c0f695c5ca0d018e8083b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_morph_setup_instance.html">MorphSetupInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a504ae9026c0f695c5ca0d018e8083b32">GetMorphSetupInstance</a> () const</td></tr>
<tr class="separator:a504ae9026c0f695c5ca0d018e8083b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb88393b965b0e7e0644d1847211db12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#aeb88393b965b0e7e0644d1847211db12">IntersectsCollisionMesh</a> (size_t lodLevel, const <a class="el" href="class_m_core_1_1_ray.html">MCore::Ray</a> &amp;ray) const</td></tr>
<tr class="separator:aeb88393b965b0e7e0644d1847211db12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367995512d11357e183d930bda2472b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a367995512d11357e183d930bda2472b7">IntersectsCollisionMesh</a> (size_t lodLevel, const <a class="el" href="class_m_core_1_1_ray.html">MCore::Ray</a> &amp;ray, AZ::Vector3 *outIntersect, AZ::Vector3 *outNormal=nullptr, AZ::Vector2 *outUV=nullptr, float *outBaryU=nullptr, float *outBaryV=nullptr, uint32 *outIndices=nullptr) const</td></tr>
<tr class="separator:a367995512d11357e183d930bda2472b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb47cbc0d26f090cf125ad50fafabe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#aaeb47cbc0d26f090cf125ad50fafabe0">IntersectsMesh</a> (size_t lodLevel, const <a class="el" href="class_m_core_1_1_ray.html">MCore::Ray</a> &amp;ray) const</td></tr>
<tr class="separator:aaeb47cbc0d26f090cf125ad50fafabe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6160f4c88fb36cfc16367fd4cc86317"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#af6160f4c88fb36cfc16367fd4cc86317">IntersectsMesh</a> (size_t lodLevel, const <a class="el" href="class_m_core_1_1_ray.html">MCore::Ray</a> &amp;ray, AZ::Vector3 *outIntersect, AZ::Vector3 *outNormal=nullptr, AZ::Vector2 *outUV=nullptr, float *outBaryU=nullptr, float *outBaryV=nullptr, uint32 *outStartIndex=nullptr) const</td></tr>
<tr class="separator:af6160f4c88fb36cfc16367fd4cc86317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee143709661bc53e24cbd7267f74994f"><td class="memItemLeft" align="right" valign="top"><a id="aee143709661bc53e24cbd7267f74994f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetRagdoll</b> (Physics::Ragdoll *ragdoll)</td></tr>
<tr class="separator:aee143709661bc53e24cbd7267f74994f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7694ed404016afcea5231159e71103c"><td class="memItemLeft" align="right" valign="top"><a id="ae7694ed404016afcea5231159e71103c"></a>
<a class="el" href="class_e_motion_f_x_1_1_ragdoll_instance.html">RagdollInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetRagdollInstance</b> () const</td></tr>
<tr class="separator:ae7694ed404016afcea5231159e71103c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd18b0d87faecb3e235434834e936ee"><td class="memItemLeft" align="right" valign="top"><a id="a7cd18b0d87faecb3e235434834e936ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetParentWorldSpaceTransform</b> (const Transform &amp;transform)</td></tr>
<tr class="separator:a7cd18b0d87faecb3e235434834e936ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c14ce047f5890519c5498eed1dedc87"><td class="memItemLeft" align="right" valign="top"><a id="a0c14ce047f5890519c5498eed1dedc87"></a>
const Transform &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetParentWorldSpaceTransform</b> () const</td></tr>
<tr class="separator:a0c14ce047f5890519c5498eed1dedc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7545ddf5e3d72fd2dcede347e358080"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#ae7545ddf5e3d72fd2dcede347e358080">SetRender</a> (bool enabled)</td></tr>
<tr class="separator:ae7545ddf5e3d72fd2dcede347e358080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5a0f225f14f1b0b4ef2d9331ecad48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#afd5a0f225f14f1b0b4ef2d9331ecad48">GetRender</a> () const</td></tr>
<tr class="separator:afd5a0f225f14f1b0b4ef2d9331ecad48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c061249a03ce7c8d1c6281559ede15"><td class="memItemLeft" align="right" valign="top"><a id="a74c061249a03ce7c8d1c6281559ede15"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetIsUsedForVisualization</b> (bool enabled)</td></tr>
<tr class="separator:a74c061249a03ce7c8d1c6281559ede15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9723340a2ef3356aacb8a81a0a1952"><td class="memItemLeft" align="right" valign="top"><a id="a1a9723340a2ef3356aacb8a81a0a1952"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetIsUsedForVisualization</b> () const</td></tr>
<tr class="separator:a1a9723340a2ef3356aacb8a81a0a1952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada715c19c1310f8e0c4042e09cdad3a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#ada715c19c1310f8e0c4042e09cdad3a7">SetIsOwnedByRuntime</a> (bool isOwnedByRuntime)</td></tr>
<tr class="separator:ada715c19c1310f8e0c4042e09cdad3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b970720086e0e7b4bf7a6b5bcb7b24a"><td class="memItemLeft" align="right" valign="top"><a id="a4b970720086e0e7b4bf7a6b5bcb7b24a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetIsOwnedByRuntime</b> () const</td></tr>
<tr class="separator:a4b970720086e0e7b4bf7a6b5bcb7b24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6229e508930b1dc3ff8e6938ae6ee502"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a6229e508930b1dc3ff8e6938ae6ee502">EnableNode</a> (uint16 nodeIndex)</td></tr>
<tr class="separator:a6229e508930b1dc3ff8e6938ae6ee502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9790452386c9f78e79833b9b3575be9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#ad9790452386c9f78e79833b9b3575be9">DisableNode</a> (uint16 nodeIndex)</td></tr>
<tr class="separator:ad9790452386c9f78e79833b9b3575be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed9795818b3cf8ba1843e1fa2a50dc0"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE const AZStd::vector&lt; uint16 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a1ed9795818b3cf8ba1843e1fa2a50dc0">GetEnabledNodes</a> () const</td></tr>
<tr class="separator:a1ed9795818b3cf8ba1843e1fa2a50dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bce8e70166054df7bae876a58bbd5b8"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a2bce8e70166054df7bae876a58bbd5b8">GetNumEnabledNodes</a> () const</td></tr>
<tr class="separator:a2bce8e70166054df7bae876a58bbd5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b25434f21dd06c0926e63aae62fcf54"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a1b25434f21dd06c0926e63aae62fcf54">GetEnabledNode</a> (size_t index) const</td></tr>
<tr class="separator:a1b25434f21dd06c0926e63aae62fcf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4952c288bb2befe101142da4327ad813"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a4952c288bb2befe101142da4327ad813">EnableAllNodes</a> ()</td></tr>
<tr class="separator:a4952c288bb2befe101142da4327ad813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ad6a9511fbd568843152de898ecff9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#aa4ad6a9511fbd568843152de898ecff9">DisableAllNodes</a> ()</td></tr>
<tr class="separator:aa4ad6a9511fbd568843152de898ecff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05644895043ffaf47f1e3429547d57b3"><td class="memItemLeft" align="right" valign="top"><a id="a05644895043ffaf47f1e3429547d57b3"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><b>GetThreadIndex</b> () const</td></tr>
<tr class="separator:a05644895043ffaf47f1e3429547d57b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c02f9eaee0d918c6e93c6a073a4afb"><td class="memItemLeft" align="right" valign="top"><a id="a50c02f9eaee0d918c6e93c6a073a4afb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetThreadIndex</b> (uint32 index)</td></tr>
<tr class="separator:a50c02f9eaee0d918c6e93c6a073a4afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b88a47103282cec0da5b805179e8212"><td class="memItemLeft" align="right" valign="top"><a id="a4b88a47103282cec0da5b805179e8212"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DrawSkeleton</b> (const <a class="el" href="class_e_motion_f_x_1_1_pose.html">Pose</a> &amp;pose, const AZ::Color &amp;color)</td></tr>
<tr class="separator:a4b88a47103282cec0da5b805179e8212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f5c2f84c248d0aa0b9877a4cec9831"><td class="memItemLeft" align="right" valign="top"><a id="aa7f5c2f84c248d0aa0b9877a4cec9831"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ApplyMotionExtractionDelta</b> (const Transform &amp;trajectoryDelta)</td></tr>
<tr class="separator:aa7f5c2f84c248d0aa0b9877a4cec9831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf300a03a49de93b7cfd39d894906529"><td class="memItemLeft" align="right" valign="top"><a id="abf300a03a49de93b7cfd39d894906529"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ApplyMotionExtractionDelta</b> ()</td></tr>
<tr class="separator:abf300a03a49de93b7cfd39d894906529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4524fef86948299a3d89080e455979ba"><td class="memItemLeft" align="right" valign="top"><a id="a4524fef86948299a3d89080e455979ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MotionExtractionCompensate</b> (EMotionExtractionFlags motionExtractionFlags=(EMotionExtractionFlags) 0)</td></tr>
<tr class="separator:a4524fef86948299a3d89080e455979ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2eb6f822c1aaf91cd7f510ed3f9a819"><td class="memItemLeft" align="right" valign="top"><a id="ab2eb6f822c1aaf91cd7f510ed3f9a819"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MotionExtractionCompensate</b> (Transform &amp;inOutMotionExtractionNodeTransform, EMotionExtractionFlags motionExtractionFlags=(EMotionExtractionFlags) 0) const</td></tr>
<tr class="separator:ab2eb6f822c1aaf91cd7f510ed3f9a819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519037ebda1a70fc691d82719375a76b"><td class="memItemLeft" align="right" valign="top"><a id="a519037ebda1a70fc691d82719375a76b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMotionExtractionEnabled</b> (bool enabled)</td></tr>
<tr class="separator:a519037ebda1a70fc691d82719375a76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6239ad28fd0f44d8e96299a2fe7fdb5d"><td class="memItemLeft" align="right" valign="top"><a id="a6239ad28fd0f44d8e96299a2fe7fdb5d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetMotionExtractionEnabled</b> () const</td></tr>
<tr class="separator:a6239ad28fd0f44d8e96299a2fe7fdb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27962dc0fa4d5882c24e53049b48f91"><td class="memItemLeft" align="right" valign="top"><a id="ab27962dc0fa4d5882c24e53049b48f91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetTrajectoryDeltaTransform</b> (const Transform &amp;transform)</td></tr>
<tr class="separator:ab27962dc0fa4d5882c24e53049b48f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac85494b24fb2baecdc88087f308874b"><td class="memItemLeft" align="right" valign="top"><a id="aac85494b24fb2baecdc88087f308874b"></a>
const Transform &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetTrajectoryDeltaTransform</b> () const</td></tr>
<tr class="separator:aac85494b24fb2baecdc88087f308874b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd97bf69b5b096835846b6e1ed545e00"><td class="memItemLeft" align="right" valign="top"><a id="abd97bf69b5b096835846b6e1ed545e00"></a>
<a class="el" href="class_e_motion_f_x_1_1_anim_graph_pose.html">AnimGraphPose</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>RequestPose</b> (uint32 threadIndex)</td></tr>
<tr class="separator:abd97bf69b5b096835846b6e1ed545e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7646060ce3931ea85503e655427bb1"><td class="memItemLeft" align="right" valign="top"><a id="aee7646060ce3931ea85503e655427bb1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FreePose</b> (uint32 threadIndex, <a class="el" href="class_e_motion_f_x_1_1_anim_graph_pose.html">AnimGraphPose</a> *pose)</td></tr>
<tr class="separator:aee7646060ce3931ea85503e655427bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9d3a520e4cb33aa7d715f60a4a0412"><td class="memItemLeft" align="right" valign="top"><a id="a2b9d3a520e4cb33aa7d715f60a4a0412"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMotionSamplingTimer</b> (float timeInSeconds)</td></tr>
<tr class="separator:a2b9d3a520e4cb33aa7d715f60a4a0412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92e61f46ae5a142a64e72ed16a4496f"><td class="memItemLeft" align="right" valign="top"><a id="ae92e61f46ae5a142a64e72ed16a4496f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMotionSamplingRate</b> (float updateRateInSeconds)</td></tr>
<tr class="separator:ae92e61f46ae5a142a64e72ed16a4496f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa252e74ec14563294359475ed21e41dd"><td class="memItemLeft" align="right" valign="top"><a id="aa252e74ec14563294359475ed21e41dd"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>GetMotionSamplingTimer</b> () const</td></tr>
<tr class="separator:aa252e74ec14563294359475ed21e41dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf51070b03be3311541564e32d623237"><td class="memItemLeft" align="right" valign="top"><a id="abf51070b03be3311541564e32d623237"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>GetMotionSamplingRate</b> () const</td></tr>
<tr class="separator:abf51070b03be3311541564e32d623237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab30cbc5fc7c32ad26a6520e677b42cd"><td class="memItemLeft" align="right" valign="top"><a id="aab30cbc5fc7c32ad26a6520e677b42cd"></a>
MCORE_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetNumNodes</b> () const</td></tr>
<tr class="separator:aab30cbc5fc7c32ad26a6520e677b42cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b2f17e9e04948035088541660ca109"><td class="memItemLeft" align="right" valign="top"><a id="a91b2f17e9e04948035088541660ca109"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateVisualizeScale</b> ()</td></tr>
<tr class="separator:a91b2f17e9e04948035088541660ca109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762cf72baa2b7f05eb8f4f2193cea9e8"><td class="memItemLeft" align="right" valign="top"><a id="a762cf72baa2b7f05eb8f4f2193cea9e8"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>GetVisualizeScale</b> () const</td></tr>
<tr class="separator:a762cf72baa2b7f05eb8f4f2193cea9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca6262aa6046d94873040878aa0c6c8"><td class="memItemLeft" align="right" valign="top"><a id="a8ca6262aa6046d94873040878aa0c6c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetVisualizeScale</b> (float factor)</td></tr>
<tr class="separator:a8ca6262aa6046d94873040878aa0c6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4192ee27947c19e9b135aa50d8101a85"><td class="memItemLeft" align="right" valign="top"><a id="a4192ee27947c19e9b135aa50d8101a85"></a>
MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>SetLightingChannelMask</b> (uint32_t lightingChannelMask)</td></tr>
<tr class="separator:a4192ee27947c19e9b135aa50d8101a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e43833ed5b772a0799f5e6e2ca500a2"><td class="memItemLeft" align="right" valign="top"><a id="a5e43833ed5b772a0799f5e6e2ca500a2"></a>
MCORE_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetLightingChannelMask</b> () const</td></tr>
<tr class="separator:a5e43833ed5b772a0799f5e6e2ca500a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_core_1_1_ref_counted"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_core_1_1_ref_counted')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_core_1_1_ref_counted.html">MCore::RefCounted</a></td></tr>
<tr class="memitem:a75e7ba87c2fa79c9481b2a3f51cc88cc inherit pub_methods_class_m_core_1_1_ref_counted"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ref_counted.html#a75e7ba87c2fa79c9481b2a3f51cc88cc">RefCounted</a> ()</td></tr>
<tr class="separator:a75e7ba87c2fa79c9481b2a3f51cc88cc inherit pub_methods_class_m_core_1_1_ref_counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1e8dec8973a6073804e19bb143bd0c inherit pub_methods_class_m_core_1_1_ref_counted"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ref_counted.html#a0c1e8dec8973a6073804e19bb143bd0c">~RefCounted</a> ()</td></tr>
<tr class="separator:a0c1e8dec8973a6073804e19bb143bd0c inherit pub_methods_class_m_core_1_1_ref_counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadeeac73f8f826f2d8ca5aeea8780991 inherit pub_methods_class_m_core_1_1_ref_counted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ref_counted.html#aadeeac73f8f826f2d8ca5aeea8780991">IncreaseReferenceCount</a> ()</td></tr>
<tr class="separator:aadeeac73f8f826f2d8ca5aeea8780991 inherit pub_methods_class_m_core_1_1_ref_counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7db875f838d783ab060cdc987252e46 inherit pub_methods_class_m_core_1_1_ref_counted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ref_counted.html#af7db875f838d783ab060cdc987252e46">DecreaseReferenceCount</a> ()</td></tr>
<tr class="separator:af7db875f838d783ab060cdc987252e46 inherit pub_methods_class_m_core_1_1_ref_counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c9892d827fcc0c6976724623d81042 inherit pub_methods_class_m_core_1_1_ref_counted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ref_counted.html#a14c9892d827fcc0c6976724623d81042">Destroy</a> ()</td></tr>
<tr class="separator:a14c9892d827fcc0c6976724623d81042 inherit pub_methods_class_m_core_1_1_ref_counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c758ad5c94e23385ce1f88bd4978e4 inherit pub_methods_class_m_core_1_1_ref_counted"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_core_1_1_ref_counted.html#a60c758ad5c94e23385ce1f88bd4978e4">GetReferenceCount</a> () const</td></tr>
<tr class="separator:a60c758ad5c94e23385ce1f88bd4978e4 inherit pub_methods_class_m_core_1_1_ref_counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa9db206f45926310f85cf91722e8daf9"><td class="memItemLeft" align="right" valign="top"><a id="aa9db206f45926310f85cf91722e8daf9"></a>
static <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Create</b> (<a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> *actor, AZ::Entity *entity=nullptr, uint32 threadIndex=0)</td></tr>
<tr class="separator:aa9db206f45926310f85cf91722e8daf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be802957fd4db90c653d740e0d0a1df"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a6be802957fd4db90c653d740e0d0a1df">ExpandBounds</a> (AZ::Aabb &amp;aabb, float expandByPercentage)</td></tr>
<tr class="separator:a6be802957fd4db90c653d740e0d0a1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04530052da39ddfb90a83a9e8de81146"><td class="memItemLeft" align="right" valign="top"><a id="a04530052da39ddfb90a83a9e8de81146"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>ApplyMotionExtractionDelta</b> (Transform &amp;inOutTransform, const Transform &amp;trajectoryDelta)</td></tr>
<tr class="separator:a04530052da39ddfb90a83a9e8de81146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7ebd749e5d968a318656d3d747e9df"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#afe7ebd749e5d968a318656d3d747e9df">MotionExtractionCompensate</a> (Transform &amp;inOutMotionExtractionNodeTransform, const Transform &amp;localSpaceBindPoseTransform, EMotionExtractionFlags motionExtractionFlags=(EMotionExtractionFlags) 0)</td></tr>
<tr class="separator:afe7ebd749e5d968a318656d3d747e9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a7685ea34cf37d4b5ecb9da496a4567c3"><td class="memItemLeft" align="right" valign="top"><a id="a7685ea34cf37d4b5ecb9da496a4567c3"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Attachment</b></td></tr>
<tr class="separator:a7685ea34cf37d4b5ecb9da496a4567c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_m_core_1_1_ref_counted"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_m_core_1_1_ref_counted')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_m_core_1_1_ref_counted.html">MCore::RefCounted</a></td></tr>
<tr class="memitem:a4f6a2cf27d86fa82560e7f4ac6338a04 inherit pro_methods_class_m_core_1_1_ref_counted"><td class="memItemLeft" align="right" valign="top"><a id="a4f6a2cf27d86fa82560e7f4ac6338a04"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>Delete</b> ()</td></tr>
<tr class="separator:a4f6a2cf27d86fa82560e7f4ac6338a04 inherit pro_methods_class_m_core_1_1_ref_counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The actor instance class. An actor instance represents an animated character in your game. Each actor instance is created from some <a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> object, which contains all the hierarchy information and possibly also the transformation and mesh information. Still, each actor instance can be controlled and animated individually. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a194a056f8a28e8d95c25ec527a05ff6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194a056f8a28e8d95c25ec527a05ff6c">&#9670;&nbsp;</a></span>EBoundsType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6c">EMotionFX::ActorInstance::EBoundsType</a> : AZ::u8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The bounding volume generation types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a194a056f8a28e8d95c25ec527a05ff6ca88d7ab77f647de81bc31d7d99b0d0859"></a>BOUNDS_NODE_BASED&#160;</td><td class="fielddoc"><p>Calculate the bounding volumes based on the world space node positions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a194a056f8a28e8d95c25ec527a05ff6caaf23dce4d6b4db9210686ae815f720c2"></a>BOUNDS_MESH_BASED&#160;</td><td class="fielddoc"><p>Calculate the bounding volumes based on the world space vertex positions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a194a056f8a28e8d95c25ec527a05ff6cab5421859affaf084f4025dd8e9ed5152"></a>BOUNDS_STATIC_BASED&#160;</td><td class="fielddoc"><p>Calculate the bounding volumes based on an approximate box, based on the mesh bounds, and move this box along with the actor instance position. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a491bc00bf46223cb26c05d25ffcf52ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491bc00bf46223cb26c05d25ffcf52ff">&#9670;&nbsp;</a></span>AddAttachment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::AddAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_attachment.html">Attachment</a> *&#160;</td>
          <td class="paramname"><em>attachment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an attachment to this actor. Please note that each attachment can only belong to one actor instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachment</td><td>The attachment to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39eada870f38c1e7e0aef4e7aaf5c728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39eada870f38c1e7e0aef4e7aaf5c728">&#9670;&nbsp;</a></span>ApplyMorphSetup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::ApplyMorphSetup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the morph targets transforms additively to the current local transforms as they are stored inside the <a class="el" href="class_e_motion_f_x_1_1_transform_data.html">TransformData</a> object that you retrieve with <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a8b8f70add2a14f1ac284916a8f083337">GetTransformData()</a>. This will not apply any mesh morphs yet, as that is performed by the <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#ab61b7f8e2a25d9e0380eed7ca9855312">UpdateMeshDeformers()</a> method. </p>

</div>
</div>
<a id="a64d79499e9d54e5d84e021f321a06b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d79499e9d54e5d84e021f321a06b2e">&#9670;&nbsp;</a></span>CalcMeshBasedAabb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::CalcMeshBasedAabb </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>geomLODLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Aabb *&#160;</td>
          <td class="paramname"><em>outResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>vertexFrequency</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the axis aligned bounding box based on the world space vertex coordinates of the meshes. If the actor has no meshes, the created box will be invalid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geomLODLevel</td><td>The geometry LOD level to calculate the box for. </td></tr>
    <tr><td class="paramname">outResult</td><td>The AABB where this method should store the resulting box in. </td></tr>
    <tr><td class="paramname">vertexFrequency</td><td>This includes every "vertexFrequency"-th vertex. So for example a value of 2 would skip every second vertex and so will process half of the vertices. A value of 4 would process only each 4th vertex, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03b6ebaabe9c047938866d159aa57b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b6ebaabe9c047938866d159aa57b5c">&#9670;&nbsp;</a></span>CalcNodeBasedAabb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::CalcNodeBasedAabb </td>
          <td>(</td>
          <td class="paramtype">AZ::Aabb *&#160;</td>
          <td class="paramname"><em>outResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>nodeFrequency</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the axis aligned bounding box based on the world space positions of the nodes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outResult</td><td>The AABB where this method should store the resulting box in. </td></tr>
    <tr><td class="paramname">nodeFrequency</td><td>This will include every "nodeFrequency"-th node. So a value of 1 will include all nodes. A value of 2 would process every second node, meaning that half of the nodes will be skipped. A value of 4 would process every 4th node, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08fd830c2a559c4482ba1c293bab0588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fd830c2a559c4482ba1c293bab0588">&#9670;&nbsp;</a></span>CalcNumDisabledNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::ActorInstance::CalcNumDisabledNodes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>skeletalLODLevel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the number of disabled nodes for a given skeletal lod level. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">skeletalLODLevel</td><td>The skeletal LOD level to calculate the number of disabled nodes for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of disabled nodes for the given skeletal LOD level. </dd></dl>

</div>
</div>
<a id="a2f16faf8c204f4d01c50eb2b3cd1da4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f16faf8c204f4d01c50eb2b3cd1da4b">&#9670;&nbsp;</a></span>CalcNumSkeletalLODLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::ActorInstance::CalcNumSkeletalLODLevels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the number of used skeletal LOD levels. Each actor instance alsways has 32 skeletal LOD levels while in most cases not all of them are actually used. This function determines the number of skeletal LOD levels that actually disable some more nodes relative to the previous LOD level. </p><dl class="section return"><dt>Returns</dt><dd>The number of actually used skeletal LOD levels. </dd></dl>

</div>
</div>
<a id="a21795feb0dc740c52955df9c6a67121d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21795feb0dc740c52955df9c6a67121d">&#9670;&nbsp;</a></span>CalcStaticBasedAabb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::CalcStaticBasedAabb </td>
          <td>(</td>
          <td class="paramtype">AZ::Aabb *&#160;</td>
          <td class="paramname"><em>outResult</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate an axis aligned bounding box that can be used as static AABB. It is static in the way that the volume does not change. It can however be translated as it will move with the character's position. The box will contain the mesh based bounds, and finds the maximum of the width, depth and height, and makes all depth width and height equal to this value. So the box will in most cases be too wide, but this is done on purpose. This can be used when the character is outside of the frustum, but we still update the position. We can then use this box to test for visibility again. If there are no meshes present, a widened node based box will be used instead as basis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outResult</td><td>The resulting bounding box, moved along with the actor instance's position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b28f71d5dcca3e92a9c7c868a5514c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b28f71d5dcca3e92a9c7c868a5514c2">&#9670;&nbsp;</a></span>CheckIfCanHandleAttachment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::ActorInstance::CheckIfCanHandleAttachment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> *&#160;</td>
          <td class="paramname"><em>attachmentInstance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if we can safely attach an attachment that uses the specified actor instance. This will check for infinite recursion/circular chains. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachmentInstance</td><td>The actor instance we are trying to attach to this actor instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when we can safely attach the specified actor instance, otherwise false is returned. </dd></dl>

</div>
</div>
<a id="aa4ad6a9511fbd568843152de898ecff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ad6a9511fbd568843152de898ecff9">&#9670;&nbsp;</a></span>DisableAllNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::DisableAllNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable all nodes inside the actor instance. This means that no nodes will be updated at all (no motion sampling, no transformation calculations and no blending etc). After actor instance creation time it is possible that some nodes are disabled on default. This is controlled by node groups (represented by the <a class="el" href="class_e_motion_f_x_1_1_node_group.html">NodeGroup</a> class). Each <a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> object has a set of node groups. Each group contains a set of nodes which are either enabled or disabled on default. You can use the Actor::GetNodeGroup(...) related methods to get access to the groups and enable or disable the predefined groups of nodes manually. </p>

</div>
</div>
<a id="ad9790452386c9f78e79833b9b3575be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9790452386c9f78e79833b9b3575be9">&#9670;&nbsp;</a></span>DisableNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::DisableNode </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>nodeIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable a specific node. This will disable motion sampling, transformation and blending calculations for the given node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeIndex</td><td>The node number to disable. This must be in range of [0..Actor::GetNumNodes()-1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a032ad8134717fbdc99b58ca21d17cc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032ad8134717fbdc99b58ca21d17cc74">&#9670;&nbsp;</a></span>EMFX_SCALECODE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EMotionFX::ActorInstance::EMFX_SCALECODE </td>
          <td>(</td>
          <td class="paramtype">MCORE_INLINE void SetLocalSpaceScale(const AZ::Vector3 &amp;scale) { m_localTransform.m_scale=scale;} MCORE_INLINE const AZ::Vector3 &amp;GetLocalSpaceScale() const { return m_localTransform.m_scale;}&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the local space position/translation of this actor instance. This is relative to its parent (if it is attached ot something). Otherwise it is in world space. </p><dl class="section return"><dt>Returns</dt><dd>The local space position. Get the local space rotation of this actor instance. This is relative to its parent (if it is attached ot something). Otherwise it is in world space. </dd>
<dd>
The local space rotation. </dd></dl>

</div>
</div>
<a id="a4952c288bb2befe101142da4327ad813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4952c288bb2befe101142da4327ad813">&#9670;&nbsp;</a></span>EnableAllNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::EnableAllNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable all nodes inside the actor instance. This means that all nodes will be processed and will have their motions sampled (unless disabled by LOD), local and world space matrices calculated, etc. After actor instance creation time it is possible that some nodes are disabled on default. This is controlled by node groups (represented by the <a class="el" href="class_e_motion_f_x_1_1_node_group.html">NodeGroup</a> class). Each <a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> object has a set of node groups. Each group contains a set of nodes which are either enabled or disabled on default. You can use the Actor::GetNodeGroup(...) related methods to get access to the groups and enable or disable the predefined groups of nodes manually. </p>

</div>
</div>
<a id="a6229e508930b1dc3ff8e6938ae6ee502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6229e508930b1dc3ff8e6938ae6ee502">&#9670;&nbsp;</a></span>EnableNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::EnableNode </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>nodeIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable a specific node. This will activate motion sampling, transformation and blending calculations for the given node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeIndex</td><td>The node number to enable. This must be in range of [0..Actor::GetNumNodes()-1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6be802957fd4db90c653d740e0d0a1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be802957fd4db90c653d740e0d0a1df">&#9670;&nbsp;</a></span>ExpandBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void EMotionFX::ActorInstance::ExpandBounds </td>
          <td>(</td>
          <td class="paramtype">AZ::Aabb &amp;&#160;</td>
          <td class="paramname"><em>aabb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>expandByPercentage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Expand a bounding box by a given percentage </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aabb</td><td>The bounding box to expand </td></tr>
    <tr><td class="paramname">expandBoundsBy</td><td>Percentage to expand the bounds by. A value of 0.0 means that the calculated bounding box won't be expanded at all, while .25 means it will become 125% the original size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab27d29c4b3c51252494069c8330dbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab27d29c4b3c51252494069c8330dbd5">&#9670;&nbsp;</a></span>FindAttachmentNr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::ActorInstance::FindAttachmentNr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> *&#160;</td>
          <td class="paramname"><em>actorInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the attachment number that uses a given actor instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actorInstance</td><td>The actor instance that the attachment you search for is using. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the attachment number, in range of [0..<a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a0670df127d147bf4d12b38d85734f830">GetNumAttachments()</a>-1], or MCORE_INVALIDINDEX32 when no attachment using the specified actor instance can be found. </dd></dl>

</div>
</div>
<a id="a7b8ceae8b8cf2b7c6cf37e0eafe9e10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8ceae8b8cf2b7c6cf37e0eafe9e10d">&#9670;&nbsp;</a></span>FindAttachmentRoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a>* EMotionFX::ActorInstance::FindAttachmentRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the root actor instance. If this actor instance object represents a gun, which is attached to a cowboy, which is attached to a horse, then the attachment root that is returned by this method is the horse. </p><dl class="section return"><dt>Returns</dt><dd>The attachment root, or a pointer to itself when this actor instance isn't attached to anything. </dd></dl>

</div>
</div>
<a id="aa0c4fa4f70b8a1c9daebbae5ba03b781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c4fa4f70b8a1c9daebbae5ba03b781">&#9670;&nbsp;</a></span>GetAabb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AZ::Aabb&amp; EMotionFX::ActorInstance::GetAabb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the axis aligned bounding box. This box will be updated once the UpdateBounds method is called. That method is also called automatically when the bounds auto-update feature is enabled. </p><dl class="section return"><dt>Returns</dt><dd>The axis aligned bounding box. </dd></dl>

</div>
</div>
<a id="a1cfe1131dbbb09bb13ce6409a3036253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cfe1131dbbb09bb13ce6409a3036253">&#9670;&nbsp;</a></span>GetActor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a>* EMotionFX::ActorInstance::GetActor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the actor from which this is an instance. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the actor from which this is an instance. </dd></dl>

</div>
</div>
<a id="acb9ca1afba039dcc21cfe90d52fcea2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9ca1afba039dcc21cfe90d52fcea2d">&#9670;&nbsp;</a></span>GetAnimGraphInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_anim_graph_instance.html">AnimGraphInstance</a>* EMotionFX::ActorInstance::GetAnimGraphInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the anim graph instance. This can return nullptr, in which case the motion system as returned by <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a50a5f1785ea3ffe65ba1abf6f5aee094">GetMotionSystem()</a> will be used. </p><dl class="section return"><dt>Returns</dt><dd>The anim graph instance. </dd></dl>

</div>
</div>
<a id="ad5dd86f5da8cca2d918e548e3e7b9f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5dd86f5da8cca2d918e548e3e7b9f48">&#9670;&nbsp;</a></span>GetAttachedTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a>* EMotionFX::ActorInstance::GetAttachedTo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the actor instance where this actor instance is attached to. This will return nullptr in case this actor instance is not an attachment. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the actor instance where this actor instance is attached to. </dd></dl>

</div>
</div>
<a id="af5fc61a2ee0aad179387f18f52d8ee71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fc61a2ee0aad179387f18f52d8ee71">&#9670;&nbsp;</a></span>GetAttachment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_attachment.html">Attachment</a>* EMotionFX::ActorInstance::GetAttachment </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a specific attachment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>The attachment number, which must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a0670df127d147bf4d12b38d85734f830">GetNumAttachments()</a>-1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the attachment. </dd></dl>

</div>
</div>
<a id="af74f5f182da685aea3c845f2dd74bee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74f5f182da685aea3c845f2dd74bee7">&#9670;&nbsp;</a></span>GetBoundsUpdateEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::ActorInstance::GetBoundsUpdateEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the automatic bounds update feature is enabled. It will use the settings as provided to the SetupAutoBoundsUpdate method. </p><dl class="section return"><dt>Returns</dt><dd>Returns true when the automatic bounds update feature is enabled, or false when it is disabled. </dd></dl>

</div>
</div>
<a id="af22bfcce7eebb32420faea6e8412cf70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22bfcce7eebb32420faea6e8412cf70">&#9670;&nbsp;</a></span>GetBoundsUpdateFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float EMotionFX::ActorInstance::GetBoundsUpdateFrequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the automatic bounds update time frequency. This specifies the time interval between bounds updates. A value of 0.1 would mean that the bounding volumes will be updated 10 times per second. A value of 0.25 means 4 times per second, etc. A value of 0 can be used to force the updates to happen every frame. </p><dl class="section return"><dt>Returns</dt><dd>Returns the automatic bounds update frequency time interval, in seconds. </dd></dl>

</div>
</div>
<a id="ae6263f5eb1ece7092ba92d7872440a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6263f5eb1ece7092ba92d7872440a18">&#9670;&nbsp;</a></span>GetBoundsUpdateItemFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 EMotionFX::ActorInstance::GetBoundsUpdateItemFrequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the bounding volume auto-update item frequency. A value of 1 would mean every node or vertex will be taken into account in the bounds calculation. A value of 2 would mean every second node or vertex would be taken into account. A value of 5 means every 5th node or vertex, etc. Higher values will result in faster bounds updates, but also in possibly less accurate bounds. The value returned will always be equal or greater than one. </p><dl class="section return"><dt>Returns</dt><dd>The item frequency, which will be equal or greater than one. </dd></dl>

</div>
</div>
<a id="a8fe010cc32f0e73cbf2c8aee416bc51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe010cc32f0e73cbf2c8aee416bc51d">&#9670;&nbsp;</a></span>GetBoundsUpdatePassedTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float EMotionFX::ActorInstance::GetBoundsUpdatePassedTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the time passed since the last automatic bounds update. </p><dl class="section return"><dt>Returns</dt><dd>The time passed, in seconds, since the last automatic bounds update. </dd></dl>

</div>
</div>
<a id="a43a7ac7e9fb36be1006db11c2ef73e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a7ac7e9fb36be1006db11c2ef73e29">&#9670;&nbsp;</a></span>GetBoundsUpdateType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6c">EBoundsType</a> EMotionFX::ActorInstance::GetBoundsUpdateType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the bounding volume auto-update type. This can be either based on the node's world space positions, the mesh vertex world space positions, or the collision mesh vertex world space postitions. </p><dl class="section return"><dt>Returns</dt><dd>The bounding volume update type. </dd></dl>

</div>
</div>
<a id="a16b2c0bcbba4f28ff9ab3a363652aac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b2c0bcbba4f28ff9ab3a363652aac4">&#9670;&nbsp;</a></span>GetCustomData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* EMotionFX::ActorInstance::GetCustomData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the custom data you stored and linked with this actor instance object. Custom data can for example link a game or engine object with this EMotion FX <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> object. An example is when EMotion FX triggers a motion event. You know the actor that triggered the event, but you don't know directly what game or engine object is linked to this actor. By using the custom data methods GetCustomData and SetCustomData you can set a pointer to your game or engine object in each actor instance. The pointer that you specify will not be deleted when the actor instance is being destructed. </p><dl class="section return"><dt>Returns</dt><dd>A void pointer to the custom data you have specified. </dd></dl>

</div>
</div>
<a id="a953c9df054080a2b79354e2f771b8b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953c9df054080a2b79354e2f771b8b0c">&#9670;&nbsp;</a></span>GetDependency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_e_motion_f_x_1_1_actor_1_1_dependency.html">Actor::Dependency</a>* EMotionFX::ActorInstance::GetDependency </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a given dependency. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>The dependency number to get, which must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a9efc3a9653cae6d232d707d9cadf886f">GetNumDependencies()</a>]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the dependency. </dd></dl>

</div>
</div>
<a id="a1b25434f21dd06c0926e63aae62fcf54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b25434f21dd06c0926e63aae62fcf54">&#9670;&nbsp;</a></span>GetEnabledNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE uint16 EMotionFX::ActorInstance::GetEnabledNode </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the node number of a given enabled node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>An index in the array of enabled nodes. This must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a2bce8e70166054df7bae876a58bbd5b8">GetNumEnabledNodes()</a>-1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node number, which relates to Actor::GetNode( returnValue ). </dd></dl>

</div>
</div>
<a id="a1ed9795818b3cf8ba1843e1fa2a50dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed9795818b3cf8ba1843e1fa2a50dc0">&#9670;&nbsp;</a></span>GetEnabledNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE const AZStd::vector&lt;uint16&gt;&amp; EMotionFX::ActorInstance::GetEnabledNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get direct access to the array of enabled nodes. </p><dl class="section return"><dt>Returns</dt><dd>A read only reference to the array of enabled nodes. The values inside of this array are the node numbers of the enabled nodes. </dd></dl>

</div>
</div>
<a id="a24d7059a10d57fb7cc107088a0ed2759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d7059a10d57fb7cc107088a0ed2759">&#9670;&nbsp;</a></span>GetEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AZ::Entity* EMotionFX::ActorInstance::GetEntity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the entity to which the given actor instance belongs to. </p><dl class="section return"><dt>Returns</dt><dd>Entity having an actor component added to it to which this actor instance belongs to. nullptr in case the actor instance is used without the entity component system. </dd></dl>

</div>
</div>
<a id="a23663761ad5bc2dc0277d926c1dad224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23663761ad5bc2dc0277d926c1dad224">&#9670;&nbsp;</a></span>GetEntityId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AZ::EntityId EMotionFX::ActorInstance::GetEntityId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the entity id to which the given actor instance belongs to. </p><dl class="section return"><dt>Returns</dt><dd>Entity id of the actor instance. EntityId::InvalidEntityId in case the actor instance is used without the entity component system. </dd></dl>

</div>
</div>
<a id="abf4d9d8e78734c375ccb3da344405434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4d9d8e78734c375ccb3da344405434">&#9670;&nbsp;</a></span>GetExpandBoundsBy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float EMotionFX::ActorInstance::GetExpandBoundsBy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the normalized percentage that the calculated bounding box is expanded with. This can be used to add a tolerance area to the calculated bounding box to avoid clipping the character too early. A static bounding box together with the expansion is the recommended way for maximum performance. </p><dl class="section return"><dt>Returns</dt><dd>A value of 0.0 means that the calculated bounding box won't be expanded at all, while .25 means it will become 125% the original size. </dd></dl>

</div>
</div>
<a id="a5354268118121b05ee43038b1afc3646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5354268118121b05ee43038b1afc3646">&#9670;&nbsp;</a></span>GetID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE uint32 EMotionFX::ActorInstance::GetID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the unique identification number for the actor instance. </p><dl class="section return"><dt>Returns</dt><dd>The unique identification number. </dd></dl>

</div>
</div>
<a id="a1f224608b82b7849de66d25325fa93e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f224608b82b7849de66d25325fa93e1">&#9670;&nbsp;</a></span>GetIsAttachment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::ActorInstance::GetIsAttachment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether this actor instance also is an attachment or not. So if this actor instance is like a cowboy, and the cowboy is attached to a horse, then this will return true. If the cowboy (so this actor instance) would not be attached to anything, it will return false. </p><dl class="section return"><dt>Returns</dt><dd>Returns true when this actor instance is also an attachment to some other actor instance. Otherwise false is returned. </dd></dl>

</div>
</div>
<a id="a85f38669804377de5851f367c770136b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f38669804377de5851f367c770136b">&#9670;&nbsp;</a></span>GetIsEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE bool EMotionFX::ActorInstance::GetIsEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check whether this actor instance is enabled or not. Disabled actor instances are not updated and processed. </p><dl class="section return"><dt>Returns</dt><dd>Returns true when enabled, or false when disabled. </dd></dl>

</div>
</div>
<a id="a3fab75bdf3227031f1995365f6154ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fab75bdf3227031f1995365f6154ea6">&#9670;&nbsp;</a></span>GetIsSkinAttachment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::ActorInstance::GetIsSkinAttachment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the actor instance is a skin attachment. </p><dl class="section return"><dt>Returns</dt><dd>Returns true when the actor instance itself is a skin attachment, otherwise false is returned. </dd></dl>

</div>
</div>
<a id="a2e2ce5c1e9dac4bac2a4b04b8cd671cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2ce5c1e9dac4bac2a4b04b8cd671cd">&#9670;&nbsp;</a></span>GetIsVisible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE bool EMotionFX::ActorInstance::GetIsVisible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the visibility flag. This flag has been set by the user and identifies if this actor instance is visible or not. This is used internally by the schedulers, so that heavy calculations can be skipped on invisible characters. </p><dl class="section return"><dt>Returns</dt><dd>Returns true when the actor instance is marked as visible, otherwise false is returned. </dd></dl>

</div>
</div>
<a id="a3879c8de8e124ef331d8981122741137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3879c8de8e124ef331d8981122741137">&#9670;&nbsp;</a></span>GetLODLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::ActorInstance::GetLODLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current used geometry and skeletal detail level. In total there are 32 possible skeletal LOD levels, where 0 is the highest detail, and 31 the lowest detail. Each detail level can disable specific nodes in the actor. These disabled nodes will not be processed at all by EMotion FX. It is important to know that disabled nodes never should be used inside skinning information or on other places where their transformations are needed. </p><dl class="section return"><dt>Returns</dt><dd>The current LOD level. </dd></dl>

</div>
</div>
<a id="a504ae9026c0f695c5ca0d018e8083b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504ae9026c0f695c5ca0d018e8083b32">&#9670;&nbsp;</a></span>GetMorphSetupInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_morph_setup_instance.html">MorphSetupInstance</a>* EMotionFX::ActorInstance::GetMorphSetupInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the morph setup instance. This doesn't contain the actual morph targets, but the unique settings per morph target. These unique settings are the weight value per morph target, and a boolean that specifies if the morph target weight should be controlled automatically (extracted from motions) or manually by user specified values. If you want to access the actual morph targets, you have to use the <a class="el" href="class_e_motion_f_x_1_1_actor.html#afc60911110e12da220581c8378565628">Actor::GetMorphSetup()</a> method. When the morph setup instance object doesn't contain any morph targets, no morphing is used. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the morph setup instance object for this actor instance. </dd></dl>

</div>
</div>
<a id="a50a5f1785ea3ffe65ba1abf6f5aee094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a5f1785ea3ffe65ba1abf6f5aee094">&#9670;&nbsp;</a></span>GetMotionSystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_motion_system.html">MotionSystem</a>* EMotionFX::ActorInstance::GetMotionSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the motion system of this actor instance. The motion system handles all the motion management and blending. If you want to play a motion or figure out what motions are currently active, you have to use the motion system class. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the motion system. </dd></dl>

</div>
</div>
<a id="a0670df127d147bf4d12b38d85734f830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0670df127d147bf4d12b38d85734f830">&#9670;&nbsp;</a></span>GetNumAttachments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::ActorInstance::GetNumAttachments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of attachments that have been added to this actor instance. </p><dl class="section return"><dt>Returns</dt><dd>The number of attachments added to this actor instance. </dd></dl>

</div>
</div>
<a id="a9efc3a9653cae6d232d707d9cadf886f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efc3a9653cae6d232d707d9cadf886f">&#9670;&nbsp;</a></span>GetNumDependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::ActorInstance::GetNumDependencies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of dependencies that this actor instance has on other actors. </p><dl class="section return"><dt>Returns</dt><dd>The number of dependencies. </dd></dl>

</div>
</div>
<a id="a2bce8e70166054df7bae876a58bbd5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bce8e70166054df7bae876a58bbd5b8">&#9670;&nbsp;</a></span>GetNumEnabledNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE size_t EMotionFX::ActorInstance::GetNumEnabledNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of enabled nodes inside this actor instance. </p><dl class="section return"><dt>Returns</dt><dd>The number of nodes that have been enabled and are being updated. </dd></dl>

</div>
</div>
<a id="afd5a0f225f14f1b0b4ef2d9331ecad48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5a0f225f14f1b0b4ef2d9331ecad48">&#9670;&nbsp;</a></span>GetRender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::ActorInstance::GetRender </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if calls to ActorUpdateCallBack::OnRender() for this actor instance are being made or not. </p><dl class="section return"><dt>Returns</dt><dd>Returns true when the ActorUpdateCallBack::OnRender() is being called for this actor instance. False is returned in case this callback won't be executed for this actor instance. </dd></dl>

</div>
</div>
<a id="a7e979a2270b42e8af8e2b5e8920ad414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e979a2270b42e8af8e2b5e8920ad414">&#9670;&nbsp;</a></span>GetSelfAttachment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_attachment.html">Attachment</a>* EMotionFX::ActorInstance::GetSelfAttachment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the attachment where this actor instance is part of. So if this actor instance is a gun, and the gun is attached to some cowboy actor instance, then the <a class="el" href="class_e_motion_f_x_1_1_attachment.html">Attachment</a> object that is returned here, is the attachment object for the gun that was added to the cowboy actor instance. </p><dl class="section return"><dt>Returns</dt><dd>The attachment where this actor instance takes part of, or nullptr when this actor instance isn't an attachment. </dd></dl>

</div>
</div>
<a id="a8b8f70add2a14f1ac284916a8f083337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8f70add2a14f1ac284916a8f083337">&#9670;&nbsp;</a></span>GetTransformData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_transform_data.html">TransformData</a>* EMotionFX::ActorInstance::GetTransformData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the transformation data class for this actor instance. This transformation data class gives you access to all the transforms of the nodes in the actor. So if you wish to get or set any transformations, you can do it with the object returned by this method. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the transformation data object. </dd></dl>

</div>
</div>
<a id="aeb88393b965b0e7e0644d1847211db12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb88393b965b0e7e0644d1847211db12">&#9670;&nbsp;</a></span>IntersectsCollisionMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a>* EMotionFX::ActorInstance::IntersectsCollisionMesh </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_core_1_1_ray.html">MCore::Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check for an intersection between the collision mesh of this actor and a given ray. Returns a pointer to the node it detected a collision in case there is a collision with any of the collision meshes of all nodes of this actor. If there is no collision mesh attached to the nodes, no intersection test will be done, and nullptr will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodLevel</td><td>The level of detail to check the collision with. </td></tr>
    <tr><td class="paramname">ray</td><td>The ray to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node we detected the first intersection with (doesn't have to be the closest), or nullptr when no intersection found. </dd></dl>

</div>
</div>
<a id="a367995512d11357e183d930bda2472b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367995512d11357e183d930bda2472b7">&#9670;&nbsp;</a></span>IntersectsCollisionMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a>* EMotionFX::ActorInstance::IntersectsCollisionMesh </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_core_1_1_ray.html">MCore::Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>outIntersect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>outNormal</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector2 *&#160;</td>
          <td class="paramname"><em>outUV</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>outBaryU</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>outBaryV</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>outIndices</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check for an intersection between the collision mesh of this actor and a given ray, and calculate the closest intersection point. If there is no collision mesh attached to the nodes, no intersection test will be done, and nullptr will be returned. Returns a pointer to the node it detected a collision in case there is a collision with the collision meshes of the actor, 'outIntersect' will contain the closest intersection point in case there is a collision. Use the other Intersects method when you do not need the intersection point (since that one is faster). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodLevel</td><td>The level of detail to check the collision with. </td></tr>
    <tr><td class="paramname">ray</td><td>The ray to test with. </td></tr>
    <tr><td class="paramname">outIntersect</td><td>A pointer to the vector to store the intersection point in, in case of a collision (nullptr allowed). </td></tr>
    <tr><td class="paramname">outNormal</td><td>A pointer to the vector to store the normal at the intersection point, in case of a collision (nullptr allowed). </td></tr>
    <tr><td class="paramname">outUV</td><td>A pointer to the vector to store the uv coordinate at the intersection point (nullptr allowed). </td></tr>
    <tr><td class="paramname">outBaryU</td><td>A pointer to a float in which the method will store the barycentric U coordinate, to be used to interpolate values on the triangle (nullptr allowed). </td></tr>
    <tr><td class="paramname">outBaryV</td><td>A pointer to a float in which the method will store the barycentric V coordinate, to be used to interpolate values on the triangle (nullptr allowed). </td></tr>
    <tr><td class="paramname">outIndices</td><td>A pointer to an array of 3 integers, which will contain the 3 vertex indices of the closest intersecting triangle. Even on polygon meshes with polygons of more than 3 vertices three indices are returned. In that case the indices represent a sub-triangle inside the polygon. A value of nullptr is allowed, which will skip storing the resulting triangle indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node we detected the closest intersection with, or nullptr when no intersection found. </dd></dl>

</div>
</div>
<a id="aaeb47cbc0d26f090cf125ad50fafabe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb47cbc0d26f090cf125ad50fafabe0">&#9670;&nbsp;</a></span>IntersectsMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a>* EMotionFX::ActorInstance::IntersectsMesh </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_core_1_1_ray.html">MCore::Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check for an intersection between the real mesh (if present) of this actor and a given ray. Returns a pointer to the node it detected a collision in case there is a collision with any of the real meshes of all nodes of this actor. If there is no mesh attached to this node, no intersection test will be performed and nullptr will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodLevel</td><td>The level of detail to check the collision with. </td></tr>
    <tr><td class="paramname">ray</td><td>The ray to test with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to itself when an intersection occurred, or nullptr when no intersection found. </dd></dl>

</div>
</div>
<a id="af6160f4c88fb36cfc16367fd4cc86317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6160f4c88fb36cfc16367fd4cc86317">&#9670;&nbsp;</a></span>IntersectsMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a>* EMotionFX::ActorInstance::IntersectsMesh </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_core_1_1_ray.html">MCore::Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>outIntersect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 *&#160;</td>
          <td class="paramname"><em>outNormal</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector2 *&#160;</td>
          <td class="paramname"><em>outUV</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>outBaryU</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>outBaryV</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>outStartIndex</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks for an intersection between the real mesh (if present) of this actor and a given ray. Returns a pointer to the node it detected a collision in case there is a collision with any of the real meshes of all nodes of this actor, 'outIntersect' will contain the closest intersection point in case there is a collision. Both the intersection point and normal which are returned are in world space. Use the other Intersects method when you do not need the intersection point (since that one is faster). Both the intersection point and normal which are returned are in world space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodLevel</td><td>The level of detail to check the collision with. </td></tr>
    <tr><td class="paramname">ray</td><td>The ray to test with. </td></tr>
    <tr><td class="paramname">outIntersect</td><td>A pointer to the vector to store the intersection point in, in case of a collision (nullptr allowed). </td></tr>
    <tr><td class="paramname">outNormal</td><td>A pointer to the vector to store the normal at the intersection point, in case of a collision (nullptr allowed). </td></tr>
    <tr><td class="paramname">outUV</td><td>A pointer to the vector to store the uv coordinate at the intersection point (nullptr allowed). </td></tr>
    <tr><td class="paramname">outBaryU</td><td>A pointer to a float in which the method will store the barycentric U coordinate, to be used to interpolate values on the triangle (nullptr allowed). </td></tr>
    <tr><td class="paramname">outBaryV</td><td>A pointer to a float in which the method will store the barycentric V coordinate, to be used to interpolate values on the triangle (nullptr allowed). </td></tr>
    <tr><td class="paramname">outIndices</td><td>A pointer to an array of 3 integers, which will contain the 3 vertex indices of the closest intersecting triangle. Even on polygon meshes with polygons of more than 3 vertices three indices are returned. In that case the indices represent a sub-triangle inside the polygon. A value of nullptr is allowed, which will skip storing the resulting triangle indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node we detected the closest intersection with, or nullptr when no intersection found. </dd></dl>

</div>
</div>
<a id="afe7ebd749e5d968a318656d3d747e9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7ebd749e5d968a318656d3d747e9df">&#9670;&nbsp;</a></span>MotionExtractionCompensate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void EMotionFX::ActorInstance::MotionExtractionCompensate </td>
          <td>(</td>
          <td class="paramtype">Transform &amp;&#160;</td>
          <td class="paramname"><em>inOutMotionExtractionNodeTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Transform &amp;&#160;</td>
          <td class="paramname"><em>localSpaceBindPoseTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EMotionExtractionFlags&#160;</td>
          <td class="paramname"><em>motionExtractionFlags</em> = <code>(EMotionExtractionFlags)&#160;0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the trajectory transform from the input transformation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">inOutMotionExtractionNodeTransform</td><td>Local space transformation of the motion extraction joint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localSpaceBindPoseTransform</td><td>Bind pose transform of the motion extraction joint in local space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">motionExtractionFlags</td><td><a class="el" href="class_e_motion_f_x_1_1_motion.html">Motion</a> extraction capture options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a7e03b04882dfb1ee7372902f278df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7e03b04882dfb1ee7372902f278df3">&#9670;&nbsp;</a></span>RecursiveAddDependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::RecursiveAddDependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> *&#160;</td>
          <td class="paramname"><em>actor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively add dependencies for the given actor. This will add all dependencies stored in the specified actor, to this actor instance. Also it will recurse into the dependencies of the dependencies of the given actor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actor</td><td>The actor we should recursively copy the dependencies from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a6d3cc10985acd0070da8fefb6f5c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6d3cc10985acd0070da8fefb6f5c93">&#9670;&nbsp;</a></span>RecursiveHasAttachment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::ActorInstance::RecursiveHasAttachment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> *&#160;</td>
          <td class="paramname"><em>attachmentInstance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if this actor instance has a specific attachment that uses a specified actor instance. This function is recursive, so it also checks the attachments of the attachments, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachmentInstance</td><td>The actor instance you want to check with, which represents the attachment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the specified actor instance is being used as attachment down the hierarchy, otherwise false is returned. </dd></dl>

</div>
</div>
<a id="a643466acb234aea5bd98771f52b0512e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643466acb234aea5bd98771f52b0512e">&#9670;&nbsp;</a></span>RecursiveSetIsVisible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::RecursiveSetIsVisible </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVisible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies if this actor instance is visible or not. This recursively propagates its visibility status to child attachments. So if your horse is visibe then the rider that is attached on top of the horse will also become marked as visible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Specify</td><td>if all nodes touched should be marked as visible or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac252e3183877a3d995fbb19ec16d300c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac252e3183877a3d995fbb19ec16d300c">&#9670;&nbsp;</a></span>RecursiveSetIsVisibleTowardsRoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::RecursiveSetIsVisibleTowardsRoot </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVisible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively set the actor instance visibility flag, upwards in hierarchy, moving from an attachment up to the root actor instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Specify</td><td>if all nodes touched should be marked as visible or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada86767a29113acb688cd5f627c22f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada86767a29113acb688cd5f627c22f06">&#9670;&nbsp;</a></span>RemoveAllAttachments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::RemoveAllAttachments </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delFromMem</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all attachments from this actor instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delFromMem</td><td>Set this to true when you want the attachments also to be deleted from memory. When you set this to false, it will not be deleted from memory, but only removed from the array of attachments that is stored locally inside this actor instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78c4e5308e0e2723d66768c150f50bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c4e5308e0e2723d66768c150f50bdb">&#9670;&nbsp;</a></span>RemoveAttachment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::ActorInstance::RemoveAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> *&#160;</td>
          <td class="paramname"><em>actorInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delFromMem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an attachment that uses a specified actor instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actorInstance</td><td>The actor instance that the attachment is using. </td></tr>
    <tr><td class="paramname">delFromMem</td><td>Set this to true when you want the attachment also to be deleted from memory. When you set this to false, it will not be deleted from memory, but only removed from the array of attachments that is stored locally inside this actor instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01a833d0a7b404789c9b93dabadd0e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a833d0a7b404789c9b93dabadd0e7a">&#9670;&nbsp;</a></span>RemoveAttachment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::RemoveAttachment </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delFromMem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a given attachment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>The attachment number, which must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a0670df127d147bf4d12b38d85734f830">GetNumAttachments()</a>-1]. </td></tr>
    <tr><td class="paramname">delFromMem</td><td>Set this to true when you want the attachment that gets removed also to be deleted from memory. When you set this to false, it will not be deleted from memory, but only removed from the array of attachments that is stored locally inside this actor instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac654235fbf660ac22d2766c950ef8865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac654235fbf660ac22d2766c950ef8865">&#9670;&nbsp;</a></span>SetAabb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetAabb </td>
          <td>(</td>
          <td class="paramtype">const AZ::Aabb &amp;&#160;</td>
          <td class="paramname"><em>aabb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the axis aligned bounding box. Please beware that this box will get automatically overwritten when automatic bounds update is enabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aabb</td><td>The axis aligned bounding box to store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4528d9c1fe0c5dc2c429ccdcf077784d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4528d9c1fe0c5dc2c429ccdcf077784d">&#9670;&nbsp;</a></span>SetAnimGraphInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetAnimGraphInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_anim_graph_instance.html">AnimGraphInstance</a> *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the anim graph instance. This can be nullptr, in which case the motion system as returned by <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a50a5f1785ea3ffe65ba1abf6f5aee094">GetMotionSystem()</a> will be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The anim graph instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18ab5a91e774eb3f9a37989df0cd1124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ab5a91e774eb3f9a37989df0cd1124">&#9670;&nbsp;</a></span>SetBoundsUpdateEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetBoundsUpdateEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify whether you want the auto-bounds update to be enabled or disabled. On default, after creation of the actor instance it is enabled, using node based, with an update frequency of 1 and an update frequency of 0.1 (ten times per second). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Set to true when you want to enable the bounds automatic update feature, or false when you'd like to disable it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6f30fa140e190496c96beddc7251e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f30fa140e190496c96beddc7251e64">&#9670;&nbsp;</a></span>SetBoundsUpdateFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetBoundsUpdateFrequency </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the auto-bounds update time frequency, in seconds. This specifies the time interval between bounds updates. A value of 0.1 would mean that the bounding volumes will be updated 10 times per second. A value of 0.25 means 4 times per second, etc. A value of 0 can be used to force the updates to happen every frame. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>The amount of seconds between every bounding volume update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a993a9ee25e9cef22f26414de820ae084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993a9ee25e9cef22f26414de820ae084">&#9670;&nbsp;</a></span>SetBoundsUpdateItemFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetBoundsUpdateItemFrequency </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>freq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the bounding volume auto-update item frequency. A value of 1 would mean every node or vertex will be taken into account in the bounds calculation. A value of 2 would mean every second node or vertex would be taken into account. A value of 5 means every 5th node or vertex, etc. Higher values will result in faster bounds updates, but also in possibly less accurate bounds. The frequency value must always be greater than or equal to one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>The item frequency, which has to be 1 or above. Higher values result in faster performance, but lower accuracy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4188f42607a5c5efd4da362d60f66a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4188f42607a5c5efd4da362d60f66a0c">&#9670;&nbsp;</a></span>SetBoundsUpdatePassedTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetBoundsUpdatePassedTime </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the time passed since the last automatic bounds update. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>The amount of seconds, since the last automatic update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae82e6fa2969ceb3f646af87581dfd9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82e6fa2969ceb3f646af87581dfd9fd">&#9670;&nbsp;</a></span>SetBoundsUpdateType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetBoundsUpdateType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6c">EBoundsType</a>&#160;</td>
          <td class="paramname"><em>bType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the bounding volume auto-update type. This can be either based on the node's world space positions, the mesh vertex world space positions, or the collision mesh vertex world space positions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bType</td><td>The bounding volume update type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2354656fbe2463b54d2c61c3d469daae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2354656fbe2463b54d2c61c3d469daae">&#9670;&nbsp;</a></span>SetCustomData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetCustomData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>customData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a pointer to some custom data you want to store and link with this actor instance object. Custom data can for example link a game or engine object with this EMotion FX <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> object. An example is when EMotion FX triggers a motion event. You know the actor that triggered the event, but you don't know directly what game or engine object is linked to this actor. By using the custom data methods GetCustomData and SetCustomData you can set a pointer to your game or engine object in each actor instance. The pointer that you specify will not be deleted when the actor instance is being destructed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">customData</td><td>A void pointer to the custom data to link with this actor instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af418a56d1de20f36c4cf95e3aaeea6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af418a56d1de20f36c4cf95e3aaeea6bc">&#9670;&nbsp;</a></span>SetExpandBoundsBy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetExpandBoundsBy </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>expandBy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the normalized percentage that the calculated bounding box should be expanded with. This can be used to add a tolerance area to the calculated bounding box to avoid clipping the character too early. A static bounding box together with the expansion is the recommended way for maximum performance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expandBy</td><td>A value of 1.0 means that the calculated bounding box won't be expanded at all, while 2.0 means it will be twice the size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8bad79f6be78fe9f43f72b9ff048794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bad79f6be78fe9f43f72b9ff048794">&#9670;&nbsp;</a></span>SetID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetID </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the unique identification number for the actor instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The unique identification number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16f282d0d3090bf4a696271548a330c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f282d0d3090bf4a696271548a330c4">&#9670;&nbsp;</a></span>SetIsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetIsEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable this actor instance. Disabled actor instances are not processed at all. It will be like they do not exist. On default the actor instance is enabled, after creation. You can disable an actor instance that acts as skin attachment, but is not currently attached. This way the clothing items your character doesn't wear won't take processing power. It is always faster not to have the actor instance created at all in such case though. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Specifies whether this actor instance is enabled or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada715c19c1310f8e0c4042e09cdad3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada715c19c1310f8e0c4042e09cdad3a7">&#9670;&nbsp;</a></span>SetIsOwnedByRuntime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetIsOwnedByRuntime </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isOwnedByRuntime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks the actor instance as used by the engine runtime, as opposed to the tool suite. </p>

</div>
</div>
<a id="a7014d484d0638bfbbf1390d921d8fc3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7014d484d0638bfbbf1390d921d8fc3d">&#9670;&nbsp;</a></span>SetIsVisible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetIsVisible </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVisible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the visibility state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isVisible</td><td>Set to true when the actor instance is visible, otherwise set it to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46463a57b1c2d09d76b95214ac97a57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46463a57b1c2d09d76b95214ac97a57b">&#9670;&nbsp;</a></span>SetLocalSpacePosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void EMotionFX::ActorInstance::SetLocalSpacePosition </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the local space position of this actor instance. This is relative to its parent (if it is attached ot something). Otherwise it is in world space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position/translation to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44baacd12e3c6df7c1d2493ccad7dc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44baacd12e3c6df7c1d2493ccad7dc9b">&#9670;&nbsp;</a></span>SetLocalSpaceRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void EMotionFX::ActorInstance::SetLocalSpaceRotation </td>
          <td>(</td>
          <td class="paramtype">const AZ::Quaternion &amp;&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the local rotation of this actor instance. This is relative to its parent (if it is attached ot something). Otherwise it is in world space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>The rotation to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bbb5fabd3897360ded7ed2e2a936f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbb5fabd3897360ded7ed2e2a936f21">&#9670;&nbsp;</a></span>SetLODLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetLODLevel </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the current geometry and skeletal detail level, where 0 is the highest detail. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The LOD level. Values higher than [GetNumGeometryLODLevels()-1] will be clamped to the maximum LOD. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b52a9e4e042ce6271d3ff6f246c4d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b52a9e4e042ce6271d3ff6f246c4d9d">&#9670;&nbsp;</a></span>SetMotionSystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetMotionSystem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_motion_system.html">MotionSystem</a> *&#160;</td>
          <td class="paramname"><em>newSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delCurrentFromMem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the current motion system to use. On default a <a class="el" href="class_e_motion_f_x_1_1_motion_layer_system.html">MotionLayerSystem</a> is set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSystem</td><td>The new motion system to use. </td></tr>
    <tr><td class="paramname">delCurrentFromMem</td><td>If set to true, the currently set motion system will be deleted from memory, before setting the new motion system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7545ddf5e3d72fd2dcede347e358080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7545ddf5e3d72fd2dcede347e358080">&#9670;&nbsp;</a></span>SetRender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetRender </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set whether calls to ActorUpdateCallBack::OnRender() for this actor instance should be made or not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to true when the ActorUpdateCallBack::OnRender() should be called for this actor instance, otherwise set to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a150e6f6be16d6c9653e1bc599b76d2c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150e6f6be16d6c9653e1bc599b76d2c3">&#9670;&nbsp;</a></span>SetupAutoBoundsUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::SetupAutoBoundsUpdate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>updateFrequencyInSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6c">EBoundsType</a>&#160;</td>
          <td class="paramname"><em>boundsType</em> = <code><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6ca88d7ab77f647de81bc31d7d99b0d0859">BOUNDS_NODE_BASED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>itemFrequency</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setup the automatic update settings of the bounding volume. This allows you to specify at what time interval the bounding volume of the actor instance should be updated and if this update should base its calculations on the nodes, mesh vertices or collision mesh vertices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">updateFrequencyInSeconds</td><td>The bounds will be updated every "updateFrequencyInSeconds" seconds. A value of 0 would mean every frame and a value of 0.1 would mean 10 times per second. </td></tr>
    <tr><td class="paramname">boundsType</td><td>The type of bounds calculation. This can be either based on the node's world space positions, the mesh world space positions or the collision mesh world space positions. </td></tr>
    <tr><td class="paramname">itemFrequency</td><td>A value of 1 would mean every node or vertex will be taken into account in the bounds calculation. A value of 2 would mean every second node or vertex would be taken into account. A value of 5 means every 5th node or vertex, etc. Higher values will result in faster bounds updates, but also in possibly less accurate bounds. This value must 1 or higher. Zero is not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c1dfeabc2fa88713c053b686e35749c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1dfeabc2fa88713c053b686e35749c">&#9670;&nbsp;</a></span>UpdateAttachments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::UpdateAttachments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update all the attachments. This calls the update method for each attachment. </p>

</div>
</div>
<a id="af0eb8c912a68fc4a9432402a7c07da6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0eb8c912a68fc4a9432402a7c07da6d">&#9670;&nbsp;</a></span>UpdateBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::UpdateBounds </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>geomLODLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6c">EBoundsType</a>&#160;</td>
          <td class="paramname"><em>boundsType</em> = <code><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html#a194a056f8a28e8d95c25ec527a05ff6ca88d7ab77f647de81bc31d7d99b0d0859">BOUNDS_NODE_BASED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>itemFrequency</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the bounding volumes of the actor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geomLODLevel</td><td>The geometry level of detail number to generate the LOD for. Must be in range of 0..GetNumGeometryLODLevels()-1. The same LOD level will be chosen for the attachments when they will be included. If the specified LOD level is lower than the number of attachment LODS, the lowest attachment LOD will be chosen. </td></tr>
    <tr><td class="paramname">boundsType</td><td>The bounding volume generation method, each having different accuracies and generation speeds. </td></tr>
    <tr><td class="paramname">itemFrequency</td><td>Depending on the type of bounds you specify to the boundsType parameter, this specifies how many "vertices or nodes" the updating functions should skip. If you specified a value of 4, and use BOUND_MESH_BASED or collision mesh based, every 4th vertex will be included in the bounds calculation, so only processing 25% of the total number of vertices. The same goes for node based bounds, but then it will process every 4th node. Of course higher values produce less accurate results, but are faster to process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b38bd4e21d3eae57a27f7f52a3f111e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b38bd4e21d3eae57a27f7f52a3f111e">&#9670;&nbsp;</a></span>UpdateDependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::UpdateDependencies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update all dependencies of this actor instance. </p>

</div>
</div>
<a id="ab61b7f8e2a25d9e0380eed7ca9855312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61b7f8e2a25d9e0380eed7ca9855312">&#9670;&nbsp;</a></span>UpdateMeshDeformers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::UpdateMeshDeformers </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>timePassedInSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>processDisabledDeformers</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update/Process the mesh deformers. This will apply skinning and morphing deformations to the meshes used by the actor instance. All deformations happen on the CPU. So if you use pure GPU processing, you should not be calling this method. Also invisible actor instances should not update their mesh deformers, as this can be very CPU intensive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timePassedInSeconds</td><td>The time passed in seconds, since the last frame or update. </td></tr>
    <tr><td class="paramname">processDisabledDeformers</td><td>When set to true, even mesh deformers that are disabled will even be processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef228ac0ff11f605818e46ac0e006c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef228ac0ff11f605818e46ac0e006c0a">&#9670;&nbsp;</a></span>UpdateMorphMeshDeformers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::UpdateMorphMeshDeformers </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>timePassedInSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>processDisabledDeformers</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update/Process the morph mesh deformers. This will apply morphing deformations only to the meshes used by the actor instance. All morph deformations happen on the CPU. So if you use pure GPU processing, you should not be calling this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timePassedInSeconds</td><td>The time passed in seconds, since the last frame or update. </td></tr>
    <tr><td class="paramname">processDisabledDeformers</td><td>When set to true, even mesh deformers that are disabled will even be processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b4715b7d6dadec79ebd022047aa3095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4715b7d6dadec79ebd022047aa3095">&#9670;&nbsp;</a></span>UpdateSkeletalLODFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::UpdateSkeletalLODFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the skeletal LOD flags from the nodes of the corresponding actor and pass them over to this actor instance. The actor keeps the information about which nodes are enabled at what skeletal LOD and this is the transfer function to actually apply it to the actor instance as each actor instance can be in a different skeletal LOD level. </p>

</div>
</div>
<a id="a075ad81858e945794b3fdcbaae1475dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075ad81858e945794b3fdcbaae1475dc">&#9670;&nbsp;</a></span>UpdateSkinningMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::UpdateSkinningMatrices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the skinning matrices. This will update the data inside the <a class="el" href="class_e_motion_f_x_1_1_transform_data.html">TransformData</a> class. </p>

</div>
</div>
<a id="af832651b8cf9a541f4968f1a10371711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af832651b8cf9a541f4968f1a10371711">&#9670;&nbsp;</a></span>UpdateStaticBasedAabbDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::UpdateStaticBasedAabbDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the base static axis aligned bounding box shape. This is a quite heavy function in comparision to the CalcStaticBasedAABB. Basically the dimensions of the static based aabb are calculated here. First it will try to generate the aabb from the meshes. If there are no meshes it will use a node based aabb as basis. After that it will find the maximum of the depth, width and height, and makes all dimensions the same as this max value. This function is generally only executed once, when creating the actor instance. The CalcStaticBasedAABB function then simply translates this box along with the actor instance's position. </p>

</div>
</div>
<a id="ab739b25487943f4cce4b9b1ed458b1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab739b25487943f4cce4b9b1ed458b1dd">&#9670;&nbsp;</a></span>UpdateTransformations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::ActorInstance::UpdateTransformations </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>timePassedInSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>updateJointTransforms</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sampleMotions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the transformations of this actor instance. This can be the actor instance transform and can also include the joint transforms. This automatically updates all motion timers and anim graph nodes as well. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timePassedInSeconds</td><td>The time passed in seconds, since the last frame or update. </td></tr>
    <tr><td class="paramname">updateJointTransforms</td><td>When set to true the joint transformations will be calculated by calculating the animation graph output for example. </td></tr>
    <tr><td class="paramname">sampleMotions</td><td>When set to true motions will be sampled, or whole anim graphs if using those. When updateMatrices is set to false, motions will never be sampled, even if set to true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Gems/EMotionFX/Code/EMotionFX/Source/ActorInstance.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>EMotionFX</b></li><li class="navelem"><a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a></li>
    <li class="footer">Generated on Tue Oct 8 2024 21:27:43 for Open 3D Engine EMotionFX Gem API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
