<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Open 3D Engine EMotionFX Gem API Reference: EMotionFX::Actor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine EMotionFX Gem API Reference
   &#160;<span id="projectnumber">23.05.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_e_motion_f_x_1_1_actor.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_e_motion_f_x_1_1_actor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">EMotionFX::Actor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;Actor.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_motion_f_x_1_1_actor_1_1_dependency.html">Dependency</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_motion_f_x_1_1_actor_1_1_node_mirror_info.html">NodeMirrorInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac4dd405dad9df9990469fb72f94db5ad"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>MIRRORFLAG_INVERT_X</b> = 1 &lt;&lt; 0, 
<b>MIRRORFLAG_INVERT_Y</b> = 1 &lt;&lt; 1, 
<b>MIRRORFLAG_INVERT_Z</b> = 1 &lt;&lt; 2
 }</td></tr>
<tr class="separator:ac4dd405dad9df9990469fb72f94db5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f23f1e62edb0717fa480a05534bef5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>EAxis</b> : uint8 { <b>AXIS_X</b> = 0, 
<b>AXIS_Y</b> = 1, 
<b>AXIS_Z</b> = 2
 }</td></tr>
<tr class="separator:a30f23f1e62edb0717fa480a05534bef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace494fc2a33b143d44d80b0a4d817191"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>LoadRequirement</b> : bool { <b>RequireBlockingLoad</b>, 
<b>AllowAsyncLoad</b>
 }</td></tr>
<tr class="separator:ace494fc2a33b143d44d80b0a4d817191"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5fb8b2d7d478a76ef9d8cfbc85aca0e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a5fb8b2d7d478a76ef9d8cfbc85aca0e2">Actor</a> (const char *name)</td></tr>
<tr class="separator:a5fb8b2d7d478a76ef9d8cfbc85aca0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaea7fd55dd2d6b15689d71e2658f798"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#afaea7fd55dd2d6b15689d71e2658f798">GetID</a> () const </td></tr>
<tr class="separator:afaea7fd55dd2d6b15689d71e2658f798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb11060aad48e044c177af8242713b88"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#acb11060aad48e044c177af8242713b88">SetID</a> (uint32 id)</td></tr>
<tr class="separator:acb11060aad48e044c177af8242713b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef54597acb30b84e6a29c124aa67431"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a5ef54597acb30b84e6a29c124aa67431">AddNode</a> (<a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *node)</td></tr>
<tr class="separator:a5ef54597acb30b84e6a29c124aa67431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bcc14d8448b0d2aa272a79319cf229"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a47bcc14d8448b0d2aa272a79319cf229">AddNode</a> (size_t nodeIndex, const char *name, size_t parentIndex=InvalidIndex)</td></tr>
<tr class="separator:a47bcc14d8448b0d2aa272a79319cf229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8e84626f1e65650e5ac040b367a5d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a7b8e84626f1e65650e5ac040b367a5d9">RemoveNode</a> (size_t nr, bool delMem=true)</td></tr>
<tr class="separator:a7b8e84626f1e65650e5ac040b367a5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4113d10df23926337f1c0b5f0338bd8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a4113d10df23926337f1c0b5f0338bd8d">DeleteAllNodes</a> ()</td></tr>
<tr class="separator:a4113d10df23926337f1c0b5f0338bd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf0773caab0f6a6533cbe15346cff7f"><td class="memItemLeft" align="right" valign="top">AZStd::unique_ptr&lt; <a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a6cf0773caab0f6a6533cbe15346cff7f">Clone</a> () const </td></tr>
<tr class="separator:a6cf0773caab0f6a6533cbe15346cff7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62f8cd6a46f5cb87fb2d8a59c6cf20d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#ac62f8cd6a46f5cb87fb2d8a59c6cf20d">Scale</a> (float scaleFactor)</td></tr>
<tr class="separator:ac62f8cd6a46f5cb87fb2d8a59c6cf20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab4b124983080c05a52734f21f9bbc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a9ab4b124983080c05a52734f21f9bbc8">ScaleToUnitType</a> (MCore::Distance::EUnitType targetUnitType)</td></tr>
<tr class="separator:a9ab4b124983080c05a52734f21f9bbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e8773c1003ffd14ad7a72422752979"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#aa0e8773c1003ffd14ad7a72422752979">FindBestMotionExtractionNode</a> () const </td></tr>
<tr class="separator:aa0e8773c1003ffd14ad7a72422752979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96ec525b6c474691b5cfc189065d646"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#ae96ec525b6c474691b5cfc189065d646">AutoSetMotionExtractionNode</a> ()</td></tr>
<tr class="separator:ae96ec525b6c474691b5cfc189065d646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759ffbd12ae4344405707ad432ffc4ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a759ffbd12ae4344405707ad432ffc4ca">GenerateUpdatePathToRoot</a> (size_t endNodeIndex, AZStd::vector&lt; size_t &gt; &amp;outPath) const </td></tr>
<tr class="separator:a759ffbd12ae4344405707ad432ffc4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1883f2bc2f474c6b9f48a1d093d43dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a1883f2bc2f474c6b9f48a1d093d43dcb">SetMotionExtractionNode</a> (<a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *node)</td></tr>
<tr class="separator:a1883f2bc2f474c6b9f48a1d093d43dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cd5e5de79099d727c342d2425e1228"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#ae5cd5e5de79099d727c342d2425e1228">SetMotionExtractionNodeIndex</a> (size_t nodeIndex)</td></tr>
<tr class="separator:ae5cd5e5de79099d727c342d2425e1228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17d8f0ba205a6da060c5c7269630ffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#ac17d8f0ba205a6da060c5c7269630ffd">GetMotionExtractionNode</a> () const </td></tr>
<tr class="separator:ac17d8f0ba205a6da060c5c7269630ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefbe87c6442ae4f7c7e8fb4bdc927dd"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#adefbe87c6442ae4f7c7e8fb4bdc927dd">GetMotionExtractionNodeIndex</a> () const </td></tr>
<tr class="separator:adefbe87c6442ae4f7c7e8fb4bdc927dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335ada7775f4c68299e88d22db7bb4b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a335ada7775f4c68299e88d22db7bb4b7">CheckIfHasMeshes</a> (size_t lodLevel) const </td></tr>
<tr class="separator:a335ada7775f4c68299e88d22db7bb4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02919d23f6aad50d8bf5050372e30a57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a02919d23f6aad50d8bf5050372e30a57">CheckIfHasSkinnedMeshes</a> (size_t lodLevel) const </td></tr>
<tr class="separator:a02919d23f6aad50d8bf5050372e30a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c3c6497a412e35bed18330cbd8ab33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#af2c3c6497a412e35bed18330cbd8ab33">ExtractBoneList</a> (size_t lodLevel, AZStd::vector&lt; size_t &gt; *outBoneList) const </td></tr>
<tr class="separator:af2c3c6497a412e35bed18330cbd8ab33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5512cee097eae513c55a92c288246d9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5512cee097eae513c55a92c288246d9b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetPhysicsSetup</b> (const AZStd::shared_ptr&lt; <a class="el" href="class_e_motion_f_x_1_1_physics_setup.html">PhysicsSetup</a> &gt; &amp;physicsSetup)</td></tr>
<tr class="separator:a5512cee097eae513c55a92c288246d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9008214760d48023adfa9fa5b58ddb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a9008214760d48023adfa9fa5b58ddb"></a>
const AZStd::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="class_e_motion_f_x_1_1_physics_setup.html">PhysicsSetup</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetPhysicsSetup</b> () const </td></tr>
<tr class="separator:a2a9008214760d48023adfa9fa5b58ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be5cc39bb65de03c10d8ac3265051a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8be5cc39bb65de03c10d8ac3265051a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetSimulatedObjectSetup</b> (const AZStd::shared_ptr&lt; <a class="el" href="class_e_motion_f_x_1_1_simulated_object_setup.html">SimulatedObjectSetup</a> &gt; &amp;setup)</td></tr>
<tr class="separator:a8be5cc39bb65de03c10d8ac3265051a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2968a4eadb9f8942cdb69052848f72cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2968a4eadb9f8942cdb69052848f72cb"></a>
const AZStd::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="class_e_motion_f_x_1_1_simulated_object_setup.html">SimulatedObjectSetup</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetSimulatedObjectSetup</b> () const </td></tr>
<tr class="separator:a2968a4eadb9f8942cdb69052848f72cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bce69a29c8ccc433371ad7537d349c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a46bce69a29c8ccc433371ad7537d349c">AddLODLevel</a> (bool copyFromLastLODLevel=true)</td></tr>
<tr class="separator:a46bce69a29c8ccc433371ad7537d349c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550e115f96a167524134a7d773386892"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a550e115f96a167524134a7d773386892">CopyLODLevel</a> (<a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> *copyActor, size_t copyLODLevel, size_t replaceLODLevel, bool copySkeletalLODFlags)</td></tr>
<tr class="separator:a550e115f96a167524134a7d773386892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cb2fbed44c360f0913620673836e15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a19cb2fbed44c360f0913620673836e15">InsertLODLevel</a> (size_t insertAt)</td></tr>
<tr class="separator:a19cb2fbed44c360f0913620673836e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ccaeec356267a8d253de798847310b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#ac2ccaeec356267a8d253de798847310b">SetNumLODLevels</a> (size_t numLODs, bool adjustMorphSetup=true)</td></tr>
<tr class="separator:ac2ccaeec356267a8d253de798847310b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78755caf37b41d6072466f3502923698"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a78755caf37b41d6072466f3502923698">GetNumLODLevels</a> () const </td></tr>
<tr class="separator:a78755caf37b41d6072466f3502923698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b34ebf73d08c5db52429a04a9927f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a31b34ebf73d08c5db52429a04a9927f3">RemoveAllNodeMeshes</a> ()</td></tr>
<tr class="separator:a31b34ebf73d08c5db52429a04a9927f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1692299b03dccff85ec31929d4455b2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a1692299b03dccff85ec31929d4455b2f">CalcMeshTotals</a> (size_t lodLevel, uint32 *outNumPolygons, uint32 *outNumVertices, uint32 *outNumIndices) const </td></tr>
<tr class="separator:a1692299b03dccff85ec31929d4455b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ededab5573db9d05502848f5451f29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a54ededab5573db9d05502848f5451f29">CalcStaticMeshTotals</a> (size_t lodLevel, uint32 *outNumVertices, uint32 *outNumIndices)</td></tr>
<tr class="separator:a54ededab5573db9d05502848f5451f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadea88b6150d5b46efd3e7f7adb7e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#acadea88b6150d5b46efd3e7f7adb7e95">CalcDeformableMeshTotals</a> (size_t lodLevel, uint32 *outNumVertices, uint32 *outNumIndices)</td></tr>
<tr class="separator:acadea88b6150d5b46efd3e7f7adb7e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3263fba7bc8ca94033903ecfe11f18"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#adb3263fba7bc8ca94033903ecfe11f18">CalcMaxNumInfluences</a> (size_t lodLevel) const </td></tr>
<tr class="separator:adb3263fba7bc8ca94033903ecfe11f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25584365b9cdc30a3098260038873e96"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a25584365b9cdc30a3098260038873e96">CalcMaxNumInfluences</a> (size_t lodLevel, AZStd::vector&lt; size_t &gt; &amp;outVertexCounts) const </td></tr>
<tr class="separator:a25584365b9cdc30a3098260038873e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed915a7c71927e024ea9b26548cd6f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#abed915a7c71927e024ea9b26548cd6f0">VerifySkinning</a> (AZStd::vector&lt; uint8 &gt; &amp;conflictNodeFlags, size_t skeletalLODLevel, size_t geometryLODLevel)</td></tr>
<tr class="separator:abed915a7c71927e024ea9b26548cd6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc1f7d0fcf63ea3f7d6319b10d6ee1c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a9cc1f7d0fcf63ea3f7d6319b10d6ee1c">GetCustomData</a> () const </td></tr>
<tr class="separator:a9cc1f7d0fcf63ea3f7d6319b10d6ee1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476f86af2bcbe125ec8109ba60d6e8f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a476f86af2bcbe125ec8109ba60d6e8f0">SetCustomData</a> (void *dataPointer)</td></tr>
<tr class="separator:a476f86af2bcbe125ec8109ba60d6e8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b4c0870a5f0b08188552b9309a1fe0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#aa2b4c0870a5f0b08188552b9309a1fe0">SetName</a> (const char *name)</td></tr>
<tr class="separator:aa2b4c0870a5f0b08188552b9309a1fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d65bf17912268f2eda0f473f80b4361"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a1d65bf17912268f2eda0f473f80b4361">GetName</a> () const </td></tr>
<tr class="separator:a1d65bf17912268f2eda0f473f80b4361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b19aefff6485de86393ae1b7734d86"><td class="memItemLeft" align="right" valign="top">const AZStd::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#af4b19aefff6485de86393ae1b7734d86">GetNameString</a> () const </td></tr>
<tr class="separator:af4b19aefff6485de86393ae1b7734d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4870d72ffe5c58dfb56e3e036f3ae037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a4870d72ffe5c58dfb56e3e036f3ae037">SetFileName</a> (const char *filename)</td></tr>
<tr class="separator:a4870d72ffe5c58dfb56e3e036f3ae037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9246d6de1c99852307d274affa54bed"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#af9246d6de1c99852307d274affa54bed">GetFileName</a> () const </td></tr>
<tr class="separator:af9246d6de1c99852307d274affa54bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3ce142e07d42d28e4bad187d00f808"><td class="memItemLeft" align="right" valign="top">const AZStd::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a9b3ce142e07d42d28e4bad187d00f808">GetFileNameString</a> () const </td></tr>
<tr class="separator:a9b3ce142e07d42d28e4bad187d00f808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e591f7db9da96067aa4f3b11901bcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a28e591f7db9da96067aa4f3b11901bcb">AddDependency</a> (const <a class="el" href="struct_e_motion_f_x_1_1_actor_1_1_dependency.html">Dependency</a> &amp;dependency)</td></tr>
<tr class="separator:a28e591f7db9da96067aa4f3b11901bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f1ddc402f4c1fb48c6dfd8dcf64fc9"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a66f1ddc402f4c1fb48c6dfd8dcf64fc9">GetNumDependencies</a> () const </td></tr>
<tr class="separator:a66f1ddc402f4c1fb48c6dfd8dcf64fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe144f686b22570ffa5e883a09cf5f2"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE <a class="el" href="struct_e_motion_f_x_1_1_actor_1_1_dependency.html">Dependency</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#aefe144f686b22570ffa5e883a09cf5f2">GetDependency</a> (size_t nr)</td></tr>
<tr class="separator:aefe144f686b22570ffa5e883a09cf5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec5cf85deed4bb0f48b98cbff77316a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adec5cf85deed4bb0f48b98cbff77316a"></a>
MCORE_INLINE const <a class="el" href="struct_e_motion_f_x_1_1_actor_1_1_dependency.html">Dependency</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetDependency</b> (size_t nr) const </td></tr>
<tr class="separator:adec5cf85deed4bb0f48b98cbff77316a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9214b2db7be5e22104d8a4ec9244d9ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a9214b2db7be5e22104d8a4ec9244d9ae">RecursiveAddDependencies</a> (const <a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> *actor)</td></tr>
<tr class="separator:a9214b2db7be5e22104d8a4ec9244d9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5721f168b625e44aaf881fa4d58ac6"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_morph_setup.html">MorphSetup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#abd5721f168b625e44aaf881fa4d58ac6">GetMorphSetup</a> (size_t geomLODLevel) const </td></tr>
<tr class="separator:abd5721f168b625e44aaf881fa4d58ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5095d71a7af3877dd6bf9055f12049"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a4d5095d71a7af3877dd6bf9055f12049">RemoveAllMorphSetups</a> (bool deleteMeshDeformers=true)</td></tr>
<tr class="separator:a4d5095d71a7af3877dd6bf9055f12049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68bb7957c830caf0bf9c80a3d7a91a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#ae68bb7957c830caf0bf9c80a3d7a91a6">SetMorphSetup</a> (size_t lodLevel, <a class="el" href="class_e_motion_f_x_1_1_morph_setup.html">MorphSetup</a> *setup)</td></tr>
<tr class="separator:ae68bb7957c830caf0bf9c80a3d7a91a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bfc192661677bbc5e4e366810ac7ee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#ad6bfc192661677bbc5e4e366810ac7ee">GetNumNodeGroups</a> () const </td></tr>
<tr class="separator:ad6bfc192661677bbc5e4e366810ac7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba617c67fec91709e2aecdfe7d997a14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_node_group.html">NodeGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#aba617c67fec91709e2aecdfe7d997a14">GetNodeGroup</a> (size_t index) const </td></tr>
<tr class="separator:aba617c67fec91709e2aecdfe7d997a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb271f489fb14201657f29a58971a56a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#acb271f489fb14201657f29a58971a56a">AddNodeGroup</a> (<a class="el" href="class_e_motion_f_x_1_1_node_group.html">NodeGroup</a> *newGroup)</td></tr>
<tr class="separator:acb271f489fb14201657f29a58971a56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2be4f32aef78414113bbff6461d648"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a3f2be4f32aef78414113bbff6461d648">RemoveNodeGroup</a> (size_t index, bool delFromMem=true)</td></tr>
<tr class="separator:a3f2be4f32aef78414113bbff6461d648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d936106ca228b7d47120975b688b60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a28d936106ca228b7d47120975b688b60">RemoveNodeGroup</a> (<a class="el" href="class_e_motion_f_x_1_1_node_group.html">NodeGroup</a> *group, bool delFromMem=true)</td></tr>
<tr class="separator:a28d936106ca228b7d47120975b688b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861f3c434785dbdbbb68e17ac1ad55b7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a861f3c434785dbdbbb68e17ac1ad55b7">FindNodeGroupIndexByName</a> (const char *groupName) const </td></tr>
<tr class="separator:a861f3c434785dbdbbb68e17ac1ad55b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6482983dae6b9339730b76466e4266d5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a6482983dae6b9339730b76466e4266d5">FindNodeGroupIndexByNameNoCase</a> (const char *groupName) const </td></tr>
<tr class="separator:a6482983dae6b9339730b76466e4266d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef5cd974984c057171b81edbfbb412a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_node_group.html">NodeGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#abef5cd974984c057171b81edbfbb412a">FindNodeGroupByName</a> (const char *groupName) const </td></tr>
<tr class="separator:abef5cd974984c057171b81edbfbb412a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7da4402ad74bbd6370090dc695f1acf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_e_motion_f_x_1_1_node_group.html">NodeGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#ab7da4402ad74bbd6370090dc695f1acf">FindNodeGroupByNameNoCase</a> (const char *groupName) const </td></tr>
<tr class="separator:ab7da4402ad74bbd6370090dc695f1acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9fee8c1e67fd12c9a986ff279e59f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a0e9fee8c1e67fd12c9a986ff279e59f2">RemoveAllNodeGroups</a> ()</td></tr>
<tr class="separator:a0e9fee8c1e67fd12c9a986ff279e59f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93602eaaaf8226a1a8c7a18ad95be6f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a93602eaaaf8226a1a8c7a18ad95be6f5">AllocateNodeMirrorInfos</a> ()</td></tr>
<tr class="separator:a93602eaaaf8226a1a8c7a18ad95be6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d085abf8ace04bb0252fd63b64dddf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a9d085abf8ace04bb0252fd63b64dddf6">RemoveNodeMirrorInfos</a> ()</td></tr>
<tr class="separator:a9d085abf8ace04bb0252fd63b64dddf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2d2948bb9b1e88cad90812d0bf7369"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE <a class="el" href="struct_e_motion_f_x_1_1_actor_1_1_node_mirror_info.html">NodeMirrorInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a2a2d2948bb9b1e88cad90812d0bf7369">GetNodeMirrorInfo</a> (size_t nodeIndex)</td></tr>
<tr class="separator:a2a2d2948bb9b1e88cad90812d0bf7369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2239d17203a41dacc37ebf10dfff3db4"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE const <a class="el" href="struct_e_motion_f_x_1_1_actor_1_1_node_mirror_info.html">NodeMirrorInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a2239d17203a41dacc37ebf10dfff3db4">GetNodeMirrorInfo</a> (size_t nodeIndex) const </td></tr>
<tr class="separator:a2239d17203a41dacc37ebf10dfff3db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931d51a1e3ea221620133960ad86be60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a931d51a1e3ea221620133960ad86be60"></a>
MCORE_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetHasMirrorInfo</b> () const </td></tr>
<tr class="separator:a931d51a1e3ea221620133960ad86be60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab4b3af666fb956de003fbbf0734cc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#afab4b3af666fb956de003fbbf0734cc3">MatchNodeMotionSources</a> (const char *subStringA, const char *subStringB)</td></tr>
<tr class="separator:afab4b3af666fb956de003fbbf0734cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9769003ebbdc356b54b3e487d58dc23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#af9769003ebbdc356b54b3e487d58dc23">MapNodeMotionSource</a> (const char *sourceNodeName, const char *destNodeName)</td></tr>
<tr class="separator:af9769003ebbdc356b54b3e487d58dc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbd6b43e65481acce304feca9c6c4a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacbd6b43e65481acce304feca9c6c4a1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MapNodeMotionSource</b> (uint16 sourceNodeIndex, uint16 targetNodeIndex)</td></tr>
<tr class="separator:aacbd6b43e65481acce304feca9c6c4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8908beb973851e281877bb80e4839570"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a8908beb973851e281877bb80e4839570">FindBestMatchForNode</a> (const char *nodeName, const char *subStringA, const char *subStringB, bool firstPass=true) const </td></tr>
<tr class="separator:a8908beb973851e281877bb80e4839570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78248c3d72dc82db62e3daab240c4251"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78248c3d72dc82db62e3daab240c4251"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MatchNodeMotionSourcesGeometrical</b> ()</td></tr>
<tr class="separator:a78248c3d72dc82db62e3daab240c4251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba60de75be868124cec40b54b376632"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ba60de75be868124cec40b54b376632"></a>
uint16&#160;</td><td class="memItemRight" valign="bottom"><b>FindBestMirrorMatchForNode</b> (uint16 nodeIndex, <a class="el" href="class_e_motion_f_x_1_1_pose.html">Pose</a> &amp;pose) const </td></tr>
<tr class="separator:a1ba60de75be868124cec40b54b376632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f7cb283ae54c671a09443cdf6fa24e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a49f7cb283ae54c671a09443cdf6fa24e">SetDirtyFlag</a> (bool dirty)</td></tr>
<tr class="separator:a49f7cb283ae54c671a09443cdf6fa24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39e006fa6c825a9379bf730f166c2c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#af39e006fa6c825a9379bf730f166c2c5">GetDirtyFlag</a> () const </td></tr>
<tr class="separator:af39e006fa6c825a9379bf730f166c2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c4a9913aee4716b4ab910ac27412ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8c4a9913aee4716b4ab910ac27412ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetIsUsedForVisualization</b> (bool flag)</td></tr>
<tr class="separator:af8c4a9913aee4716b4ab910ac27412ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e500de8041d0b2c5083e17a882435b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9e500de8041d0b2c5083e17a882435b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetIsUsedForVisualization</b> () const </td></tr>
<tr class="separator:af9e500de8041d0b2c5083e17a882435b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8867ef9e5df153c01e96a431e01bf86e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a8867ef9e5df153c01e96a431e01bf86e">FindFirstActiveParentBone</a> (size_t skeletalLOD, size_t startNodeIndex) const </td></tr>
<tr class="separator:a8867ef9e5df153c01e96a431e01bf86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67e15da5a77e3ae660fa4478d0cbf50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#ab67e15da5a77e3ae660fa4478d0cbf50">MakeGeomLODsCompatibleWithSkeletalLODs</a> ()</td></tr>
<tr class="separator:ab67e15da5a77e3ae660fa4478d0cbf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663af10d3d82ef433697efda631ddeb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a663af10d3d82ef433697efda631ddeb2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReinitializeMeshDeformers</b> ()</td></tr>
<tr class="separator:a663af10d3d82ef433697efda631ddeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d72dc5111e5432e6f4d5ba9272e1e24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d72dc5111e5432e6f4d5ba9272e1e24"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PostCreateInit</b> (bool makeGeomLodsCompatibleWithSkeletalLODs=true, bool convertUnitType=true)</td></tr>
<tr class="separator:a7d72dc5111e5432e6f4d5ba9272e1e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ad049a6816dc8b41ab680949c57fd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45ad049a6816dc8b41ab680949c57fd0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AutoDetectMirrorAxes</b> ()</td></tr>
<tr class="separator:a45ad049a6816dc8b41ab680949c57fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70527e481e23f56454b11558b1edcf1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70527e481e23f56454b11558b1edcf1a"></a>
const AZStd::vector<br class="typebreak"/>
&lt; <a class="el" href="struct_e_motion_f_x_1_1_actor_1_1_node_mirror_info.html">NodeMirrorInfo</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetNodeMirrorInfos</b> () const </td></tr>
<tr class="separator:a70527e481e23f56454b11558b1edcf1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de38913e72de4df82e55c33aa2a4b41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6de38913e72de4df82e55c33aa2a4b41"></a>
AZStd::vector&lt; <a class="el" href="struct_e_motion_f_x_1_1_actor_1_1_node_mirror_info.html">NodeMirrorInfo</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetNodeMirrorInfos</b> ()</td></tr>
<tr class="separator:a6de38913e72de4df82e55c33aa2a4b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9498a4dd61f996e53ccf78b7ef063c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f9498a4dd61f996e53ccf78b7ef063c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetNodeMirrorInfos</b> (const AZStd::vector&lt; <a class="el" href="struct_e_motion_f_x_1_1_actor_1_1_node_mirror_info.html">NodeMirrorInfo</a> &gt; &amp;mirrorInfos)</td></tr>
<tr class="separator:a8f9498a4dd61f996e53ccf78b7ef063c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e90f3d549a73695ac1961d5d4bc935d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e90f3d549a73695ac1961d5d4bc935d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetHasMirrorAxesDetected</b> () const </td></tr>
<tr class="separator:a6e90f3d549a73695ac1961d5d4bc935d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5199f05492cfa3d67c729d6a54061c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f5199f05492cfa3d67c729d6a54061c"></a>
MCORE_INLINE const <br class="typebreak"/>
AZStd::vector&lt; Transform &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetInverseBindPoseTransforms</b> () const </td></tr>
<tr class="separator:a7f5199f05492cfa3d67c729d6a54061c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e31529ed3a5a9a35654c46e83a17267"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e31529ed3a5a9a35654c46e83a17267"></a>
MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_pose.html">Pose</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetBindPose</b> ()</td></tr>
<tr class="separator:a1e31529ed3a5a9a35654c46e83a17267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030e8ce94c3de3a18794266c5caf18a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a030e8ce94c3de3a18794266c5caf18a9"></a>
MCORE_INLINE const <a class="el" href="class_e_motion_f_x_1_1_pose.html">Pose</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetBindPose</b> () const </td></tr>
<tr class="separator:a030e8ce94c3de3a18794266c5caf18a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4df7051423d768843775170185dca61"><td class="memItemLeft" align="right" valign="top">MCORE_INLINE const Transform &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#ae4df7051423d768843775170185dca61">GetInverseBindPoseTransform</a> (size_t nodeIndex) const </td></tr>
<tr class="separator:ae4df7051423d768843775170185dca61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bebd82a9737ef51cc8ddc480ae52a2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bebd82a9737ef51cc8ddc480ae52a2b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReleaseTransformData</b> ()</td></tr>
<tr class="separator:a4bebd82a9737ef51cc8ddc480ae52a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7401975070b65dd65754da66b58b7405"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7401975070b65dd65754da66b58b7405"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ResizeTransformData</b> ()</td></tr>
<tr class="separator:a7401975070b65dd65754da66b58b7405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae302770f76985756dd54ec256b72ab0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae302770f76985756dd54ec256b72ab0d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CopyTransformsFrom</b> (const <a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> *other)</td></tr>
<tr class="separator:ae302770f76985756dd54ec256b72ab0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab088b488128ad4c8f1df694ebd0dfde8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab088b488128ad4c8f1df694ebd0dfde8"></a>
const AZ::Aabb &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetStaticAabb</b> () const </td></tr>
<tr class="separator:ab088b488128ad4c8f1df694ebd0dfde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111a774ed084ea678b53c93eb3833bfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a111a774ed084ea678b53c93eb3833bfd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetStaticAabb</b> (const AZ::Aabb &amp;aabb)</td></tr>
<tr class="separator:a111a774ed084ea678b53c93eb3833bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835875e67bac55b8db9d21521ab651d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a835875e67bac55b8db9d21521ab651d4">UpdateStaticAabb</a> ()</td></tr>
<tr class="separator:a835875e67bac55b8db9d21521ab651d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5acad4294eb8c3e0771c343818d42d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5acad4294eb8c3e0771c343818d42d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetThreadIndex</b> (uint32 index)</td></tr>
<tr class="separator:ac5acad4294eb8c3e0771c343818d42d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5fcb7fd06078adad06c16765bb85ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d5fcb7fd06078adad06c16765bb85ad"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><b>GetThreadIndex</b> () const </td></tr>
<tr class="separator:a1d5fcb7fd06078adad06c16765bb85ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1ae60899b02a820479168b9f9d1085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c1ae60899b02a820479168b9f9d1085"></a>
<a class="el" href="class_e_motion_f_x_1_1_mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetMesh</b> (size_t lodLevel, size_t nodeIndex) const </td></tr>
<tr class="separator:a8c1ae60899b02a820479168b9f9d1085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400d14fd51c6adecd33d04452eb43b4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a400d14fd51c6adecd33d04452eb43b4a"></a>
<a class="el" href="class_e_motion_f_x_1_1_mesh_deformer_stack.html">MeshDeformerStack</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetMeshDeformerStack</b> (size_t lodLevel, size_t nodeIndex) const </td></tr>
<tr class="separator:a400d14fd51c6adecd33d04452eb43b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658bfdca400a0c36bae2b9dde0848559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a658bfdca400a0c36bae2b9dde0848559">FindMostInfluencedMeshPoints</a> (const <a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *node, AZStd::vector&lt; AZ::Vector3 &gt; &amp;outPoints) const </td></tr>
<tr class="separator:a658bfdca400a0c36bae2b9dde0848559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79599c6131d2ac8da322a94a19da53e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac79599c6131d2ac8da322a94a19da53e"></a>
MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_skeleton.html">Skeleton</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetSkeleton</b> () const </td></tr>
<tr class="separator:ac79599c6131d2ac8da322a94a19da53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e8ec425ead005587afa322cdba8a9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58e8ec425ead005587afa322cdba8a9a"></a>
MCORE_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetNumNodes</b> () const </td></tr>
<tr class="separator:a58e8ec425ead005587afa322cdba8a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e4ac2c13266b1afdc4e9f956ab1cea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13e4ac2c13266b1afdc4e9f956ab1cea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMesh</b> (size_t lodLevel, size_t nodeIndex, <a class="el" href="class_e_motion_f_x_1_1_mesh.html">Mesh</a> *mesh)</td></tr>
<tr class="separator:a13e4ac2c13266b1afdc4e9f956ab1cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f86c6aa722ce9b21598906836cf044"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3f86c6aa722ce9b21598906836cf044"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMeshDeformerStack</b> (size_t lodLevel, size_t nodeIndex, <a class="el" href="class_e_motion_f_x_1_1_mesh_deformer_stack.html">MeshDeformerStack</a> *stack)</td></tr>
<tr class="separator:ac3f86c6aa722ce9b21598906836cf044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5bf7bc112a5106e2bc4d6097a8696d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed5bf7bc112a5106e2bc4d6097a8696d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>CheckIfHasMorphDeformer</b> (size_t lodLevel, size_t nodeIndex) const </td></tr>
<tr class="separator:aed5bf7bc112a5106e2bc4d6097a8696d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfa5ca25f170fb0144acaed6f909aae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5dfa5ca25f170fb0144acaed6f909aae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>CheckIfHasSkinningDeformer</b> (size_t lodLevel, size_t nodeIndex) const </td></tr>
<tr class="separator:a5dfa5ca25f170fb0144acaed6f909aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19fe040db1d966fbc43283701e0abf6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab19fe040db1d966fbc43283701e0abf6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveNodeMeshForLOD</b> (size_t lodLevel, size_t nodeIndex, bool destroyMesh=true)</td></tr>
<tr class="separator:ab19fe040db1d966fbc43283701e0abf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d69d8d1e12a5d25431d319d965213d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8d69d8d1e12a5d25431d319d965213d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetNumNodes</b> (size_t numNodes)</td></tr>
<tr class="separator:ae8d69d8d1e12a5d25431d319d965213d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60cb326483c7a7cb08fbc5e4defd9e89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60cb326483c7a7cb08fbc5e4defd9e89"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetUnitType</b> (MCore::Distance::EUnitType unitType)</td></tr>
<tr class="separator:a60cb326483c7a7cb08fbc5e4defd9e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738512a6ad2baa60eb9b8da315dc3129"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a738512a6ad2baa60eb9b8da315dc3129"></a>
MCore::Distance::EUnitType&#160;</td><td class="memItemRight" valign="bottom"><b>GetUnitType</b> () const </td></tr>
<tr class="separator:a738512a6ad2baa60eb9b8da315dc3129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6040c8ad8c33e2d0bfa5fa2fff1fafd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6040c8ad8c33e2d0bfa5fa2fff1fafd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFileUnitType</b> (MCore::Distance::EUnitType unitType)</td></tr>
<tr class="separator:af6040c8ad8c33e2d0bfa5fa2fff1fafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56a951de6a7fa4f2bd49365d40c5fe8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab56a951de6a7fa4f2bd49365d40c5fe8"></a>
MCore::Distance::EUnitType&#160;</td><td class="memItemRight" valign="bottom"><b>GetFileUnitType</b> () const </td></tr>
<tr class="separator:ab56a951de6a7fa4f2bd49365d40c5fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8217dd608c775bb26372aa25af03dbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8217dd608c775bb26372aa25af03dbb"></a>
EAxis&#160;</td><td class="memItemRight" valign="bottom"><b>FindBestMatchingMotionExtractionAxis</b> () const </td></tr>
<tr class="separator:ab8217dd608c775bb26372aa25af03dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00ec79f7eb1ee29c9192a42210c1c76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af00ec79f7eb1ee29c9192a42210c1c76"></a>
MCORE_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetRetargetRootNodeIndex</b> () const </td></tr>
<tr class="separator:af00ec79f7eb1ee29c9192a42210c1c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8265e8a7440d6ec2a4cab74d6e150a2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8265e8a7440d6ec2a4cab74d6e150a2d"></a>
MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetRetargetRootNode</b> () const </td></tr>
<tr class="separator:a8265e8a7440d6ec2a4cab74d6e150a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1adf412b00e1a5eb4fde9b5aa22765"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c1adf412b00e1a5eb4fde9b5aa22765"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetRetargetRootNodeIndex</b> (size_t nodeIndex)</td></tr>
<tr class="separator:a5c1adf412b00e1a5eb4fde9b5aa22765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7994c0a74f4e3bfb5ff1f3b028c1f598"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7994c0a74f4e3bfb5ff1f3b028c1f598"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetRetargetRootNode</b> (<a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *node)</td></tr>
<tr class="separator:a7994c0a74f4e3bfb5ff1f3b028c1f598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7706bd9a17265c18378847e8889e5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b7706bd9a17265c18378847e8889e5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AutoSetupSkeletalLODsBasedOnSkinningData</b> (const AZStd::vector&lt; AZStd::string &gt; &amp;alwaysIncludeJoints)</td></tr>
<tr class="separator:a7b7706bd9a17265c18378847e8889e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dad9016dd98a470d09c0833e54f7c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72dad9016dd98a470d09c0833e54f7c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintSkeletonLODs</b> ()</td></tr>
<tr class="separator:a72dad9016dd98a470d09c0833e54f7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d64eac6f2acce262a6efc97966e50c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3d64eac6f2acce262a6efc97966e50c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GenerateOptimizedSkeleton</b> ()</td></tr>
<tr class="separator:aa3d64eac6f2acce262a6efc97966e50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec54351408296c6756fe0ecf5eee6c7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec54351408296c6756fe0ecf5eee6c7f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetOptimizeSkeleton</b> (bool optimizeSkeleton)</td></tr>
<tr class="separator:aec54351408296c6756fe0ecf5eee6c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a37fc89b84142752d57501af88bd721"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a37fc89b84142752d57501af88bd721"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetOptimizeSkeleton</b> () const </td></tr>
<tr class="separator:a0a37fc89b84142752d57501af88bd721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fc2666e85981cb31c880bf27e91d1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61fc2666e85981cb31c880bf27e91d1f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMeshAssetId</b> (const AZ::Data::AssetId &amp;assetId)</td></tr>
<tr class="separator:a61fc2666e85981cb31c880bf27e91d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0405bd8b77d32ebf50cad14f15aea4a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0405bd8b77d32ebf50cad14f15aea4a0"></a>
AZ::Data::AssetId&#160;</td><td class="memItemRight" valign="bottom"><b>GetMeshAssetId</b> () const </td></tr>
<tr class="separator:a0405bd8b77d32ebf50cad14f15aea4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e6ab1968f3a80dec706a3f624c5bb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01e6ab1968f3a80dec706a3f624c5bb4"></a>
const AZ::Data::Asset<br class="typebreak"/>
&lt; AZ::RPI::ModelAsset &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetMeshAsset</b> () const </td></tr>
<tr class="separator:a01e6ab1968f3a80dec706a3f624c5bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e6b823ae486a98a3183daacf84c756"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19e6b823ae486a98a3183daacf84c756"></a>
const AZ::Data::Asset<br class="typebreak"/>
&lt; AZ::RPI::SkinMetaAsset &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetSkinMetaAsset</b> () const </td></tr>
<tr class="separator:a19e6b823ae486a98a3183daacf84c756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4938687dec172390da1577e1973c94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b4938687dec172390da1577e1973c94"></a>
const AZ::Data::Asset<br class="typebreak"/>
&lt; AZ::RPI::MorphTargetMetaAsset &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetMorphTargetMetaAsset</b> () const </td></tr>
<tr class="separator:a2b4938687dec172390da1577e1973c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4001e775778f225c1886e90cc6cf29b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4001e775778f225c1886e90cc6cf29b2"></a>
const AZStd::unordered_map<br class="typebreak"/>
&lt; AZ::u16, AZ::u16 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetSkinToSkeletonIndexMap</b> () const </td></tr>
<tr class="separator:a4001e775778f225c1886e90cc6cf29b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a80e7a715b48a49fd70b52dfd48e93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a26a80e7a715b48a49fd70b52dfd48e93">IsReady</a> () const </td></tr>
<tr class="separator:a26a80e7a715b48a49fd70b52dfd48e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a564e2dd50ada911bf8a6d662f0fe67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_e_motion_f_x_1_1_actor.html#a4a564e2dd50ada911bf8a6d662f0fe67">Finalize</a> (LoadRequirement loadReq=LoadRequirement::AllowAsyncLoad)</td></tr>
<tr class="separator:a4a564e2dd50ada911bf8a6d662f0fe67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The actor is the representation of a completely animatable object, like a human character or an animal. It represents a (read only) shared data object, from which <a class="el" href="class_e_motion_f_x_1_1_actor_instance.html">ActorInstance</a> objects can be created. The actor instance objects are used as characters in the game and can all be controlled individually, while they still share the same data from the <a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> class. The <a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> contains information about the hierarchy/structure of the characters. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5fb8b2d7d478a76ef9d8cfbc85aca0e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EMotionFX::Actor::Actor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the actor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a28e591f7db9da96067aa4f3b11901bcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::AddDependency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_e_motion_f_x_1_1_actor_1_1_dependency.html">Dependency</a> &amp;&#160;</td>
          <td class="paramname"><em>dependency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a dependency to the actor. Dependencies are used to identify on what other actor objects this actor relies. This can be because this actor uses meshes or transforms that are stored inside the other actor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dependency</td><td>The dependency to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46bce69a29c8ccc433371ad7537d349c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::AddLODLevel </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copyFromLastLODLevel</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a LOD level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copyFromLastLevelLOD</td><td>True in case the new LOD level should contain the same meshes as the last LOD level. In case of false the meshes and everything won't be copied over. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ef54597acb30b84e6a29c124aa67431"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::AddNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a node to this actor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47bcc14d8448b0d2aa272a79319cf229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a>* EMotionFX::Actor::AddNode </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>parentIndex</em> = <code>InvalidIndex</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a node to this actor. </p>

</div>
</div>
<a class="anchor" id="acb271f489fb14201657f29a58971a56a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::AddNodeGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_node_group.html">NodeGroup</a> *&#160;</td>
          <td class="paramname"><em>newGroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a node group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newGroup</td><td>The new node group to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93602eaaaf8226a1a8c7a18ad95be6f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::AllocateNodeMirrorInfos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate data for the node motion mirror info. This resizes the array of node motion infos and initializes it on default values. </p>

</div>
</div>
<a class="anchor" id="ae96ec525b6c474691b5cfc189065d646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::AutoSetMotionExtractionNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Automatically find the best motion extraction node, using FindBestMotionExtractionNode and set it as current motion extraction node. </p>

</div>
</div>
<a class="anchor" id="acadea88b6150d5b46efd3e7f7adb7e95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::CalcDeformableMeshTotals </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>outNumVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>outNumIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the total number of vertices and indices of all DEFORMABLE node meshes for the given LOD. With deformable we mean meshes that are being modified by mesh deformers, such as skinning or morphing deformers. The number of faces can be calculated by dividing the resulting number of indices by 3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodLevel</td><td>The LOD level, where 0 is the highest detail LOD level. This value must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_actor.html#a78755caf37b41d6072466f3502923698">GetNumLODLevels()</a>-1]. </td></tr>
    <tr><td class="paramname">outNumVertices</td><td>The integer to write the number of vertices in. </td></tr>
    <tr><td class="paramname">outNumIndices</td><td>The integer to write the number of indices in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb3263fba7bc8ca94033903ecfe11f18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Actor::CalcMaxNumInfluences </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodLevel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the maximum number of bone influences. This is calculated by for each vertex checking the number of bone influences, and take the maximum of that amount. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodLevel</td><td>The LOD level, where 0 is the highest detail LOD level. This value must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_actor.html#a78755caf37b41d6072466f3502923698">GetNumLODLevels()</a>-1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of influences. This will be 0 for non-softskinned objects. </dd></dl>

</div>
</div>
<a class="anchor" id="a25584365b9cdc30a3098260038873e96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Actor::CalcMaxNumInfluences </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZStd::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>outVertexCounts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the maximum number of bone influences. Also provides an array containing the number of vertices for each number of influences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodLevel</td><td>The LOD level, where 0 is the highest detail LOD level. This value must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_actor.html#a78755caf37b41d6072466f3502923698">GetNumLODLevels()</a>-1]. </td></tr>
    <tr><td class="paramname">vertexCounts</td><td>An output array, which will contain for each number of influences, the number of vertices with this number of influences. In other words, the first element of the array will contain the number of vertices, which have 0 influences. The next element in the array will contain the number of vertices, which are influenced by exactly 1 bone, etc. </td></tr>
    <tr><td class="paramname">lodLevel</td><td>The detail level to calculate the results for. A value of 0 is the highest detail. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of vertex/bone influences. This will be 0 for rigid, non-skinned objects. </dd></dl>

</div>
</div>
<a class="anchor" id="a1692299b03dccff85ec31929d4455b2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::CalcMeshTotals </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>outNumPolygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>outNumVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>outNumIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the total number of vertices and indices of all node meshes for the given LOD. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodLevel</td><td>The LOD level, where 0 is the highest detail LOD level. This value must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_actor.html#a78755caf37b41d6072466f3502923698">GetNumLODLevels()</a>-1]. </td></tr>
    <tr><td class="paramname">outNumPolygons</td><td>The integer to write the number of polygons in. </td></tr>
    <tr><td class="paramname">outNumVertices</td><td>The integer to write the number of vertices in. </td></tr>
    <tr><td class="paramname">outNumIndices</td><td>The integer to write the number of indices in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54ededab5573db9d05502848f5451f29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::CalcStaticMeshTotals </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>outNumVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>outNumIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the total number of vertices and indices of all STATIC node meshes for the given LOD. With static we mean the meshes that are NOT effected by any deformers, so which are completely rigid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodLevel</td><td>The LOD level, where 0 is the highest detail LOD level. This value must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_actor.html#a78755caf37b41d6072466f3502923698">GetNumLODLevels()</a>-1]. </td></tr>
    <tr><td class="paramname">outNumVertices</td><td>The integer to write the number of vertices in. </td></tr>
    <tr><td class="paramname">outNumIndices</td><td>The integer to write the number of indices in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a335ada7775f4c68299e88d22db7bb4b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::Actor::CheckIfHasMeshes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodLevel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if this actor contains any nodes that have meshes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodLevel</td><td>The LOD level to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when this actor contains nodes that have meshes in the given LOD, otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a02919d23f6aad50d8bf5050372e30a57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::Actor::CheckIfHasSkinnedMeshes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodLevel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if we have skinned meshes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodLevel</td><td>The LOD level to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when skinned meshes are present in the specified LOD level, otherwise false is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cf0773caab0f6a6533cbe15346cff7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AZStd::unique_ptr&lt;<a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a>&gt; EMotionFX::Actor::Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clones this actor. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the duplicated clone. </dd></dl>

</div>
</div>
<a class="anchor" id="a550e115f96a167524134a7d773386892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::CopyLODLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> *&#160;</td>
          <td class="paramname"><em>copyActor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>copyLODLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>replaceLODLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copySkeletalLODFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy data from a given LOD level to another one. This will copy the skeletal LOD flag for the nodes, copy over the meshes and their deformer stacks, the materials as well as the whole morph setup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copyActor</td><td>The actor to copy the LOD level from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copyLODLevel</td><td>The LOD level from which we get the data from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replaceLODLevel</td><td>The LOD level to which we copy the data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copySkeletalLODFlags</td><td>Copy over the skeletal LOD flags in case of true, skip them in case of false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delLODActorFromMem</td><td>When set to true, the method will automatically delete the given copyActor from memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4113d10df23926337f1c0b5f0338bd8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::DeleteAllNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all nodes from memory. </p>

</div>
</div>
<a class="anchor" id="af2c3c6497a412e35bed18330cbd8ab33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::ExtractBoneList </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZStd::vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>outBoneList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract a list with nodes that represent bones. Not all nodes inside an actor have to be bones. With bones we mean nodes that appear inside the skinning information of the meshes. So nodes that have vertices linked to them. Extracting this information is not fast, so shouldn't be done inside a loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodLevel</td><td>The LOD level, which must be in range of 0..<a class="el" href="class_e_motion_f_x_1_1_actor.html#a78755caf37b41d6072466f3502923698">GetNumLODLevels()</a>. </td></tr>
    <tr><td class="paramname">outBoneList</td><td>The array of indices to nodes that will be filled with the nodes that are bones. When the outBoneList array already contains items, the array will first be cleared, so all existing contents will be lost. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a564e2dd50ada911bf8a6d662f0fe67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::Finalize </td>
          <td>(</td>
          <td class="paramtype">LoadRequirement&#160;</td>
          <td class="paramname"><em>loadReq</em> = <code>LoadRequirement::AllowAsyncLoad</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finalize the actor with preload assets (mesh, skinmeta and morph target assets). LoadRequirement - We won't need a blocking load if the actor is part of the actor asset, as that will trigger the preload assets to load and get ready before finalize has been reached. However, if we are calling this on an actor that bypassed the asset system (e.g loading the actor directly from disk), it will require a blocking load. This option is now being used because emfx editor does not fully integrate with the asset system. </p>

</div>
</div>
<a class="anchor" id="a8908beb973851e281877bb80e4839570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 EMotionFX::Actor::FindBestMatchForNode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nodeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>subStringA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>subStringB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>firstPass</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the best match for a given node, using two substrings. For example, if you use the node name "Right Leg" and you use as subStringA "Right" and as subStringB "Left", then it will result most likely (asssuming that node exists) in the node with the name "Left Leg". You can use this to guess the most most likely match for a given node, when using motion mirroring. Please note that artists can all setup this already. If you want to do it manually you might also want to use the MatchNodeMotionSources function instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeName</td><td>The name of the node to find the counter-mirror-node for. </td></tr>
    <tr><td class="paramname">subStringA</td><td>The first substring, for example "Left". </td></tr>
    <tr><td class="paramname">subStringB</td><td>The second substring, for example "Right". </td></tr>
    <tr><td class="paramname">firstPass</td><td>Basically just set this to true always, which is also its default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node index for the node that matches best, or MCORE_INVALIDINDEX16 (please note the 16 and NOT 32) when no good match has been found. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0e8773c1003ffd14ad7a72422752979"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a>* EMotionFX::Actor::FindBestMotionExtractionNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to find the best motion extraction node automatically. It picks the node with the most number of child nodes down the hierarchy below that node. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the best suitable motion extraction node, or nullptr when no node could be found. </dd></dl>

</div>
</div>
<a class="anchor" id="a8867ef9e5df153c01e96a431e01bf86e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Actor::FindFirstActiveParentBone </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>skeletalLOD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startNodeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively find the parent bone that is enabled in a given LOD, starting from a given node. For example if you have a finger bone, while the finger bones are disabled in the skeletal LOD, this function will return the index to the hand bone. This is because the hand bone will most likely be the first active bone in that LOD, when moving up the hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skeletalLOD</td><td>The skeletal LOD level to search in. </td></tr>
    <tr><td class="paramname">startNodeIndex</td><td>The node to start looking at, for example the node index of the finger bone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the first active node, when moving up the hierarchy towards the root node. Returns MCORE_INVALIDINDEX32 when not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a658bfdca400a0c36bae2b9dde0848559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::FindMostInfluencedMeshPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZStd::vector&lt; AZ::Vector3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the mesh points for which the specified node is the node with the highest influence. This is a pretty expensive function which is only intended for use in the editor. The resulting points will be given in model space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>The node for which the most heavily influenced mesh points are sought. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outPoints</td><td>Container which will be filled with the points for which the node is the heaviest influence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abef5cd974984c057171b81edbfbb412a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_node_group.html">NodeGroup</a>* EMotionFX::Actor::FindNodeGroupByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>groupName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a node group by its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupName</td><td>The name of the group to search for. This is case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node group, or nullptr when it cannot be found. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7da4402ad74bbd6370090dc695f1acf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_node_group.html">NodeGroup</a>* EMotionFX::Actor::FindNodeGroupByNameNoCase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>groupName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a node group by its name, but without case sensitivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupName</td><td>The name of the group to search for. This is NOT case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node group, or nullptr when it cannot be found. </dd></dl>

</div>
</div>
<a class="anchor" id="a861f3c434785dbdbbb68e17ac1ad55b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Actor::FindNodeGroupIndexByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>groupName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a node group index by its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupName</td><td>The name of the group to search for. This is case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The group number, or MCORE_INVALIDINDEX32 when it cannot be found. </dd></dl>

</div>
</div>
<a class="anchor" id="a6482983dae6b9339730b76466e4266d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Actor::FindNodeGroupIndexByNameNoCase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>groupName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a group index by its name, on a non-case sensitive way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupName</td><td>The name of the group to search for. This is NOT case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The group number, or MCORE_INVALIDINDEX32 when it cannot be found. </dd></dl>

</div>
</div>
<a class="anchor" id="a759ffbd12ae4344405707ad432ffc4ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::GenerateUpdatePathToRoot </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>endNodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZStd::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>outPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate an update path from a given node towards the root. The first element in the array will be the end node index, the next node will be its parent node, etc. So the last node will be the root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endNodeIndex</td><td>The node index to generate the path to. </td></tr>
    <tr><td class="paramname">outPath</td><td>the array that will contain the path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cc1f7d0fcf63ea3f7d6319b10d6ee1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* EMotionFX::Actor::GetCustomData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the custom data you stored. Custom data can for example link a game or engine object with this EMotion FX actor object. An example is when EMotion FX triggers a motion event. You know the actor that triggered the event, but you don't know directly what game or engine object is linked to this actor. By using the custom data methods GetCustomData and SetCustomData you can set a pointer to your game or engine object in each actor. The pointer that you specify will not be deleted when the actor object is being destructed. </p>
<dl class="section return"><dt>Returns</dt><dd>A void pointer to the custom data you have specified. </dd></dl>

</div>
</div>
<a class="anchor" id="aefe144f686b22570ffa5e883a09cf5f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE <a class="el" href="struct_e_motion_f_x_1_1_actor_1_1_dependency.html">Dependency</a>* EMotionFX::Actor::GetDependency </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a given dependency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>The dependency number, which must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_actor.html#a66f1ddc402f4c1fb48c6dfd8dcf64fc9">GetNumDependencies()</a>-1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the dependency. </dd></dl>

</div>
</div>
<a class="anchor" id="af39e006fa6c825a9379bf730f166c2c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::Actor::GetDirtyFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the dirty flag which indicates whether the user has made changes to the actor or not. This indicator is set to true when the user changed something like adding a new node group. When the user saves the actor, the indicator is usually set to false. </p>
<dl class="section return"><dt>Returns</dt><dd>The dirty flag. </dd></dl>

</div>
</div>
<a class="anchor" id="af9246d6de1c99852307d274affa54bed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* EMotionFX::Actor::GetFileName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the filename of the actor. </p>
<dl class="section return"><dt>Returns</dt><dd>The filename of the actor. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b3ce142e07d42d28e4bad187d00f808"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AZStd::string&amp; EMotionFX::Actor::GetFileNameString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the filename of the actor, as a AZStd::string object. </p>
<dl class="section return"><dt>Returns</dt><dd>The filename of the actor. </dd></dl>

</div>
</div>
<a class="anchor" id="afaea7fd55dd2d6b15689d71e2658f798"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE uint32 EMotionFX::Actor::GetID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the unique identification number for the actor. </p>
<dl class="section return"><dt>Returns</dt><dd>The unique identification number. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4df7051423d768843775170185dca61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE const Transform&amp; EMotionFX::Actor::GetInverseBindPoseTransform </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nodeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the inverse bind pose (in world space) transform of a given joint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jointIndex</td><td>The joint number, which must be in range of [0..GetNumNodes()-1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse of the bind pose transform. </dd></dl>

</div>
</div>
<a class="anchor" id="abd5721f168b625e44aaf881fa4d58ac6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE <a class="el" href="class_e_motion_f_x_1_1_morph_setup.html">MorphSetup</a>* EMotionFX::Actor::GetMorphSetup </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>geomLODLevel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the morph setup at a given geometry LOD level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geomLODLevel</td><td>The geometry LOD level, which must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_actor.html#a78755caf37b41d6072466f3502923698">GetNumLODLevels()</a>]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer object to the morph setup. Use the MCore::Pointer&lt;MorphSetup&gt;::GetPointer() to get the actual pointer. That GetPointer() method will return nullptr when there is no morph setup for the given LOD level. </dd></dl>

</div>
</div>
<a class="anchor" id="ac17d8f0ba205a6da060c5c7269630ffd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a>* EMotionFX::Actor::GetMotionExtractionNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the motion extraction node. </p>
<dl class="section return"><dt>Returns</dt><dd>The motion extraction node, or nullptr when it has not been set. </dd></dl>

</div>
</div>
<a class="anchor" id="adefbe87c6442ae4f7c7e8fb4bdc927dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE size_t EMotionFX::Actor::GetMotionExtractionNodeIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the motion extraction node index. </p>
<dl class="section return"><dt>Returns</dt><dd>The motion extraction node index, or MCORE_INVALIDINDEX32 when it has not been set. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d65bf17912268f2eda0f473f80b4361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* EMotionFX::Actor::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of the actor. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the actor. </dd></dl>

</div>
</div>
<a class="anchor" id="af4b19aefff6485de86393ae1b7734d86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const AZStd::string&amp; EMotionFX::Actor::GetNameString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of the actor as a Core string object. </p>
<dl class="section return"><dt>Returns</dt><dd>The string containing the name of the actor. </dd></dl>

</div>
</div>
<a class="anchor" id="aba617c67fec91709e2aecdfe7d997a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_e_motion_f_x_1_1_node_group.html">NodeGroup</a>* EMotionFX::Actor::GetNodeGroup </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to a given node group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The node group index, which must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_actor.html#ad6bfc192661677bbc5e4e366810ac7ee">GetNumNodeGroups()</a>-1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a2d2948bb9b1e88cad90812d0bf7369"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE <a class="el" href="struct_e_motion_f_x_1_1_actor_1_1_node_mirror_info.html">NodeMirrorInfo</a>&amp; EMotionFX::Actor::GetNodeMirrorInfo </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nodeIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the mirror info for a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeIndex</td><td>The node index to get the info for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mirror info. </dd></dl>

</div>
</div>
<a class="anchor" id="a2239d17203a41dacc37ebf10dfff3db4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE const <a class="el" href="struct_e_motion_f_x_1_1_actor_1_1_node_mirror_info.html">NodeMirrorInfo</a>&amp; EMotionFX::Actor::GetNodeMirrorInfo </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nodeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the mirror info for a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeIndex</td><td>The node index to get the info for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mirror info. </dd></dl>

</div>
</div>
<a class="anchor" id="a66f1ddc402f4c1fb48c6dfd8dcf64fc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE size_t EMotionFX::Actor::GetNumDependencies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of dependencies. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of dependencies that this actor has on other actors. </dd></dl>

</div>
</div>
<a class="anchor" id="a78755caf37b41d6072466f3502923698"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Actor::GetNumLODLevels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of LOD levels inside this actor. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of LOD levels. This value is at least 1, since the full detail LOD is always there. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6bfc192661677bbc5e4e366810ac7ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EMotionFX::Actor::GetNumNodeGroups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of node groups inside this actor object. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of node groups. </dd></dl>

</div>
</div>
<a class="anchor" id="a19cb2fbed44c360f0913620673836e15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::InsertLODLevel </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>insertAt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert LOD level at the given position. This function will not copy any meshes, deformer, morph targets or materials but just insert an empty LOD level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">insertAt</td><td>The position to insert the new LOD level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26a80e7a715b48a49fd70b52dfd48e93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::Actor::IsReady </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is the actor fully ready? </p>
<dl class="section return"><dt>Returns</dt><dd>True in case the actor as well as its dependent files (e.g. mesh, skin, morph targets) are fully loaded and initialized. </dd></dl>

</div>
</div>
<a class="anchor" id="ab67e15da5a77e3ae660fa4478d0cbf50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::MakeGeomLODsCompatibleWithSkeletalLODs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the geometry LOD levels compatible with the skinning LOD levels. This means that it modifies the skinning information so that disabled bones are not used by the meshes anymore. Instead, the skinning influences are remapped to the first enabled parent bone. So if you disable all finger bones in a given LOD, it will adjust the skinning influences so that the vertices of the fingers are linked to the hand bone instead. </p>

</div>
</div>
<a class="anchor" id="af9769003ebbdc356b54b3e487d58dc23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EMotionFX::Actor::MapNodeMotionSource </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sourceNodeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>destNodeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map two nodes to eachother for motion mirroring. This could be used to tell to play the motion for the right arm on the left arm. The parameters you would give would be like: "Left Arm" and "Right Arm" in that case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceNodeName</td><td>The name of the first node, for example "Left Hand". </td></tr>
    <tr><td class="paramname">destNodeName</td><td>The name of the second node, for example "Right Hand". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true when the mapping was successful, or false when one of the nodes cannot be found. </dd></dl>

</div>
</div>
<a class="anchor" id="afab4b3af666fb956de003fbbf0734cc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::MatchNodeMotionSources </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>subStringA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>subStringB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Match and map the motion sources of given nodes, based on two substrings. This is used for motion mirroring, where we want to play the motion of the left arm on the right arm for example. If you have nodes named like "Left Leg", "Left Arm" "My Left Foot" and "My Right Foot", "Right Leg" and "Right Arm", then you can use the following substrings as parameters to match everything automatically: subStringA="Left" and subStringB="Right". Nodes that have no mirrored match (for example the spine bones) will mirror their own transforms when mirroring is enabled. It doesn't matter if you put the "left" or "right" substring inside subStringA or subStringB. The order of them doesn't matter. Also please note that artists can already setup all this, so your model is probably already prepared for mirroring once loaded if you are planning to use motion mirroring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subStringA</td><td>The first substring, which could be something like "Left" or "Bip01 " or " L ". </td></tr>
    <tr><td class="paramname">subStringB</td><td>The second substring, which could be something like "Right" or "Bip01 R" or " R ". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9214b2db7be5e22104d8a4ec9244d9ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::RecursiveAddDependencies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a> *&#160;</td>
          <td class="paramname"><em>actor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively add dependencies that this actor has on other actors. This adds the dependencies of the actors on which we currently have dependencies, and that recursively. So after executing this, the current actor contains all dependencies of all the actors it is dependent on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actor</td><td>The actor to create the dependencies for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d5095d71a7af3877dd6bf9055f12049"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::RemoveAllMorphSetups </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteMeshDeformers</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all morph setups. Morph setups contain all morph targtets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deleteMeshDeformers</td><td>When set to true (default), mesh deformers, such as the morphing deformer, will be deleted from all nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e9fee8c1e67fd12c9a986ff279e59f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::RemoveAllNodeGroups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all node groups from this actor. This also deletes the groups from memory. </p>

</div>
</div>
<a class="anchor" id="a31b34ebf73d08c5db52429a04a9927f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::RemoveAllNodeMeshes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all meshes from all nodes inside this actor. This means all memory will be released and pointers to the meshes will not be valid anymore. Also all mesh deformer stacks will be removed. </p>

</div>
</div>
<a class="anchor" id="a7b8e84626f1e65650e5ac040b367a5d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::RemoveNode </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delMem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>The node to remove. </td></tr>
    <tr><td class="paramname">delMem</td><td>If true the allocated memory of the node will be deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f2be4f32aef78414113bbff6461d648"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::RemoveNodeGroup </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delFromMem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a given node group by its index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The node group number to remove. This value must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_actor.html#ad6bfc192661677bbc5e4e366810ac7ee">GetNumNodeGroups()</a>-1]. </td></tr>
    <tr><td class="paramname">delFromMem</td><td>Set to true (default) when you wish to also delete the specified group from memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28d936106ca228b7d47120975b688b60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::RemoveNodeGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_node_group.html">NodeGroup</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delFromMem</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a given node group by its pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>The node group to remove. Please keep in mind that this group should really be part of this actor. </td></tr>
    <tr><td class="paramname">delFromMem</td><td>Set to true (default) when you wish to also delete the specified group from memory. Even if this group is not part of this actor and delFromMem is set to true, the group will be deleted from memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d085abf8ace04bb0252fd63b64dddf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::RemoveNodeMirrorInfos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove memory for the motion node source array. If the motion node source array has not been allocated before it will do nothing at all. </p>

</div>
</div>
<a class="anchor" id="ac62f8cd6a46f5cb87fb2d8a59c6cf20d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::Scale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleFactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale all transform and mesh positional data. This is a very slow operation and is used to convert between different unit systems (cm, meters, etc). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleFactor</td><td>The scale factor to scale the current data by. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ab4b124983080c05a52734f21f9bbc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::ScaleToUnitType </td>
          <td>(</td>
          <td class="paramtype">MCore::Distance::EUnitType&#160;</td>
          <td class="paramname"><em>targetUnitType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale to a given unit type. This method does nothing if the actor is already in this unit type. You can check what the current unit type is with the GetUnitType() method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetUnitType</td><td>The unit type to scale into (meters, centimeters, etc). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a476f86af2bcbe125ec8109ba60d6e8f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::SetCustomData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dataPointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the custom data you stored. Custom data can for example link a game or engine object with this EMotion FX actor object. An example is when EMotion FX triggers a motion event. You know the actor that triggered the event, but you don't know directly what game or engine object is linked to this actor. By using the custom data methods GetCustomData and SetCustomData you can set a pointer to your game or engine object in each actor. The pointer that you specify will not be deleted when the actor object is being destructed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataPointer</td><td>A void pointer to the custom data, which could for example be your engine or game object that is linked to this actor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49f7cb283ae54c671a09443cdf6fa24e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::SetDirtyFlag </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dirty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the dirty flag which indicates whether the user has made changes to the actor or not. This indicator is set to true when the user changed something like adding a new node group. When the user saves the actor, the indicator is usually set to false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirty</td><td>The dirty flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4870d72ffe5c58dfb56e3e036f3ae037"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::SetFileName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the filename of the actor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The filename of the actor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb11060aad48e044c177af8242713b88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCORE_INLINE void EMotionFX::Actor::SetID </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the unique identification number for the actor instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The unique identification number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae68bb7957c830caf0bf9c80a3d7a91a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::SetMorphSetup </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lodLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_morph_setup.html">MorphSetup</a> *&#160;</td>
          <td class="paramname"><em>setup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the morph setup for a given geometry LOD level. It is possible to set the setup for a given LOD level to nullptr. If the setup is nullptr, no morphing is being processed for the given LOD. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lodLevel</td><td>The LOD level, which must be in range of [0..<a class="el" href="class_e_motion_f_x_1_1_actor.html#a78755caf37b41d6072466f3502923698">GetNumLODLevels()</a>-1]. </td></tr>
    <tr><td class="paramname">setup</td><td>The morph setup for this LOD. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1883f2bc2f474c6b9f48a1d093d43dcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::SetMotionExtractionNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_motion_f_x_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the motion extraction node. This is the node from which we filter the motion. Most likely the hips node. The filtered motion of this node is applied to the actor instance. You can set the node to nullptr in case you want to disable motion extraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The motion extraction node, or nullptr to disable it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5cd5e5de79099d727c342d2425e1228"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::SetMotionExtractionNodeIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nodeIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the motion extraction node index. This is the node from which we filter the motion. Most likely the hips node. The filtered motion of this node is applied to the actor instance. You can set the node to MCORE_INVALIDINDEX32 in case you want to disable motion extraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeIndex</td><td>The motion extraction node, or MCORE_INVALIDINDEX32 to disable it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2b4c0870a5f0b08188552b9309a1fe0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::SetName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the name of the actor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the actor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2ccaeec356267a8d253de798847310b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::SetNumLODLevels </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numLODs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>adjustMorphSetup</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the number of LOD levels. This will be called by the importer. Do not use manually. </p>

</div>
</div>
<a class="anchor" id="a835875e67bac55b8db9d21521ab651d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::UpdateStaticAabb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the static aabb and expects to have the model asset ready. </p>

</div>
</div>
<a class="anchor" id="abed915a7c71927e024ea9b26548cd6f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EMotionFX::Actor::VerifySkinning </td>
          <td>(</td>
          <td class="paramtype">AZStd::vector&lt; uint8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>conflictNodeFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>skeletalLODLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>geometryLODLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify if the skinning will look correctly in the given geometry LOD for a given skeletal LOD level. As the skeletal LOD system can disable nodes entirely the skinning info of a mesh might be linked to a disabled node. This will end up in in an incorrectly deformed mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conflictNodeFlags</td><td>The array of flags that indicate whether a node is used by the skinning info of the geometry LOD level but is disabled by the given skeletal LOD level. Nodes which have an enabled state after calling the function will be nodes that are responsible for bad skinning. The size of the array will always be equal to the number of nodes. So if the conflictNodeFlags[myNodeNr] equals 1 you know there is a conflict, while everything is alright if the value is 0. </td></tr>
    <tr><td class="paramname">skeletalLODLevel</td><td>The skeletal LOD level to be verified. The skinning influences will be tested against disabled nodes from the given skeletal LOD level. </td></tr>
    <tr><td class="paramname">geometryLODLevel</td><td>The geometry LOD level to test the skeletal LOD against with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Gems/EMotionFX/Code/EMotionFX/Source/Actor.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>EMotionFX</b></li><li class="navelem"><a class="el" href="class_e_motion_f_x_1_1_actor.html">Actor</a></li>
    <li class="footer">Generated on Thu Apr 20 2023 21:34:12 for Open 3D Engine EMotionFX Gem API Reference by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
