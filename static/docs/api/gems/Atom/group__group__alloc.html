<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine Atom Gem API Reference: Memory allocation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Open 3D Engine Atom Gem API Reference<span id="projectnumber">&#160;23.10.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group__alloc.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Memory allocation</div></div>
</div><!--header-->
<div class="contents">

<p>API elements related to the allocation, deallocation, and management of Vulkan memory, buffers, images. Most basic ones being: <a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="group__group__alloc.html#gaa76142ae43535c862ad9e194a6e38aaa" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters of new <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a>.  <a href="struct_vma_allocation_create_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_pool_create_info.html">VmaPoolCreateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes parameter of created <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a>.  <a href="struct_vma_pool_create_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters of <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a> objects, that can be retrieved using function <a class="el" href="group__group__alloc.html#gab9c96ca6bb55ad9069829fe8355bbb79" title="Returns current information about specified allocation.">vmaGetAllocationInfo()</a>.  <a href="struct_vma_allocation_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for defragmentation.  <a href="struct_vma_defragmentation_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_defragmentation_move.html">VmaDefragmentationMove</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single move of an allocation to be done for defragmentation.  <a href="struct_vma_defragmentation_move.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for incremental defragmentation steps.  <a href="struct_vma_defragmentation_pass_move_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_defragmentation_stats.html">VmaDefragmentationStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics returned for defragmentation process in function <a class="el" href="group__group__alloc.html#gae419e366d1c015716165bdfd5aafef6f" title="Ends defragmentation process.">vmaEndDefragmentation()</a>.  <a href="struct_vma_defragmentation_stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_pool.html">VmaPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents custom memory pool.  <a href="struct_vma_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents single memory allocation.  <a href="struct_vma_allocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque object that represents started defragmentation process.  <a href="struct_vma_defragmentation_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga806e8499dde802e59eb72a1dc811c35f"><td class="memItemLeft" align="right" valign="top"><a id="ga806e8499dde802e59eb72a1dc811c35f" name="ga806e8499dde802e59eb72a1dc811c35f"></a>
typedef enum <a class="el" href="group__group__alloc.html#gaa5846affa1e9da3800e3e78fae2305cc">VmaMemoryUsage</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VmaMemoryUsage</b></td></tr>
<tr class="memdesc:ga806e8499dde802e59eb72a1dc811c35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intended usage of the allocated memory. <br /></td></tr>
<tr class="separator:ga806e8499dde802e59eb72a1dc811c35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fceecc301f4064dc808d3cd6c038941"><td class="memItemLeft" align="right" valign="top"><a id="ga4fceecc301f4064dc808d3cd6c038941" name="ga4fceecc301f4064dc808d3cd6c038941"></a>
typedef enum <a class="el" href="group__group__alloc.html#gad9889c10c798b040d59c92f257cae597">VmaAllocationCreateFlagBits</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VmaAllocationCreateFlagBits</b></td></tr>
<tr class="memdesc:ga4fceecc301f4064dc808d3cd6c038941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>. <br /></td></tr>
<tr class="separator:ga4fceecc301f4064dc808d3cd6c038941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5225e5e11f8376f6a31a1791f3d6e817"><td class="memItemLeft" align="right" valign="top"><a id="ga5225e5e11f8376f6a31a1791f3d6e817" name="ga5225e5e11f8376f6a31a1791f3d6e817"></a>
typedef VkFlags&#160;</td><td class="memItemRight" valign="bottom"><b>VmaAllocationCreateFlags</b></td></tr>
<tr class="memdesc:ga5225e5e11f8376f6a31a1791f3d6e817"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="group__group__alloc.html#gad9889c10c798b040d59c92f257cae597" title="Flags to be passed as VmaAllocationCreateInfo::flags.">VmaAllocationCreateFlagBits</a>. <br /></td></tr>
<tr class="separator:ga5225e5e11f8376f6a31a1791f3d6e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d4f2efc2509157a9e4ecd4fd7942303"><td class="memItemLeft" align="right" valign="top"><a id="ga4d4f2efc2509157a9e4ecd4fd7942303" name="ga4d4f2efc2509157a9e4ecd4fd7942303"></a>
typedef enum <a class="el" href="group__group__alloc.html#ga9a7c45f9c863695d98c83fa5ac940fe7">VmaPoolCreateFlagBits</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VmaPoolCreateFlagBits</b></td></tr>
<tr class="memdesc:ga4d4f2efc2509157a9e4ecd4fd7942303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_pool_create_info.html#a8405139f63d078340ae74513a59f5446" title="Use combination of VmaPoolCreateFlagBits.">VmaPoolCreateInfo::flags</a>. <br /></td></tr>
<tr class="separator:ga4d4f2efc2509157a9e4ecd4fd7942303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2770e325ea42e087c1b91fdf46d0292a"><td class="memItemLeft" align="right" valign="top"><a id="ga2770e325ea42e087c1b91fdf46d0292a" name="ga2770e325ea42e087c1b91fdf46d0292a"></a>
typedef VkFlags&#160;</td><td class="memItemRight" valign="bottom"><b>VmaPoolCreateFlags</b></td></tr>
<tr class="memdesc:ga2770e325ea42e087c1b91fdf46d0292a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_pool_create_info.html#a8405139f63d078340ae74513a59f5446" title="Use combination of VmaPoolCreateFlagBits.">VmaPoolCreateInfo::flags</a>. See <a class="el" href="group__group__alloc.html#ga9a7c45f9c863695d98c83fa5ac940fe7" title="Flags to be passed as VmaPoolCreateInfo::flags.">VmaPoolCreateFlagBits</a>. <br /></td></tr>
<tr class="separator:ga2770e325ea42e087c1b91fdf46d0292a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13415cc0b443353a7b5abda300b833fc"><td class="memItemLeft" align="right" valign="top"><a id="ga13415cc0b443353a7b5abda300b833fc" name="ga13415cc0b443353a7b5abda300b833fc"></a>
typedef enum <a class="el" href="group__group__alloc.html#ga6552a65b71d16f378c6994b3ceaef50c">VmaDefragmentationFlagBits</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VmaDefragmentationFlagBits</b></td></tr>
<tr class="memdesc:ga13415cc0b443353a7b5abda300b833fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_defragmentation_info.html#a3e23080c978ecf3abb3180f5b2069da7" title="Use combination of VmaDefragmentationFlagBits.">VmaDefragmentationInfo::flags</a>. <br /></td></tr>
<tr class="separator:ga13415cc0b443353a7b5abda300b833fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88a77cef37e5d3c4fc9eb328885d048d"><td class="memItemLeft" align="right" valign="top"><a id="ga88a77cef37e5d3c4fc9eb328885d048d" name="ga88a77cef37e5d3c4fc9eb328885d048d"></a>
typedef VkFlags&#160;</td><td class="memItemRight" valign="bottom"><b>VmaDefragmentationFlags</b></td></tr>
<tr class="memdesc:ga88a77cef37e5d3c4fc9eb328885d048d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="group__group__alloc.html#ga6552a65b71d16f378c6994b3ceaef50c" title="Flags to be passed as VmaDefragmentationInfo::flags.">VmaDefragmentationFlagBits</a>. <br /></td></tr>
<tr class="separator:ga88a77cef37e5d3c4fc9eb328885d048d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ea666deeb3c2c74806a097e27cdb4a1"><td class="memItemLeft" align="right" valign="top"><a id="ga2ea666deeb3c2c74806a097e27cdb4a1" name="ga2ea666deeb3c2c74806a097e27cdb4a1"></a>
typedef enum <a class="el" href="group__group__alloc.html#gada9e3861caf96f08894b0bcc160ec257">VmaDefragmentationMoveOperation</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VmaDefragmentationMoveOperation</b></td></tr>
<tr class="memdesc:ga2ea666deeb3c2c74806a097e27cdb4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation performed on single defragmentation move. See structure <a class="el" href="struct_vma_defragmentation_move.html" title="Single move of an allocation to be done for defragmentation.">VmaDefragmentationMove</a>. <br /></td></tr>
<tr class="separator:ga2ea666deeb3c2c74806a097e27cdb4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bf110892ea2fb4649fedb68488d026a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga3bf110892ea2fb4649fedb68488d026a">VmaAllocationCreateInfo</a></td></tr>
<tr class="memdesc:ga3bf110892ea2fb4649fedb68488d026a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters of new <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a>.  <br /></td></tr>
<tr class="separator:ga3bf110892ea2fb4649fedb68488d026a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1017aa83489c0eee8d2163d2bf253f67"><td class="memItemLeft" align="right" valign="top"><a id="ga1017aa83489c0eee8d2163d2bf253f67" name="ga1017aa83489c0eee8d2163d2bf253f67"></a>
typedef struct <a class="el" href="struct_vma_pool_create_info.html">VmaPoolCreateInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VmaPoolCreateInfo</b></td></tr>
<tr class="memdesc:ga1017aa83489c0eee8d2163d2bf253f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes parameter of created <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a>. <br /></td></tr>
<tr class="separator:ga1017aa83489c0eee8d2163d2bf253f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf7774606721026a68aabe3af2e5b50"><td class="memItemLeft" align="right" valign="top"><a id="ga1cf7774606721026a68aabe3af2e5b50" name="ga1cf7774606721026a68aabe3af2e5b50"></a>
typedef struct <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VmaAllocationInfo</b></td></tr>
<tr class="memdesc:ga1cf7774606721026a68aabe3af2e5b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters of <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a> objects, that can be retrieved using function <a class="el" href="group__group__alloc.html#gab9c96ca6bb55ad9069829fe8355bbb79" title="Returns current information about specified allocation.">vmaGetAllocationInfo()</a>. <br /></td></tr>
<tr class="separator:ga1cf7774606721026a68aabe3af2e5b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bf47f96bf92bed2a49461bd9af3acfa"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga2bf47f96bf92bed2a49461bd9af3acfa">VmaDefragmentationInfo</a></td></tr>
<tr class="memdesc:ga2bf47f96bf92bed2a49461bd9af3acfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for defragmentation.  <br /></td></tr>
<tr class="separator:ga2bf47f96bf92bed2a49461bd9af3acfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga563f4b43d3e31ed603d80cacc9ba8589"><td class="memItemLeft" align="right" valign="top"><a id="ga563f4b43d3e31ed603d80cacc9ba8589" name="ga563f4b43d3e31ed603d80cacc9ba8589"></a>
typedef struct <a class="el" href="struct_vma_defragmentation_move.html">VmaDefragmentationMove</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VmaDefragmentationMove</b></td></tr>
<tr class="memdesc:ga563f4b43d3e31ed603d80cacc9ba8589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single move of an allocation to be done for defragmentation. <br /></td></tr>
<tr class="separator:ga563f4b43d3e31ed603d80cacc9ba8589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6799e8e2b1527abfc84d33bc44aeaf5"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gad6799e8e2b1527abfc84d33bc44aeaf5">VmaDefragmentationPassMoveInfo</a></td></tr>
<tr class="memdesc:gad6799e8e2b1527abfc84d33bc44aeaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for incremental defragmentation steps.  <br /></td></tr>
<tr class="separator:gad6799e8e2b1527abfc84d33bc44aeaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad94034192259c2e34a4d1c5e27810403"><td class="memItemLeft" align="right" valign="top"><a id="gad94034192259c2e34a4d1c5e27810403" name="gad94034192259c2e34a4d1c5e27810403"></a>
typedef struct <a class="el" href="struct_vma_defragmentation_stats.html">VmaDefragmentationStats</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VmaDefragmentationStats</b></td></tr>
<tr class="memdesc:gad94034192259c2e34a4d1c5e27810403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics returned for defragmentation process in function <a class="el" href="group__group__alloc.html#gae419e366d1c015716165bdfd5aafef6f" title="Ends defragmentation process.">vmaEndDefragmentation()</a>. <br /></td></tr>
<tr class="separator:gad94034192259c2e34a4d1c5e27810403"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa5846affa1e9da3800e3e78fae2305cc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gaa5846affa1e9da3800e3e78fae2305cc">VmaMemoryUsage</a> { <br />
&#160;&#160;<a class="el" href="group__group__alloc.html#ggaa5846affa1e9da3800e3e78fae2305ccaf50d27e34e0925cf3a63db8c839121dd">VMA_MEMORY_USAGE_UNKNOWN</a> = 0
, <a class="el" href="group__group__alloc.html#ggaa5846affa1e9da3800e3e78fae2305ccac6b5dc1432d88647aa4cd456246eadf7">VMA_MEMORY_USAGE_GPU_ONLY</a> = 1
, <a class="el" href="group__group__alloc.html#ggaa5846affa1e9da3800e3e78fae2305cca40bdf4cddeffeb12f43d45ca1286e0a5">VMA_MEMORY_USAGE_CPU_ONLY</a> = 2
, <a class="el" href="group__group__alloc.html#ggaa5846affa1e9da3800e3e78fae2305cca9066b52c5a7079bb74a69aaf8b92ff67">VMA_MEMORY_USAGE_CPU_TO_GPU</a> = 3
, <br />
&#160;&#160;<a class="el" href="group__group__alloc.html#ggaa5846affa1e9da3800e3e78fae2305cca7b586d2fdaf82a463b58f581ed72be27">VMA_MEMORY_USAGE_GPU_TO_CPU</a> = 4
, <a class="el" href="group__group__alloc.html#ggaa5846affa1e9da3800e3e78fae2305cca416a444d4d0fc20067c3f76f32ff2500">VMA_MEMORY_USAGE_CPU_COPY</a> = 5
, <a class="el" href="group__group__alloc.html#ggaa5846affa1e9da3800e3e78fae2305cca835333d9072db63a653818030e17614d">VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED</a> = 6
, <a class="el" href="group__group__alloc.html#ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e">VMA_MEMORY_USAGE_AUTO</a> = 7
, <br />
&#160;&#160;<a class="el" href="group__group__alloc.html#ggaa5846affa1e9da3800e3e78fae2305ccae2adb696d6a73c18bb20c23666661327">VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE</a> = 8
, <a class="el" href="group__group__alloc.html#ggaa5846affa1e9da3800e3e78fae2305cca9b422585242160b8ed3418310ee6664d">VMA_MEMORY_USAGE_AUTO_PREFER_HOST</a> = 9
, <b>VMA_MEMORY_USAGE_MAX_ENUM</b> = 0x7FFFFFFF
<br />
 }</td></tr>
<tr class="memdesc:gaa5846affa1e9da3800e3e78fae2305cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intended usage of the allocated memory.  <a href="group__group__alloc.html#gaa5846affa1e9da3800e3e78fae2305cc">More...</a><br /></td></tr>
<tr class="separator:gaa5846affa1e9da3800e3e78fae2305cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9889c10c798b040d59c92f257cae597"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gad9889c10c798b040d59c92f257cae597">VmaAllocationCreateFlagBits</a> { <br />
&#160;&#160;<a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a> = 0x00000001
, <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</a> = 0x00000002
, <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f">VMA_ALLOCATION_CREATE_MAPPED_BIT</a> = 0x00000004
, <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597aa6f24f821cd6a7c5e4a443f7bf59c520">VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</a> = 0x00000020
, <br />
&#160;&#160;<a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a42ba3a2d2c7117953210b7c3ef8da0df">VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</a> = 0x00000040
, <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a2310568c62208af432724305fe29ccea">VMA_ALLOCATION_CREATE_DONT_BIND_BIT</a> = 0x00000080
, <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597ab8b1764f3e9022368e440c057783b92d">VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT</a> = 0x00000100
, <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6">VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT</a> = 0x00000200
, <br />
&#160;&#160;<a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</a> = 0x00000400
, <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</a> = 0x00000800
, <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a11337f96eacf34c1016c339eac165cad">VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</a> = 0x00001000
, <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</a> = 0x00010000
, <br />
&#160;&#160;<a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</a> = 0x00020000
, <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d">VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</a> = 0x00040000
, <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a839826775c62319466441f86496f036d">VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</a> = VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT
, <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a33eb2052674f3ad92386c714a65fb777">VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</a> = VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT
, <br />
&#160;&#160;<a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a8e16845d81ae3d27c47106d4770d5c7e">VMA_ALLOCATION_CREATE_STRATEGY_MASK</a>
, <b>VMA_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM</b> = 0x7FFFFFFF
<br />
 }</td></tr>
<tr class="memdesc:gad9889c10c798b040d59c92f257cae597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>.  <a href="group__group__alloc.html#gad9889c10c798b040d59c92f257cae597">More...</a><br /></td></tr>
<tr class="separator:gad9889c10c798b040d59c92f257cae597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a7c45f9c863695d98c83fa5ac940fe7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga9a7c45f9c863695d98c83fa5ac940fe7">VmaPoolCreateFlagBits</a> { <a class="el" href="group__group__alloc.html#gga9a7c45f9c863695d98c83fa5ac940fe7a9f1a499508a8edb4e8ba40aa0290a3d2">VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</a> = 0x00000002
, <a class="el" href="group__group__alloc.html#gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</a> = 0x00000004
, <a class="el" href="group__group__alloc.html#gga9a7c45f9c863695d98c83fa5ac940fe7af4d270f8f42517a0f70037ceb6ac1d9c">VMA_POOL_CREATE_ALGORITHM_MASK</a>
, <b>VMA_POOL_CREATE_FLAG_BITS_MAX_ENUM</b> = 0x7FFFFFFF
 }</td></tr>
<tr class="memdesc:ga9a7c45f9c863695d98c83fa5ac940fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_pool_create_info.html#a8405139f63d078340ae74513a59f5446" title="Use combination of VmaPoolCreateFlagBits.">VmaPoolCreateInfo::flags</a>.  <a href="group__group__alloc.html#ga9a7c45f9c863695d98c83fa5ac940fe7">More...</a><br /></td></tr>
<tr class="separator:ga9a7c45f9c863695d98c83fa5ac940fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6552a65b71d16f378c6994b3ceaef50c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga6552a65b71d16f378c6994b3ceaef50c">VmaDefragmentationFlagBits</a> { <br />
&#160;&#160;<b>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT</b> = 0x1
, <b>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</b> = 0x2
, <b>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</b> = 0x4
, <a class="el" href="group__group__alloc.html#gga6552a65b71d16f378c6994b3ceaef50cae45a9469e5337731627758671741e412">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</a> = 0x8
, <br />
&#160;&#160;<a class="el" href="group__group__alloc.html#gga6552a65b71d16f378c6994b3ceaef50cabcbbdb3bfd53c4c3ab4eaeb5fd4894e9">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK</a>
, <b>VMA_DEFRAGMENTATION_FLAG_BITS_MAX_ENUM</b> = 0x7FFFFFFF
<br />
 }</td></tr>
<tr class="memdesc:ga6552a65b71d16f378c6994b3ceaef50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_defragmentation_info.html#a3e23080c978ecf3abb3180f5b2069da7" title="Use combination of VmaDefragmentationFlagBits.">VmaDefragmentationInfo::flags</a>.  <a href="group__group__alloc.html#ga6552a65b71d16f378c6994b3ceaef50c">More...</a><br /></td></tr>
<tr class="separator:ga6552a65b71d16f378c6994b3ceaef50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada9e3861caf96f08894b0bcc160ec257"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gada9e3861caf96f08894b0bcc160ec257">VmaDefragmentationMoveOperation</a> { <a class="el" href="group__group__alloc.html#ggada9e3861caf96f08894b0bcc160ec257ad4a06ac46c4cb1c67b0ebc1edfab9f18">VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY</a> = 0
, <a class="el" href="group__group__alloc.html#ggada9e3861caf96f08894b0bcc160ec257ad25bc6f816b226b4fd5170e845f218d2">VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE</a> = 1
, <a class="el" href="group__group__alloc.html#ggada9e3861caf96f08894b0bcc160ec257a9786f8492a9be2c03bd26395e352ab85">VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY</a> = 2
 }</td></tr>
<tr class="memdesc:gada9e3861caf96f08894b0bcc160ec257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation performed on single defragmentation move. See structure <a class="el" href="struct_vma_defragmentation_move.html" title="Single move of an allocation to be done for defragmentation.">VmaDefragmentationMove</a>.  <a href="group__group__alloc.html#gada9e3861caf96f08894b0bcc160ec257">More...</a><br /></td></tr>
<tr class="separator:gada9e3861caf96f08894b0bcc160ec257"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga03cee2bfc7fef20382fa56f5870f3b2f"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga03cee2bfc7fef20382fa56f5870f3b2f">vmaFindMemoryTypeIndex</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, uint32_t memoryTypeBits, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL pAllocationCreateInfo, uint32_t *VMA_NOT_NULL pMemoryTypeIndex)</td></tr>
<tr class="memdesc:ga03cee2bfc7fef20382fa56f5870f3b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helps to find memoryTypeIndex, given memoryTypeBits and <a class="el" href="struct_vma_allocation_create_info.html" title="Parameters of new VmaAllocation.">VmaAllocationCreateInfo</a>.  <br /></td></tr>
<tr class="separator:ga03cee2bfc7fef20382fa56f5870f3b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga723f5683b363c306bf860dab1861f299"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga723f5683b363c306bf860dab1861f299">vmaFindMemoryTypeIndexForBufferInfo</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, const <a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a> *VMA_NOT_NULL pBufferCreateInfo, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL pAllocationCreateInfo, uint32_t *VMA_NOT_NULL pMemoryTypeIndex)</td></tr>
<tr class="memdesc:ga723f5683b363c306bf860dab1861f299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helps to find memoryTypeIndex, given <a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a> and <a class="el" href="struct_vma_allocation_create_info.html" title="Parameters of new VmaAllocation.">VmaAllocationCreateInfo</a>.  <br /></td></tr>
<tr class="separator:ga723f5683b363c306bf860dab1861f299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf05345771a087328949b485ff2da4db"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gaaf05345771a087328949b485ff2da4db">vmaFindMemoryTypeIndexForImageInfo</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, const <a class="el" href="struct_vk_image_create_info.html">VkImageCreateInfo</a> *VMA_NOT_NULL pImageCreateInfo, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL pAllocationCreateInfo, uint32_t *VMA_NOT_NULL pMemoryTypeIndex)</td></tr>
<tr class="memdesc:gaaf05345771a087328949b485ff2da4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helps to find memoryTypeIndex, given <a class="el" href="struct_vk_image_create_info.html">VkImageCreateInfo</a> and <a class="el" href="struct_vma_allocation_create_info.html" title="Parameters of new VmaAllocation.">VmaAllocationCreateInfo</a>.  <br /></td></tr>
<tr class="separator:gaaf05345771a087328949b485ff2da4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga250d4f6f4c09a6a03b82323f999c9c4e"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga250d4f6f4c09a6a03b82323f999c9c4e">vmaCreatePool</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, const <a class="el" href="struct_vma_pool_create_info.html">VmaPoolCreateInfo</a> *VMA_NOT_NULL pCreateInfo, <a class="el" href="struct_vma_pool.html">VmaPool</a> VMA_NULLABLE *VMA_NOT_NULL pPool)</td></tr>
<tr class="memdesc:ga250d4f6f4c09a6a03b82323f999c9c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates Vulkan device memory and creates <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a> object.  <br /></td></tr>
<tr class="separator:ga250d4f6f4c09a6a03b82323f999c9c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03da7fd4d8b772bc2a299bc34850d98"><td class="memItemLeft" align="right" valign="top"><a id="gad03da7fd4d8b772bc2a299bc34850d98" name="gad03da7fd4d8b772bc2a299bc34850d98"></a>
VMA_CALL_PRE void VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><b>vmaDestroyPool</b> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_pool.html">VmaPool</a> VMA_NULLABLE pool)</td></tr>
<tr class="memdesc:gad03da7fd4d8b772bc2a299bc34850d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a> object and frees Vulkan device memory. <br /></td></tr>
<tr class="separator:gad03da7fd4d8b772bc2a299bc34850d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19e2e174d6acb8abfdeb8c200517a468"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga19e2e174d6acb8abfdeb8c200517a468">vmaCheckPoolCorruption</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_pool.html">VmaPool</a> VMA_NOT_NULL pool)</td></tr>
<tr class="memdesc:ga19e2e174d6acb8abfdeb8c200517a468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks magic number in margins around all allocations in given memory pool in search for corruptions.  <br /></td></tr>
<tr class="separator:ga19e2e174d6acb8abfdeb8c200517a468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77b2f609887eabcc36ab90e94230acbf"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE void VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga77b2f609887eabcc36ab90e94230acbf">vmaGetPoolName</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_pool.html">VmaPool</a> VMA_NOT_NULL pool, const char *VMA_NULLABLE *VMA_NOT_NULL ppName)</td></tr>
<tr class="memdesc:ga77b2f609887eabcc36ab90e94230acbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves name of a custom pool.  <br /></td></tr>
<tr class="separator:ga77b2f609887eabcc36ab90e94230acbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0322f7ac6c6425492aec787397d5597"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE void VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gac0322f7ac6c6425492aec787397d5597">vmaSetPoolName</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_pool.html">VmaPool</a> VMA_NOT_NULL pool, const char *VMA_NULLABLE pName)</td></tr>
<tr class="memdesc:gac0322f7ac6c6425492aec787397d5597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets name of a custom pool.  <br /></td></tr>
<tr class="separator:gac0322f7ac6c6425492aec787397d5597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf813f55a0667016a8cd68bb4b8b3b30c"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gaf813f55a0667016a8cd68bb4b8b3b30c">vmaAllocateMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, const <a class="el" href="struct_vk_memory_requirements.html">VkMemoryRequirements</a> *VMA_NOT_NULL pVkMemoryRequirements, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL pCreateInfo, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE *VMA_NOT_NULL pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *VMA_NULLABLE pAllocationInfo)</td></tr>
<tr class="memdesc:gaf813f55a0667016a8cd68bb4b8b3b30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose memory allocation.  <br /></td></tr>
<tr class="separator:gaf813f55a0667016a8cd68bb4b8b3b30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe6834626398ff26264a94ab7581e150"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gafe6834626398ff26264a94ab7581e150">vmaAllocateMemoryPages</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, const <a class="el" href="struct_vk_memory_requirements.html">VkMemoryRequirements</a> *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pVkMemoryRequirements, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pCreateInfo, size_t allocationCount, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pAllocations, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) pAllocationInfo)</td></tr>
<tr class="memdesc:gafe6834626398ff26264a94ab7581e150"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose memory allocation for multiple allocation objects at once.  <br /></td></tr>
<tr class="separator:gafe6834626398ff26264a94ab7581e150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7010aa90a4ccdda56f83db8597b9896"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gaf7010aa90a4ccdda56f83db8597b9896">vmaAllocateMemoryForBuffer</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE buffer, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL pCreateInfo, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE *VMA_NOT_NULL pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *VMA_NULLABLE pAllocationInfo)</td></tr>
<tr class="memdesc:gaf7010aa90a4ccdda56f83db8597b9896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory suitable for given <code>VkBuffer</code>.  <br /></td></tr>
<tr class="separator:gaf7010aa90a4ccdda56f83db8597b9896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b7f39281cb383c1496b68f97cb7f4c5"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga4b7f39281cb383c1496b68f97cb7f4c5">vmaAllocateMemoryForImage</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, VkImage VMA_NOT_NULL_NON_DISPATCHABLE image, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL pCreateInfo, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE *VMA_NOT_NULL pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *VMA_NULLABLE pAllocationInfo)</td></tr>
<tr class="memdesc:ga4b7f39281cb383c1496b68f97cb7f4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory suitable for given <code>VkImage</code>.  <br /></td></tr>
<tr class="separator:ga4b7f39281cb383c1496b68f97cb7f4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c9baca5124d440046bbe508f61d2839"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE void VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga5c9baca5124d440046bbe508f61d2839">vmaFreeMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE allocation)</td></tr>
<tr class="memdesc:ga5c9baca5124d440046bbe508f61d2839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory previously allocated using <a class="el" href="group__group__alloc.html#gaf813f55a0667016a8cd68bb4b8b3b30c" title="General purpose memory allocation.">vmaAllocateMemory()</a>, <a class="el" href="group__group__alloc.html#gaf7010aa90a4ccdda56f83db8597b9896" title="Allocates memory suitable for given VkBuffer.">vmaAllocateMemoryForBuffer()</a>, or <a class="el" href="group__group__alloc.html#ga4b7f39281cb383c1496b68f97cb7f4c5" title="Allocates memory suitable for given VkImage.">vmaAllocateMemoryForImage()</a>.  <br /></td></tr>
<tr class="separator:ga5c9baca5124d440046bbe508f61d2839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga033c6727ed2efed0745ec24ce01d5e1b"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE void VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga033c6727ed2efed0745ec24ce01d5e1b">vmaFreeMemoryPages</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, size_t allocationCount, const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pAllocations)</td></tr>
<tr class="memdesc:ga033c6727ed2efed0745ec24ce01d5e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory and destroys multiple allocations.  <br /></td></tr>
<tr class="separator:ga033c6727ed2efed0745ec24ce01d5e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c96ca6bb55ad9069829fe8355bbb79"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE void VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gab9c96ca6bb55ad9069829fe8355bbb79">vmaGetAllocationInfo</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL allocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *VMA_NOT_NULL pAllocationInfo)</td></tr>
<tr class="memdesc:gab9c96ca6bb55ad9069829fe8355bbb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current information about specified allocation.  <br /></td></tr>
<tr class="separator:gab9c96ca6bb55ad9069829fe8355bbb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1f392a3c70a647f0c53a9ddaa7a6f14"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE void VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gac1f392a3c70a647f0c53a9ddaa7a6f14">vmaSetAllocationUserData</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL allocation, void *VMA_NULLABLE pUserData)</td></tr>
<tr class="memdesc:gac1f392a3c70a647f0c53a9ddaa7a6f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pUserData in given allocation to new value.  <br /></td></tr>
<tr class="separator:gac1f392a3c70a647f0c53a9ddaa7a6f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29b210b1f39e49de844fc7b6944736d7"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE void VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga29b210b1f39e49de844fc7b6944736d7">vmaSetAllocationName</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL allocation, const char *VMA_NULLABLE pName)</td></tr>
<tr class="memdesc:ga29b210b1f39e49de844fc7b6944736d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pName in given allocation to new value.  <br /></td></tr>
<tr class="separator:ga29b210b1f39e49de844fc7b6944736d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6785483eda8b53561437e05e2177d7b"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE void VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gaf6785483eda8b53561437e05e2177d7b">vmaGetAllocationMemoryProperties</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL allocation, VkMemoryPropertyFlags *VMA_NOT_NULL pFlags)</td></tr>
<tr class="memdesc:gaf6785483eda8b53561437e05e2177d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an allocation, returns Property Flags of its memory type.  <br /></td></tr>
<tr class="separator:gaf6785483eda8b53561437e05e2177d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13b93ec0ed38ad7232300cb94931c8d2"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga13b93ec0ed38ad7232300cb94931c8d2">vmaMapMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL allocation, void *VMA_NULLABLE *VMA_NOT_NULL ppData)</td></tr>
<tr class="memdesc:ga13b93ec0ed38ad7232300cb94931c8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps memory represented by given allocation and returns pointer to it.  <br /></td></tr>
<tr class="separator:ga13b93ec0ed38ad7232300cb94931c8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec4645c1787976e2b50d2dfd31279a2b"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE void VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gaec4645c1787976e2b50d2dfd31279a2b">vmaUnmapMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL allocation)</td></tr>
<tr class="memdesc:gaec4645c1787976e2b50d2dfd31279a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps memory represented by given allocation, mapped previously using <a class="el" href="group__group__alloc.html#ga13b93ec0ed38ad7232300cb94931c8d2" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>.  <br /></td></tr>
<tr class="separator:gaec4645c1787976e2b50d2dfd31279a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8093faf3afb114596d964d4bd24cb4a"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gab8093faf3afb114596d964d4bd24cb4a">vmaFlushAllocation</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL allocation, VkDeviceSize offset, VkDeviceSize size)</td></tr>
<tr class="memdesc:gab8093faf3afb114596d964d4bd24cb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes memory of given allocation.  <br /></td></tr>
<tr class="separator:gab8093faf3afb114596d964d4bd24cb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1059764930e85ac377a92b5237b5b919"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga1059764930e85ac377a92b5237b5b919">vmaInvalidateAllocation</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL allocation, VkDeviceSize offset, VkDeviceSize size)</td></tr>
<tr class="memdesc:ga1059764930e85ac377a92b5237b5b919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates memory of given allocation.  <br /></td></tr>
<tr class="separator:ga1059764930e85ac377a92b5237b5b919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09b0a57c5c45949a324ac7c0a4ec42d5"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga09b0a57c5c45949a324ac7c0a4ec42d5">vmaFlushAllocations</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, uint32_t allocationCount, const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) allocations, const VkDeviceSize *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) offsets, const VkDeviceSize *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) sizes)</td></tr>
<tr class="memdesc:ga09b0a57c5c45949a324ac7c0a4ec42d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes memory of given set of allocations.  <br /></td></tr>
<tr class="separator:ga09b0a57c5c45949a324ac7c0a4ec42d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga693a1ae5faed72fac89f12685e1d366f"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga693a1ae5faed72fac89f12685e1d366f">vmaInvalidateAllocations</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, uint32_t allocationCount, const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) allocations, const VkDeviceSize *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) offsets, const VkDeviceSize *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) sizes)</td></tr>
<tr class="memdesc:ga693a1ae5faed72fac89f12685e1d366f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates memory of given set of allocations.  <br /></td></tr>
<tr class="separator:ga693a1ae5faed72fac89f12685e1d366f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0baa58dd12991e7b0fe42dcdf22bb100"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga0baa58dd12991e7b0fe42dcdf22bb100">vmaCheckCorruption</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, uint32_t memoryTypeBits)</td></tr>
<tr class="memdesc:ga0baa58dd12991e7b0fe42dcdf22bb100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions.  <br /></td></tr>
<tr class="separator:ga0baa58dd12991e7b0fe42dcdf22bb100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cdd7b0b8653745fa95af9e78d919e70"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga0cdd7b0b8653745fa95af9e78d919e70">vmaBeginDefragmentation</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, const <a class="el" href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a> *VMA_NOT_NULL pInfo, <a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> VMA_NULLABLE *VMA_NOT_NULL pContext)</td></tr>
<tr class="memdesc:ga0cdd7b0b8653745fa95af9e78d919e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins defragmentation process.  <br /></td></tr>
<tr class="separator:ga0cdd7b0b8653745fa95af9e78d919e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae419e366d1c015716165bdfd5aafef6f"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE void VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gae419e366d1c015716165bdfd5aafef6f">vmaEndDefragmentation</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> VMA_NOT_NULL context, <a class="el" href="struct_vma_defragmentation_stats.html">VmaDefragmentationStats</a> *VMA_NULLABLE pStats)</td></tr>
<tr class="memdesc:gae419e366d1c015716165bdfd5aafef6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends defragmentation process.  <br /></td></tr>
<tr class="separator:gae419e366d1c015716165bdfd5aafef6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbe4a77fdfa7ea29328d2f940d423ab7"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gacbe4a77fdfa7ea29328d2f940d423ab7">vmaBeginDefragmentationPass</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> VMA_NOT_NULL context, <a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a> *VMA_NOT_NULL pPassInfo)</td></tr>
<tr class="memdesc:gacbe4a77fdfa7ea29328d2f940d423ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts single defragmentation pass.  <br /></td></tr>
<tr class="separator:gacbe4a77fdfa7ea29328d2f940d423ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbc69db60f82972ddffaceb6653e344a"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gabbc69db60f82972ddffaceb6653e344a">vmaEndDefragmentationPass</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> VMA_NOT_NULL context, <a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a> *VMA_NOT_NULL pPassInfo)</td></tr>
<tr class="memdesc:gabbc69db60f82972ddffaceb6653e344a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends single defragmentation pass.  <br /></td></tr>
<tr class="separator:gabbc69db60f82972ddffaceb6653e344a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7748e60ccc54e240777a848cb260bb19"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga7748e60ccc54e240777a848cb260bb19">vmaBindBufferMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL allocation, VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE buffer)</td></tr>
<tr class="memdesc:ga7748e60ccc54e240777a848cb260bb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds buffer to allocation.  <br /></td></tr>
<tr class="separator:ga7748e60ccc54e240777a848cb260bb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a71c30e3474a835bdd7fd0507740be7"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga4a71c30e3474a835bdd7fd0507740be7">vmaBindBufferMemory2</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL allocation, VkDeviceSize allocationLocalOffset, VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE buffer, const void *VMA_NULLABLE pNext)</td></tr>
<tr class="memdesc:ga4a71c30e3474a835bdd7fd0507740be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds buffer to allocation with additional parameters.  <br /></td></tr>
<tr class="separator:ga4a71c30e3474a835bdd7fd0507740be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a5d8d9f2a29b42cf87f0f8dfef591f4"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga3a5d8d9f2a29b42cf87f0f8dfef591f4">vmaBindImageMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL allocation, VkImage VMA_NOT_NULL_NON_DISPATCHABLE image)</td></tr>
<tr class="memdesc:ga3a5d8d9f2a29b42cf87f0f8dfef591f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds image to allocation.  <br /></td></tr>
<tr class="separator:ga3a5d8d9f2a29b42cf87f0f8dfef591f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0216b9225b02a66ac610cb45d4729d00"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga0216b9225b02a66ac610cb45d4729d00">vmaBindImageMemory2</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL allocation, VkDeviceSize allocationLocalOffset, VkImage VMA_NOT_NULL_NON_DISPATCHABLE image, const void *VMA_NULLABLE pNext)</td></tr>
<tr class="memdesc:ga0216b9225b02a66ac610cb45d4729d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds image to allocation with additional parameters.  <br /></td></tr>
<tr class="separator:ga0216b9225b02a66ac610cb45d4729d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9773fe0ef8582e23136d2d83c336ab9"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9">vmaCreateBuffer</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, const <a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a> *VMA_NOT_NULL pBufferCreateInfo, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL pAllocationCreateInfo, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pBuffer, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE *VMA_NOT_NULL pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *VMA_NULLABLE pAllocationInfo)</td></tr>
<tr class="memdesc:gae9773fe0ef8582e23136d2d83c336ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code>VkBuffer</code>, allocates and binds memory for it.  <br /></td></tr>
<tr class="separator:gae9773fe0ef8582e23136d2d83c336ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a4d6890fe94cf4d234ca1d78af91229"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga0a4d6890fe94cf4d234ca1d78af91229">vmaCreateBufferWithAlignment</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, const <a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a> *VMA_NOT_NULL pBufferCreateInfo, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL pAllocationCreateInfo, VkDeviceSize minAlignment, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pBuffer, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE *VMA_NOT_NULL pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *VMA_NULLABLE pAllocationInfo)</td></tr>
<tr class="memdesc:ga0a4d6890fe94cf4d234ca1d78af91229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a buffer with additional minimum alignment.  <br /></td></tr>
<tr class="separator:ga0a4d6890fe94cf4d234ca1d78af91229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41a76d0f9f98a001900a889f55973536"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga41a76d0f9f98a001900a889f55973536">vmaCreateAliasingBuffer</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL allocation, const <a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a> *VMA_NOT_NULL pBufferCreateInfo, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pBuffer)</td></tr>
<tr class="memdesc:ga41a76d0f9f98a001900a889f55973536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code>VkBuffer</code>, binds already created memory for it.  <br /></td></tr>
<tr class="separator:ga41a76d0f9f98a001900a889f55973536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a52f74424f23118949951c8f2efe5c"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga56a52f74424f23118949951c8f2efe5c">vmaCreateAliasingBuffer2</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL allocation, VkDeviceSize allocationLocalOffset, const <a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a> *VMA_NOT_NULL pBufferCreateInfo, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pBuffer)</td></tr>
<tr class="memdesc:ga56a52f74424f23118949951c8f2efe5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code>VkBuffer</code>, binds already created memory for it.  <br /></td></tr>
<tr class="separator:ga56a52f74424f23118949951c8f2efe5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcc45e5a6388ab35daa9a46688baee20"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE void VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#gafcc45e5a6388ab35daa9a46688baee20">vmaDestroyBuffer</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE buffer, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE allocation)</td></tr>
<tr class="memdesc:gafcc45e5a6388ab35daa9a46688baee20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys Vulkan buffer and frees allocated memory.  <br /></td></tr>
<tr class="separator:gafcc45e5a6388ab35daa9a46688baee20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa76142ae43535c862ad9e194a6e38aaa"><td class="memItemLeft" align="right" valign="top"><a id="gaa76142ae43535c862ad9e194a6e38aaa" name="gaa76142ae43535c862ad9e194a6e38aaa"></a>
VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><b>vmaCreateImage</b> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, const <a class="el" href="struct_vk_image_create_info.html">VkImageCreateInfo</a> *VMA_NOT_NULL pImageCreateInfo, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL pAllocationCreateInfo, VkImage VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pImage, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE *VMA_NOT_NULL pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *VMA_NULLABLE pAllocationInfo)</td></tr>
<tr class="memdesc:gaa76142ae43535c862ad9e194a6e38aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function similar to <a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>. <br /></td></tr>
<tr class="separator:gaa76142ae43535c862ad9e194a6e38aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ef2c5794b39fea75da48305e3a17084"><td class="memItemLeft" align="right" valign="top"><a id="ga9ef2c5794b39fea75da48305e3a17084" name="ga9ef2c5794b39fea75da48305e3a17084"></a>
VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><b>vmaCreateAliasingImage</b> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL allocation, const <a class="el" href="struct_vk_image_create_info.html">VkImageCreateInfo</a> *VMA_NOT_NULL pImageCreateInfo, VkImage VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pImage)</td></tr>
<tr class="memdesc:ga9ef2c5794b39fea75da48305e3a17084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function similar to <a class="el" href="group__group__alloc.html#ga41a76d0f9f98a001900a889f55973536" title="Creates a new VkBuffer, binds already created memory for it.">vmaCreateAliasingBuffer()</a> but for images. <br /></td></tr>
<tr class="separator:ga9ef2c5794b39fea75da48305e3a17084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad72841405ba3840c757715f0083fd2"><td class="memItemLeft" align="right" valign="top"><a id="gacad72841405ba3840c757715f0083fd2" name="gacad72841405ba3840c757715f0083fd2"></a>
VMA_CALL_PRE VkResult VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><b>vmaCreateAliasingImage2</b> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL allocation, VkDeviceSize allocationLocalOffset, const <a class="el" href="struct_vk_image_create_info.html">VkImageCreateInfo</a> *VMA_NOT_NULL pImageCreateInfo, VkImage VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pImage)</td></tr>
<tr class="memdesc:gacad72841405ba3840c757715f0083fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function similar to <a class="el" href="group__group__alloc.html#ga56a52f74424f23118949951c8f2efe5c" title="Creates a new VkBuffer, binds already created memory for it.">vmaCreateAliasingBuffer2()</a> but for images. <br /></td></tr>
<tr class="separator:gacad72841405ba3840c757715f0083fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f6367e612daace5c5ecd7ef9e47c3fd"><td class="memItemLeft" align="right" valign="top">VMA_CALL_PRE void VMA_CALL_POST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__alloc.html#ga2f6367e612daace5c5ecd7ef9e47c3fd">vmaDestroyImage</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL allocator, VkImage VMA_NULLABLE_NON_DISPATCHABLE image, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE allocation)</td></tr>
<tr class="memdesc:ga2f6367e612daace5c5ecd7ef9e47c3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys Vulkan image and frees allocated memory.  <br /></td></tr>
<tr class="separator:ga2f6367e612daace5c5ecd7ef9e47c3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>API elements related to the allocation, deallocation, and management of Vulkan memory, buffers, images. Most basic ones being: <a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="group__group__alloc.html#gaa76142ae43535c862ad9e194a6e38aaa" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga3bf110892ea2fb4649fedb68488d026a" name="ga3bf110892ea2fb4649fedb68488d026a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bf110892ea2fb4649fedb68488d026a">&#9670;&#160;</a></span>VmaAllocationCreateInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameters of new <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a>. </p>
<p>To be used with functions like <a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="group__group__alloc.html#gaa76142ae43535c862ad9e194a6e38aaa" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>, and many others. </p>

</div>
</div>
<a id="ga2bf47f96bf92bed2a49461bd9af3acfa" name="ga2bf47f96bf92bed2a49461bd9af3acfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bf47f96bf92bed2a49461bd9af3acfa">&#9670;&#160;</a></span>VmaDefragmentationInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a> <a class="el" href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameters for defragmentation. </p>
<p>To be used with function <a class="el" href="group__group__alloc.html#ga0cdd7b0b8653745fa95af9e78d919e70" title="Begins defragmentation process.">vmaBeginDefragmentation()</a>. </p>

</div>
</div>
<a id="gad6799e8e2b1527abfc84d33bc44aeaf5" name="gad6799e8e2b1527abfc84d33bc44aeaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6799e8e2b1527abfc84d33bc44aeaf5">&#9670;&#160;</a></span>VmaDefragmentationPassMoveInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a> <a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameters for incremental defragmentation steps. </p>
<p>To be used with function <a class="el" href="group__group__alloc.html#gacbe4a77fdfa7ea29328d2f940d423ab7" title="Starts single defragmentation pass.">vmaBeginDefragmentationPass()</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gad9889c10c798b040d59c92f257cae597" name="gad9889c10c798b040d59c92f257cae597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9889c10c798b040d59c92f257cae597">&#9670;&#160;</a></span>VmaAllocationCreateFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__alloc.html#gad9889c10c798b040d59c92f257cae597">VmaAllocationCreateFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be passed as <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" name="ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f"></a>VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT&#160;</td><td class="fielddoc"><p>Set this flag if the allocation should have its own memory block. </p>
<p>Use it for special, big resources, like fullscreen images used as attachments. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" name="ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff"></a>VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT&#160;</td><td class="fielddoc"><p>Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block. </p>
<p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
<p>You should not use <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" title="Set this flag if the allocation should have its own memory block.">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a> and <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" title="Set this flag to only try to allocate from existing VkDeviceMemory blocks and never create new such b...">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</a> at the same time. It makes no sense. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" name="ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f"></a>VMA_ALLOCATION_CREATE_MAPPED_BIT&#160;</td><td class="fielddoc"><p>Set this flag to use a memory that will be persistently mapped and retrieve pointer to it. </p>
<p>Pointer to mapped memory will be returned through <a class="el" href="struct_vma_allocation_info.html#a17a39eb34201a610347acb91b38eca79" title="Pointer to the beginning of this allocation as mapped data.">VmaAllocationInfo::pMappedData</a>.</p>
<p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if possible on platforms that support it (e.g. Intel GPU). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597aa6f24f821cd6a7c5e4a443f7bf59c520" name="ggad9889c10c798b040d59c92f257cae597aa6f24f821cd6a7c5e4a443f7bf59c520"></a>VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT&#160;</td><td class="fielddoc"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Preserved for backward compatibility. Consider using <a class="el" href="group__group__alloc.html#ga29b210b1f39e49de844fc7b6944736d7" title="Sets pName in given allocation to new value.">vmaSetAllocationName()</a> instead.</dd></dl>
<p>Set this flag to treat <a class="el" href="struct_vma_allocation_create_info.html#a74e2eb74b3772b657c59473ce605058a" title="Custom general-purpose pointer that will be stored in VmaAllocation, can be read as VmaAllocationInfo...">VmaAllocationCreateInfo::pUserData</a> as pointer to a null-terminated string. Instead of copying pointer value, a local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is also used in <a class="el" href="group__group__stats.html#ga9326cba3c64929b59a15c3ca9cdc8cdb" title="Builds and returns statistics as a null-terminated string in JSON format.">vmaBuildStatsString()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a42ba3a2d2c7117953210b7c3ef8da0df" name="ggad9889c10c798b040d59c92f257cae597a42ba3a2d2c7117953210b7c3ef8da0df"></a>VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT&#160;</td><td class="fielddoc"><p>Allocation will be created from upper stack in a double stack pool.</p>
<p>This flag is only allowed for custom pools created with <a class="el" href="group__group__alloc.html#gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" title="Enables alternative, linear allocation algorithm in this pool.">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</a> flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a2310568c62208af432724305fe29ccea" name="ggad9889c10c798b040d59c92f257cae597a2310568c62208af432724305fe29ccea"></a>VMA_ALLOCATION_CREATE_DONT_BIND_BIT&#160;</td><td class="fielddoc"><p>Create both buffer/image and allocation, but don't bind them together. It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with functions that bind by default: <a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="group__group__alloc.html#gaa76142ae43535c862ad9e194a6e38aaa" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>. Otherwise it is ignored.</p>
<p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure in case the allocation ends up in its own memory block, use also flag <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6" title="Set this flag if the allocated memory will have aliasing resources.">VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597ab8b1764f3e9022368e440c057783b92d" name="ggad9889c10c798b040d59c92f257cae597ab8b1764f3e9022368e440c057783b92d"></a>VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT&#160;</td><td class="fielddoc"><p>Create allocation only if additional device memory required for it, if any, won't exceed memory budget. Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6" name="ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6"></a>VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT&#160;</td><td class="fielddoc"><p>Set this flag if the allocated memory will have aliasing resources. </p>
<p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" title="Set this flag if the allocation should have its own memory block.">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a> is specified. Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" name="ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5"></a>VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT&#160;</td><td class="fielddoc"><p>Requests possibility to map the allocation (using <a class="el" href="group__group__alloc.html#ga13b93ec0ed38ad7232300cb94931c8d2" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a> or <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a>).</p>
<ul>
<li>If you use <a class="el" href="group__group__alloc.html#ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e">VMA_MEMORY_USAGE_AUTO</a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation. Otherwise, mapping is incorrect.</li>
<li>If you use other value of <a class="el" href="group__group__alloc.html#gaa5846affa1e9da3800e3e78fae2305cc" title="Intended usage of the allocated memory.">VmaMemoryUsage</a>, this flag is ignored and mapping is always possible in memory types that are <code>HOST_VISIBLE</code>. This includes allocations created in <a class="el" href="custom_memory_pools.html">Custom memory pools</a>.</li>
</ul>
<p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
<dl class="section warning"><dt>Warning</dt><dd>Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g. <code>pMappedData[i] += x;</code> Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" name="ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492"></a>VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT&#160;</td><td class="fielddoc"><p>Requests possibility to map the allocation (using <a class="el" href="group__group__alloc.html#ga13b93ec0ed38ad7232300cb94931c8d2" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a> or <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a>).</p>
<ul>
<li>If you use <a class="el" href="group__group__alloc.html#ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e">VMA_MEMORY_USAGE_AUTO</a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation. Otherwise, mapping is incorrect.</li>
<li>If you use other value of <a class="el" href="group__group__alloc.html#gaa5846affa1e9da3800e3e78fae2305cc" title="Intended usage of the allocated memory.">VmaMemoryUsage</a>, this flag is ignored and mapping is always possible in memory types that are <code>HOST_VISIBLE</code>. This includes allocations created in <a class="el" href="custom_memory_pools.html">Custom memory pools</a>.</li>
</ul>
<p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is required. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a11337f96eacf34c1016c339eac165cad" name="ggad9889c10c798b040d59c92f257cae597a11337f96eacf34c1016c339eac165cad"></a>VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT&#160;</td><td class="fielddoc"><p>Together with <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</a> or <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</a>, it says that despite request for host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.</p>
<p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using <a class="el" href="group__group__alloc.html#gaf6785483eda8b53561437e05e2177d7b" title="Given an allocation, returns Property Flags of its memory type.">vmaGetAllocationMemoryProperties()</a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>, <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d" name="ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d"></a>VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT&#160;</td><td class="fielddoc"><p>Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the expense of allocation time. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d" name="ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d"></a>VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT&#160;</td><td class="fielddoc"><p>Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d" name="ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d"></a>VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT&#160;</td><td class="fielddoc"><p>Allocation strategy that chooses always the lowest offset in available space. This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a839826775c62319466441f86496f036d" name="ggad9889c10c798b040d59c92f257cae597a839826775c62319466441f86496f036d"></a>VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT&#160;</td><td class="fielddoc"><p>Alias to <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a33eb2052674f3ad92386c714a65fb777" name="ggad9889c10c798b040d59c92f257cae597a33eb2052674f3ad92386c714a65fb777"></a>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT&#160;</td><td class="fielddoc"><p>Alias to <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a8e16845d81ae3d27c47106d4770d5c7e" name="ggad9889c10c798b040d59c92f257cae597a8e16845d81ae3d27c47106d4770d5c7e"></a>VMA_ALLOCATION_CREATE_STRATEGY_MASK&#160;</td><td class="fielddoc"><p>A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6552a65b71d16f378c6994b3ceaef50c" name="ga6552a65b71d16f378c6994b3ceaef50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6552a65b71d16f378c6994b3ceaef50c">&#9670;&#160;</a></span>VmaDefragmentationFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__alloc.html#ga6552a65b71d16f378c6994b3ceaef50c">VmaDefragmentationFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be passed as <a class="el" href="struct_vma_defragmentation_info.html#a3e23080c978ecf3abb3180f5b2069da7" title="Use combination of VmaDefragmentationFlagBits.">VmaDefragmentationInfo::flags</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6552a65b71d16f378c6994b3ceaef50cae45a9469e5337731627758671741e412" name="gga6552a65b71d16f378c6994b3ceaef50cae45a9469e5337731627758671741e412"></a>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT&#160;</td><td class="fielddoc"><p>Use the most roboust algorithm at the cost of time to compute and number of copies to make. Only available when bufferImageGranularity is greater than 1, since it aims to reduce alignment issues between different types of resources. Otherwise falls back to same behavior as VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6552a65b71d16f378c6994b3ceaef50cabcbbdb3bfd53c4c3ab4eaeb5fd4894e9" name="gga6552a65b71d16f378c6994b3ceaef50cabcbbdb3bfd53c4c3ab4eaeb5fd4894e9"></a>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK&#160;</td><td class="fielddoc"><p>A bit mask to extract only <code>ALGORITHM</code> bits from entire set of flags. </p>
</td></tr>
</table>

</div>
</div>
<a id="gada9e3861caf96f08894b0bcc160ec257" name="gada9e3861caf96f08894b0bcc160ec257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada9e3861caf96f08894b0bcc160ec257">&#9670;&#160;</a></span>VmaDefragmentationMoveOperation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__alloc.html#gada9e3861caf96f08894b0bcc160ec257">VmaDefragmentationMoveOperation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operation performed on single defragmentation move. See structure <a class="el" href="struct_vma_defragmentation_move.html" title="Single move of an allocation to be done for defragmentation.">VmaDefragmentationMove</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggada9e3861caf96f08894b0bcc160ec257ad4a06ac46c4cb1c67b0ebc1edfab9f18" name="ggada9e3861caf96f08894b0bcc160ec257ad4a06ac46c4cb1c67b0ebc1edfab9f18"></a>VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY&#160;</td><td class="fielddoc"><p>Buffer/image has been recreated at <code>dstTmpAllocation</code>, data has been copied, old buffer/image has been destroyed. <code>srcAllocation</code> should be changed to point to the new place. This is the default value set by <a class="el" href="group__group__alloc.html#gacbe4a77fdfa7ea29328d2f940d423ab7" title="Starts single defragmentation pass.">vmaBeginDefragmentationPass()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada9e3861caf96f08894b0bcc160ec257ad25bc6f816b226b4fd5170e845f218d2" name="ggada9e3861caf96f08894b0bcc160ec257ad25bc6f816b226b4fd5170e845f218d2"></a>VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE&#160;</td><td class="fielddoc"><p>Set this value if you cannot move the allocation. New place reserved at <code>dstTmpAllocation</code> will be freed. <code>srcAllocation</code> will remain unchanged. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada9e3861caf96f08894b0bcc160ec257a9786f8492a9be2c03bd26395e352ab85" name="ggada9e3861caf96f08894b0bcc160ec257a9786f8492a9be2c03bd26395e352ab85"></a>VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY&#160;</td><td class="fielddoc"><p>Set this value if you decide to abandon the allocation and you destroyed the buffer/image. New place reserved at <code>dstTmpAllocation</code> will be freed, along with <code>srcAllocation</code>, which will be destroyed. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa5846affa1e9da3800e3e78fae2305cc" name="gaa5846affa1e9da3800e3e78fae2305cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5846affa1e9da3800e3e78fae2305cc">&#9670;&#160;</a></span>VmaMemoryUsage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__alloc.html#gaa5846affa1e9da3800e3e78fae2305cc">VmaMemoryUsage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intended usage of the allocated memory. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305ccaf50d27e34e0925cf3a63db8c839121dd" name="ggaa5846affa1e9da3800e3e78fae2305ccaf50d27e34e0925cf3a63db8c839121dd"></a>VMA_MEMORY_USAGE_UNKNOWN&#160;</td><td class="fielddoc"><p>No intended memory usage specified. Use other members of <a class="el" href="struct_vma_allocation_create_info.html" title="Parameters of new VmaAllocation.">VmaAllocationCreateInfo</a> to specify your requirements. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305ccac6b5dc1432d88647aa4cd456246eadf7" name="ggaa5846affa1e9da3800e3e78fae2305ccac6b5dc1432d88647aa4cd456246eadf7"></a>VMA_MEMORY_USAGE_GPU_ONLY&#160;</td><td class="fielddoc"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Obsolete, preserved for backward compatibility. Prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305cca40bdf4cddeffeb12f43d45ca1286e0a5" name="ggaa5846affa1e9da3800e3e78fae2305cca40bdf4cddeffeb12f43d45ca1286e0a5"></a>VMA_MEMORY_USAGE_CPU_ONLY&#160;</td><td class="fielddoc"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Obsolete, preserved for backward compatibility. Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305cca9066b52c5a7079bb74a69aaf8b92ff67" name="ggaa5846affa1e9da3800e3e78fae2305cca9066b52c5a7079bb74a69aaf8b92ff67"></a>VMA_MEMORY_USAGE_CPU_TO_GPU&#160;</td><td class="fielddoc"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Obsolete, preserved for backward compatibility. Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305cca7b586d2fdaf82a463b58f581ed72be27" name="ggaa5846affa1e9da3800e3e78fae2305cca7b586d2fdaf82a463b58f581ed72be27"></a>VMA_MEMORY_USAGE_GPU_TO_CPU&#160;</td><td class="fielddoc"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Obsolete, preserved for backward compatibility. Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305cca416a444d4d0fc20067c3f76f32ff2500" name="ggaa5846affa1e9da3800e3e78fae2305cca416a444d4d0fc20067c3f76f32ff2500"></a>VMA_MEMORY_USAGE_CPU_COPY&#160;</td><td class="fielddoc"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Obsolete, preserved for backward compatibility. Prefers not <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305cca835333d9072db63a653818030e17614d" name="ggaa5846affa1e9da3800e3e78fae2305cca835333d9072db63a653818030e17614d"></a>VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED&#160;</td><td class="fielddoc"><p>Lazily allocated GPU memory having <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>. Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.</p>
<p>Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>.</p>
<p>Allocations with this usage are always created as dedicated - it implies <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" title="Set this flag if the allocation should have its own memory block.">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e" name="ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e"></a>VMA_MEMORY_USAGE_AUTO&#160;</td><td class="fielddoc"><p>Selects best memory type automatically. This flag is recommended for most common use cases.</p>
<p>When using this flag, if you want to map the allocation (using <a class="el" href="group__group__alloc.html#ga13b93ec0ed38ad7232300cb94931c8d2" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a> or <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a>), you must pass one of the flags: <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</a> or <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</a> in <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>.</p>
<p>It can be used only with functions that let the library know <code><a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a></code> or <code><a class="el" href="struct_vk_image_create_info.html">VkImageCreateInfo</a></code>, e.g. <a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="group__group__alloc.html#gaa76142ae43535c862ad9e194a6e38aaa" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>, <a class="el" href="group__group__alloc.html#ga723f5683b363c306bf860dab1861f299" title="Helps to find memoryTypeIndex, given VkBufferCreateInfo and VmaAllocationCreateInfo.">vmaFindMemoryTypeIndexForBufferInfo()</a>, <a class="el" href="group__group__alloc.html#gaaf05345771a087328949b485ff2da4db" title="Helps to find memoryTypeIndex, given VkImageCreateInfo and VmaAllocationCreateInfo.">vmaFindMemoryTypeIndexForImageInfo()</a> and not with generic memory allocation functions. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305ccae2adb696d6a73c18bb20c23666661327" name="ggaa5846affa1e9da3800e3e78fae2305ccae2adb696d6a73c18bb20c23666661327"></a>VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE&#160;</td><td class="fielddoc"><p>Selects best memory type automatically with preference for GPU (device) memory.</p>
<p>When using this flag, if you want to map the allocation (using <a class="el" href="group__group__alloc.html#ga13b93ec0ed38ad7232300cb94931c8d2" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a> or <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a>), you must pass one of the flags: <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</a> or <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</a> in <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>.</p>
<p>It can be used only with functions that let the library know <code><a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a></code> or <code><a class="el" href="struct_vk_image_create_info.html">VkImageCreateInfo</a></code>, e.g. <a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="group__group__alloc.html#gaa76142ae43535c862ad9e194a6e38aaa" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>, <a class="el" href="group__group__alloc.html#ga723f5683b363c306bf860dab1861f299" title="Helps to find memoryTypeIndex, given VkBufferCreateInfo and VmaAllocationCreateInfo.">vmaFindMemoryTypeIndexForBufferInfo()</a>, <a class="el" href="group__group__alloc.html#gaaf05345771a087328949b485ff2da4db" title="Helps to find memoryTypeIndex, given VkImageCreateInfo and VmaAllocationCreateInfo.">vmaFindMemoryTypeIndexForImageInfo()</a> and not with generic memory allocation functions. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305cca9b422585242160b8ed3418310ee6664d" name="ggaa5846affa1e9da3800e3e78fae2305cca9b422585242160b8ed3418310ee6664d"></a>VMA_MEMORY_USAGE_AUTO_PREFER_HOST&#160;</td><td class="fielddoc"><p>Selects best memory type automatically with preference for CPU (host) memory.</p>
<p>When using this flag, if you want to map the allocation (using <a class="el" href="group__group__alloc.html#ga13b93ec0ed38ad7232300cb94931c8d2" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a> or <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a>), you must pass one of the flags: <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</a> or <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</a> in <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>.</p>
<p>It can be used only with functions that let the library know <code><a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a></code> or <code><a class="el" href="struct_vk_image_create_info.html">VkImageCreateInfo</a></code>, e.g. <a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="group__group__alloc.html#gaa76142ae43535c862ad9e194a6e38aaa" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>, <a class="el" href="group__group__alloc.html#ga723f5683b363c306bf860dab1861f299" title="Helps to find memoryTypeIndex, given VkBufferCreateInfo and VmaAllocationCreateInfo.">vmaFindMemoryTypeIndexForBufferInfo()</a>, <a class="el" href="group__group__alloc.html#gaaf05345771a087328949b485ff2da4db" title="Helps to find memoryTypeIndex, given VkImageCreateInfo and VmaAllocationCreateInfo.">vmaFindMemoryTypeIndexForImageInfo()</a> and not with generic memory allocation functions. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9a7c45f9c863695d98c83fa5ac940fe7" name="ga9a7c45f9c863695d98c83fa5ac940fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a7c45f9c863695d98c83fa5ac940fe7">&#9670;&#160;</a></span>VmaPoolCreateFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__alloc.html#ga9a7c45f9c863695d98c83fa5ac940fe7">VmaPoolCreateFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be passed as <a class="el" href="struct_vma_pool_create_info.html#a8405139f63d078340ae74513a59f5446" title="Use combination of VmaPoolCreateFlagBits.">VmaPoolCreateInfo::flags</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9a7c45f9c863695d98c83fa5ac940fe7a9f1a499508a8edb4e8ba40aa0290a3d2" name="gga9a7c45f9c863695d98c83fa5ac940fe7a9f1a499508a8edb4e8ba40aa0290a3d2"></a>VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT&#160;</td><td class="fielddoc"><p>Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be ignored. </p>
<p>This is an optional optimization flag.</p>
<p>If you always allocate using <a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="group__group__alloc.html#gaa76142ae43535c862ad9e194a6e38aaa" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>, <a class="el" href="group__group__alloc.html#gaf7010aa90a4ccdda56f83db8597b9896" title="Allocates memory suitable for given VkBuffer.">vmaAllocateMemoryForBuffer()</a>, then you don't need to use it because allocator knows exact type of your allocations so it can handle Buffer-Image Granularity in the optimal way.</p>
<p>If you also allocate using <a class="el" href="group__group__alloc.html#ga4b7f39281cb383c1496b68f97cb7f4c5" title="Allocates memory suitable for given VkImage.">vmaAllocateMemoryForImage()</a> or <a class="el" href="group__group__alloc.html#gaf813f55a0667016a8cd68bb4b8b3b30c" title="General purpose memory allocation.">vmaAllocateMemory()</a>, exact type of such allocations is not known, so allocator must be conservative in handling Buffer-Image Granularity, which can lead to suboptimal allocation (wasted memory). In that case, if you can make sure you always allocate only buffers and linear images or only optimal images out of this pool, use this flag to make allocator disregard Buffer-Image Granularity and so make allocations faster and more optimal. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" name="gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726"></a>VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT&#160;</td><td class="fielddoc"><p>Enables alternative, linear allocation algorithm in this pool. </p>
<p>Specify this flag to enable linear allocation algorithm, which always creates new allocations after last one and doesn't reuse space from allocations freed in between. It trades memory consumption for simplified algorithm and data structure, which has better performance and uses less memory for metadata.</p>
<p>By using this flag, you can achieve behavior of free-at-once, stack, ring buffer, and double stack. For details, see documentation chapter <a class="el" href="custom_memory_pools.html#linear_algorithm">Linear allocation algorithm</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a7c45f9c863695d98c83fa5ac940fe7af4d270f8f42517a0f70037ceb6ac1d9c" name="gga9a7c45f9c863695d98c83fa5ac940fe7af4d270f8f42517a0f70037ceb6ac1d9c"></a>VMA_POOL_CREATE_ALGORITHM_MASK&#160;</td><td class="fielddoc"><p>Bit mask to extract only <code>ALGORITHM</code> bits from entire set of flags. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf813f55a0667016a8cd68bb4b8b3b30c" name="gaf813f55a0667016a8cd68bb4b8b3b30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf813f55a0667016a8cd68bb4b8b3b30c">&#9670;&#160;</a></span>vmaAllocateMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vk_memory_requirements.html">VkMemoryRequirements</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pVkMemoryRequirements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pAllocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *VMA_NULLABLE&#160;</td>
          <td class="paramname"><em>pAllocationInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General purpose memory allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pVkMemoryRequirements</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pCreateInfo</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocation</td><td>Handle to allocated memory. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocationInfo</td><td>Optional. Information about allocated memory. It can be later fetched using function <a class="el" href="group__group__alloc.html#gab9c96ca6bb55ad9069829fe8355bbb79" title="Returns current information about specified allocation.">vmaGetAllocationInfo()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>You should free the memory using <a class="el" href="group__group__alloc.html#ga5c9baca5124d440046bbe508f61d2839" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a> or <a class="el" href="group__group__alloc.html#ga033c6727ed2efed0745ec24ce01d5e1b" title="Frees memory and destroys multiple allocations.">vmaFreeMemoryPages()</a>.</p>
<p>It is recommended to use <a class="el" href="group__group__alloc.html#gaf7010aa90a4ccdda56f83db8597b9896" title="Allocates memory suitable for given VkBuffer.">vmaAllocateMemoryForBuffer()</a>, <a class="el" href="group__group__alloc.html#ga4b7f39281cb383c1496b68f97cb7f4c5" title="Allocates memory suitable for given VkImage.">vmaAllocateMemoryForImage()</a>, <a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="group__group__alloc.html#gaa76142ae43535c862ad9e194a6e38aaa" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a> instead whenever possible. </p>

</div>
</div>
<a id="gaf7010aa90a4ccdda56f83db8597b9896" name="gaf7010aa90a4ccdda56f83db8597b9896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7010aa90a4ccdda56f83db8597b9896">&#9670;&#160;</a></span>vmaAllocateMemoryForBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryForBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pAllocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *VMA_NULLABLE&#160;</td>
          <td class="paramname"><em>pAllocationInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory suitable for given <code>VkBuffer</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pCreateInfo</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocation</td><td>Handle to allocated memory. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocationInfo</td><td>Optional. Information about allocated memory. It can be later fetched using function <a class="el" href="group__group__alloc.html#gab9c96ca6bb55ad9069829fe8355bbb79" title="Returns current information about specified allocation.">vmaGetAllocationInfo()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>It only creates <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a>. To bind the memory to the buffer, use <a class="el" href="group__group__alloc.html#ga7748e60ccc54e240777a848cb260bb19" title="Binds buffer to allocation.">vmaBindBufferMemory()</a>.</p>
<p>This is a special-purpose function. In most cases you should use <a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>.</p>
<p>You must free the allocation using <a class="el" href="group__group__alloc.html#ga5c9baca5124d440046bbe508f61d2839" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a> when no longer needed. </p>

</div>
</div>
<a id="ga4b7f39281cb383c1496b68f97cb7f4c5" name="ga4b7f39281cb383c1496b68f97cb7f4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b7f39281cb383c1496b68f97cb7f4c5">&#9670;&#160;</a></span>vmaAllocateMemoryForImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryForImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage VMA_NOT_NULL_NON_DISPATCHABLE&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pAllocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *VMA_NULLABLE&#160;</td>
          <td class="paramname"><em>pAllocationInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory suitable for given <code>VkImage</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">image</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pCreateInfo</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocation</td><td>Handle to allocated memory. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocationInfo</td><td>Optional. Information about allocated memory. It can be later fetched using function <a class="el" href="group__group__alloc.html#gab9c96ca6bb55ad9069829fe8355bbb79" title="Returns current information about specified allocation.">vmaGetAllocationInfo()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>It only creates <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a>. To bind the memory to the buffer, use <a class="el" href="group__group__alloc.html#ga3a5d8d9f2a29b42cf87f0f8dfef591f4" title="Binds image to allocation.">vmaBindImageMemory()</a>.</p>
<p>This is a special-purpose function. In most cases you should use <a class="el" href="group__group__alloc.html#gaa76142ae43535c862ad9e194a6e38aaa" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>.</p>
<p>You must free the allocation using <a class="el" href="group__group__alloc.html#ga5c9baca5124d440046bbe508f61d2839" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a> when no longer needed. </p>

</div>
</div>
<a id="gafe6834626398ff26264a94ab7581e150" name="gafe6834626398ff26264a94ab7581e150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe6834626398ff26264a94ab7581e150">&#9670;&#160;</a></span>vmaAllocateMemoryPages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryPages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vk_memory_requirements.html">VkMemoryRequirements</a> *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount)&#160;</td>
          <td class="paramname"><em>pVkMemoryRequirements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount)&#160;</td>
          <td class="paramname"><em>pCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>allocationCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount)&#160;</td>
          <td class="paramname"><em>pAllocations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount)&#160;</td>
          <td class="paramname"><em>pAllocationInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General purpose memory allocation for multiple allocation objects at once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pVkMemoryRequirements</td><td>Memory requirements for each allocation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pCreateInfo</td><td>Creation parameters for each allocation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocationCount</td><td>Number of allocations to make. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocations</td><td>Pointer to array that will be filled with handles to created allocations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocationInfo</td><td>Optional. Pointer to array that will be filled with parameters of created allocations.</td></tr>
  </table>
  </dd>
</dl>
<p>You should free the memory using <a class="el" href="group__group__alloc.html#ga5c9baca5124d440046bbe508f61d2839" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a> or <a class="el" href="group__group__alloc.html#ga033c6727ed2efed0745ec24ce01d5e1b" title="Frees memory and destroys multiple allocations.">vmaFreeMemoryPages()</a>.</p>
<p>Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding. It is just a general purpose allocation function able to make multiple allocations at once. It may be internally optimized to be more efficient than calling <a class="el" href="group__group__alloc.html#gaf813f55a0667016a8cd68bb4b8b3b30c" title="General purpose memory allocation.">vmaAllocateMemory()</a> <code>allocationCount</code> times.</p>
<p>All allocations are made using same parameters. All of them are created out of the same memory pool and type. If any allocation fails, all allocations already made within this function call are also freed, so that when returned result is not <code>VK_SUCCESS</code>, <code>pAllocation</code> array is always entirely filled with <code>VK_NULL_HANDLE</code>. </p>

</div>
</div>
<a id="ga0cdd7b0b8653745fa95af9e78d919e70" name="ga0cdd7b0b8653745fa95af9e78d919e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cdd7b0b8653745fa95af9e78d919e70">&#9670;&#160;</a></span>vmaBeginDefragmentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaBeginDefragmentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> VMA_NULLABLE *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins defragmentation process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pInfo</td><td>Structure filled with parameters of defragmentation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pContext</td><td>Context object that must be passed to <a class="el" href="group__group__alloc.html#gae419e366d1c015716165bdfd5aafef6f" title="Ends defragmentation process.">vmaEndDefragmentation()</a> to finish defragmentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>VK_SUCCESS</code> if defragmentation can begin.</li>
<li><code>VK_ERROR_FEATURE_NOT_PRESENT</code> if defragmentation is not supported.</li>
</ul>
</dd></dl>
<p>For more information about defragmentation, see documentation chapter: <a class="el" href="defragmentation.html">Defragmentation</a>. </p>

</div>
</div>
<a id="gacbe4a77fdfa7ea29328d2f940d423ab7" name="gacbe4a77fdfa7ea29328d2f940d423ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbe4a77fdfa7ea29328d2f940d423ab7">&#9670;&#160;</a></span>vmaBeginDefragmentationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaBeginDefragmentationPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pPassInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts single defragmentation pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>Context object that has been created by <a class="el" href="group__group__alloc.html#ga0cdd7b0b8653745fa95af9e78d919e70" title="Begins defragmentation process.">vmaBeginDefragmentation()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pPassInfo</td><td>Computed information for current pass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>VK_SUCCESS</code> if no more moves are possible. Then you can omit call to <a class="el" href="group__group__alloc.html#gabbc69db60f82972ddffaceb6653e344a" title="Ends single defragmentation pass.">vmaEndDefragmentationPass()</a> and simply end whole defragmentation.</li>
<li><code>VK_INCOMPLETE</code> if there are pending moves returned in <code>pPassInfo</code>. You need to perform them, call <a class="el" href="group__group__alloc.html#gabbc69db60f82972ddffaceb6653e344a" title="Ends single defragmentation pass.">vmaEndDefragmentationPass()</a>, and then preferably try another pass with <a class="el" href="group__group__alloc.html#gacbe4a77fdfa7ea29328d2f940d423ab7" title="Starts single defragmentation pass.">vmaBeginDefragmentationPass()</a>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7748e60ccc54e240777a848cb260bb19" name="ga7748e60ccc54e240777a848cb260bb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7748e60ccc54e240777a848cb260bb19">&#9670;&#160;</a></span>vmaBindBufferMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindBufferMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds buffer to allocation. </p>
<p>Binds specified buffer to region of memory represented by specified allocation. Gets <code>VkDeviceMemory</code> handle and offset from the allocation. If you want to create a buffer, allocate memory for it and bind them together separately, you should use this function for binding instead of standard <code>vkBindBufferMemory()</code>, because it ensures proper synchronization so that when a <code>VkDeviceMemory</code> object is used by multiple allocations, calls to <code>vkBind*Memory()</code> or <code>vkMapMemory()</code> won't happen from multiple threads simultaneously (which is illegal in Vulkan).</p>
<p>It is recommended to use function <a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a> instead of this one. </p>

</div>
</div>
<a id="ga4a71c30e3474a835bdd7fd0507740be7" name="ga4a71c30e3474a835bdd7fd0507740be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a71c30e3474a835bdd7fd0507740be7">&#9670;&#160;</a></span>vmaBindBufferMemory2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindBufferMemory2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>allocationLocalOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *VMA_NULLABLE&#160;</td>
          <td class="paramname"><em>pNext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds buffer to allocation with additional parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramname">allocation</td><td></td></tr>
    <tr><td class="paramname">allocationLocalOffset</td><td>Additional offset to be added while binding, relative to the beginning of the <code>allocation</code>. Normally it should be 0. </td></tr>
    <tr><td class="paramname">buffer</td><td></td></tr>
    <tr><td class="paramname">pNext</td><td>A chain of structures to be attached to <code>VkBindBufferMemoryInfoKHR</code> structure used internally. Normally it should be null.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is similar to <a class="el" href="group__group__alloc.html#ga7748e60ccc54e240777a848cb260bb19" title="Binds buffer to allocation.">vmaBindBufferMemory()</a>, but it provides additional parameters.</p>
<p>If <code>pNext</code> is not null, <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a> object must have been created with <a class="el" href="group__group__init.html#gga4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</a> flag or with <a class="el" href="struct_vma_allocator_create_info.html#ae0ffc55139b54520a6bb704b29ffc285" title="Optional. The highest version of Vulkan that the application is designed to use.">VmaAllocatorCreateInfo::vulkanApiVersion</a> <code>&gt;= VK_API_VERSION_1_1</code>. Otherwise the call fails. </p>

</div>
</div>
<a id="ga3a5d8d9f2a29b42cf87f0f8dfef591f4" name="ga3a5d8d9f2a29b42cf87f0f8dfef591f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a5d8d9f2a29b42cf87f0f8dfef591f4">&#9670;&#160;</a></span>vmaBindImageMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindImageMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage VMA_NOT_NULL_NON_DISPATCHABLE&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds image to allocation. </p>
<p>Binds specified image to region of memory represented by specified allocation. Gets <code>VkDeviceMemory</code> handle and offset from the allocation. If you want to create an image, allocate memory for it and bind them together separately, you should use this function for binding instead of standard <code>vkBindImageMemory()</code>, because it ensures proper synchronization so that when a <code>VkDeviceMemory</code> object is used by multiple allocations, calls to <code>vkBind*Memory()</code> or <code>vkMapMemory()</code> won't happen from multiple threads simultaneously (which is illegal in Vulkan).</p>
<p>It is recommended to use function <a class="el" href="group__group__alloc.html#gaa76142ae43535c862ad9e194a6e38aaa" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a> instead of this one. </p>

</div>
</div>
<a id="ga0216b9225b02a66ac610cb45d4729d00" name="ga0216b9225b02a66ac610cb45d4729d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0216b9225b02a66ac610cb45d4729d00">&#9670;&#160;</a></span>vmaBindImageMemory2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindImageMemory2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>allocationLocalOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage VMA_NOT_NULL_NON_DISPATCHABLE&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *VMA_NULLABLE&#160;</td>
          <td class="paramname"><em>pNext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds image to allocation with additional parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramname">allocation</td><td></td></tr>
    <tr><td class="paramname">allocationLocalOffset</td><td>Additional offset to be added while binding, relative to the beginning of the <code>allocation</code>. Normally it should be 0. </td></tr>
    <tr><td class="paramname">image</td><td></td></tr>
    <tr><td class="paramname">pNext</td><td>A chain of structures to be attached to <code>VkBindImageMemoryInfoKHR</code> structure used internally. Normally it should be null.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is similar to <a class="el" href="group__group__alloc.html#ga3a5d8d9f2a29b42cf87f0f8dfef591f4" title="Binds image to allocation.">vmaBindImageMemory()</a>, but it provides additional parameters.</p>
<p>If <code>pNext</code> is not null, <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a> object must have been created with <a class="el" href="group__group__init.html#gga4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</a> flag or with <a class="el" href="struct_vma_allocator_create_info.html#ae0ffc55139b54520a6bb704b29ffc285" title="Optional. The highest version of Vulkan that the application is designed to use.">VmaAllocatorCreateInfo::vulkanApiVersion</a> <code>&gt;= VK_API_VERSION_1_1</code>. Otherwise the call fails. </p>

</div>
</div>
<a id="ga0baa58dd12991e7b0fe42dcdf22bb100" name="ga0baa58dd12991e7b0fe42dcdf22bb100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0baa58dd12991e7b0fe42dcdf22bb100">&#9670;&#160;</a></span>vmaCheckCorruption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaCheckCorruption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>memoryTypeBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramname">memoryTypeBits</td><td>Bit mask, where each bit set means that a memory type with that index should be checked.</td></tr>
  </table>
  </dd>
</dl>
<p>Corruption detection is enabled only when <code>VMA_DEBUG_DETECT_CORRUPTION</code> macro is defined to nonzero, <code>VMA_DEBUG_MARGIN</code> is defined to nonzero and only for memory types that are <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>. For more information, see <a class="el" href="debugging_memory_usage.html#debugging_memory_usage_corruption_detection">Corruption detection</a>.</p>
<p>Possible return values:</p>
<ul>
<li><code>VK_ERROR_FEATURE_NOT_PRESENT</code> - corruption detection is not enabled for any of specified memory types.</li>
<li><code>VK_SUCCESS</code> - corruption detection has been performed and succeeded.</li>
<li><code>VK_ERROR_UNKNOWN</code> - corruption detection has been performed and found memory corruptions around one of the allocations. <code>VMA_ASSERT</code> is also fired in that case.</li>
<li>Other value: Error returned by Vulkan, e.g. memory mapping failure. </li>
</ul>

</div>
</div>
<a id="ga19e2e174d6acb8abfdeb8c200517a468" name="ga19e2e174d6acb8abfdeb8c200517a468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19e2e174d6acb8abfdeb8c200517a468">&#9670;&#160;</a></span>vmaCheckPoolCorruption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaCheckPoolCorruption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool.html">VmaPool</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks magic number in margins around all allocations in given memory pool in search for corruptions. </p>
<p>Corruption detection is enabled only when <code>VMA_DEBUG_DETECT_CORRUPTION</code> macro is defined to nonzero, <code>VMA_DEBUG_MARGIN</code> is defined to nonzero and the pool is created in memory type that is <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>. For more information, see <a class="el" href="debugging_memory_usage.html#debugging_memory_usage_corruption_detection">Corruption detection</a>.</p>
<p>Possible return values:</p>
<ul>
<li><code>VK_ERROR_FEATURE_NOT_PRESENT</code> - corruption detection is not enabled for specified pool.</li>
<li><code>VK_SUCCESS</code> - corruption detection has been performed and succeeded.</li>
<li><code>VK_ERROR_UNKNOWN</code> - corruption detection has been performed and found memory corruptions around one of the allocations. <code>VMA_ASSERT</code> is also fired in that case.</li>
<li>Other value: Error returned by Vulkan, e.g. memory mapping failure. </li>
</ul>

</div>
</div>
<a id="ga41a76d0f9f98a001900a889f55973536" name="ga41a76d0f9f98a001900a889f55973536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41a76d0f9f98a001900a889f55973536">&#9670;&#160;</a></span>vmaCreateAliasingBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateAliasingBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pBufferCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <code>VkBuffer</code>, binds already created memory for it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocation</td><td>Allocation that provides memory to be used for binding new buffer to it. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pBufferCreateInfo</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pBuffer</td><td>Buffer that was created.</td></tr>
  </table>
  </dd>
</dl>
<p>This function automatically:</p>
<ol type="1">
<li>Creates buffer.</li>
<li>Binds the buffer with the supplied memory.</li>
</ol>
<p>If any of these operations fail, buffer is not created, returned value is negative error code and <code>*pBuffer</code> is null.</p>
<p>If the function succeeded, you must destroy the buffer when you no longer need it using <code>vkDestroyBuffer()</code>. If you want to also destroy the corresponding allocation you can use convenience function <a class="el" href="group__group__alloc.html#gafcc45e5a6388ab35daa9a46688baee20" title="Destroys Vulkan buffer and frees allocated memory.">vmaDestroyBuffer()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>There is a new version of this function augmented with parameter <code>allocationLocalOffset</code> - see <a class="el" href="group__group__alloc.html#ga56a52f74424f23118949951c8f2efe5c" title="Creates a new VkBuffer, binds already created memory for it.">vmaCreateAliasingBuffer2()</a>. </dd></dl>

</div>
</div>
<a id="ga56a52f74424f23118949951c8f2efe5c" name="ga56a52f74424f23118949951c8f2efe5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56a52f74424f23118949951c8f2efe5c">&#9670;&#160;</a></span>vmaCreateAliasingBuffer2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateAliasingBuffer2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>allocationLocalOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pBufferCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <code>VkBuffer</code>, binds already created memory for it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocation</td><td>Allocation that provides memory to be used for binding new buffer to it. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocationLocalOffset</td><td>Additional offset to be added while binding, relative to the beginning of the allocation. Normally it should be 0. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pBufferCreateInfo</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pBuffer</td><td>Buffer that was created.</td></tr>
  </table>
  </dd>
</dl>
<p>This function automatically:</p>
<ol type="1">
<li>Creates buffer.</li>
<li>Binds the buffer with the supplied memory.</li>
</ol>
<p>If any of these operations fail, buffer is not created, returned value is negative error code and <code>*pBuffer</code> is null.</p>
<p>If the function succeeded, you must destroy the buffer when you no longer need it using <code>vkDestroyBuffer()</code>. If you want to also destroy the corresponding allocation you can use convenience function <a class="el" href="group__group__alloc.html#gafcc45e5a6388ab35daa9a46688baee20" title="Destroys Vulkan buffer and frees allocated memory.">vmaDestroyBuffer()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This is a new version of the function augmented with parameter <code>allocationLocalOffset</code>. </dd></dl>

</div>
</div>
<a id="gae9773fe0ef8582e23136d2d83c336ab9" name="gae9773fe0ef8582e23136d2d83c336ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9773fe0ef8582e23136d2d83c336ab9">&#9670;&#160;</a></span>vmaCreateBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pBufferCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pAllocationCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pAllocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *VMA_NULLABLE&#160;</td>
          <td class="paramname"><em>pAllocationInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <code>VkBuffer</code>, allocates and binds memory for it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pBufferCreateInfo</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pAllocationCreateInfo</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pBuffer</td><td>Buffer that was created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocation</td><td>Allocation that was created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocationInfo</td><td>Optional. Information about allocated memory. It can be later fetched using function <a class="el" href="group__group__alloc.html#gab9c96ca6bb55ad9069829fe8355bbb79" title="Returns current information about specified allocation.">vmaGetAllocationInfo()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function automatically:</p>
<ol type="1">
<li>Creates buffer.</li>
<li>Allocates appropriate memory for it.</li>
<li>Binds the buffer with the memory.</li>
</ol>
<p>If any of these operations fail, buffer and allocation are not created, returned value is negative error code, <code>*pBuffer</code> and <code>*pAllocation</code> are null.</p>
<p>If the function succeeded, you must destroy both buffer and allocation when you no longer need them using either convenience function <a class="el" href="group__group__alloc.html#gafcc45e5a6388ab35daa9a46688baee20" title="Destroys Vulkan buffer and frees allocated memory.">vmaDestroyBuffer()</a> or separately, using <code>vkDestroyBuffer()</code> and <a class="el" href="group__group__alloc.html#ga5c9baca5124d440046bbe508f61d2839" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a>.</p>
<p>If <a class="el" href="group__group__init.html#gga4f87c9100d154a65a4ad495f7763cf7cace7da7cc6e71a625dfa763c55a597878" title="Enables usage of VK_KHR_dedicated_allocation extension.">VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</a> flag was used, VK_KHR_dedicated_allocation extension is used internally to query driver whether it requires or prefers the new buffer to have dedicated allocation. If yes, and if dedicated allocation is possible (<a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" title="Set this flag to only try to allocate from existing VkDeviceMemory blocks and never create new such b...">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</a> is not used), it creates dedicated allocation for this buffer, just like when using <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" title="Set this flag if the allocation should have its own memory block.">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function creates a new <code>VkBuffer</code>. Sub-allocation of parts of one large buffer, although recommended as a good practice, is out of scope of this library and could be implemented by the user as a higher-level logic on top of VMA. </dd></dl>

</div>
</div>
<a id="ga0a4d6890fe94cf4d234ca1d78af91229" name="ga0a4d6890fe94cf4d234ca1d78af91229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a4d6890fe94cf4d234ca1d78af91229">&#9670;&#160;</a></span>vmaCreateBufferWithAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateBufferWithAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pBufferCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pAllocationCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>minAlignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pAllocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *VMA_NULLABLE&#160;</td>
          <td class="paramname"><em>pAllocationInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a buffer with additional minimum alignment. </p>
<p>Similar to <a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a> but provides additional parameter <code>minAlignment</code> which allows to specify custom, minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g. for interop with OpenGL. </p>

</div>
</div>
<a id="ga250d4f6f4c09a6a03b82323f999c9c4e" name="ga250d4f6f4c09a6a03b82323f999c9c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga250d4f6f4c09a6a03b82323f999c9c4e">&#9670;&#160;</a></span>vmaCreatePool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreatePool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_pool_create_info.html">VmaPoolCreateInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool.html">VmaPool</a> VMA_NULLABLE *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pPool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates Vulkan device memory and creates <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pCreateInfo</td><td>Parameters of pool to create. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pPool</td><td>Handle to created pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafcc45e5a6388ab35daa9a46688baee20" name="gafcc45e5a6388ab35daa9a46688baee20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcc45e5a6388ab35daa9a46688baee20">&#9670;&#160;</a></span>vmaDestroyBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE void VMA_CALL_POST vmaDestroyBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer VMA_NULLABLE_NON_DISPATCHABLE&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys Vulkan buffer and frees allocated memory. </p>
<p>This is just a convenience function equivalent to:</p>
<div class="fragment"><div class="line">vkDestroyBuffer(device, buffer, allocationCallbacks);</div>
<div class="line"><a class="code hl_function" href="group__group__alloc.html#ga5c9baca5124d440046bbe508f61d2839">vmaFreeMemory</a>(allocator, allocation);</div>
<div class="ttc" id="agroup__group__alloc_html_ga5c9baca5124d440046bbe508f61d2839"><div class="ttname"><a href="group__group__alloc.html#ga5c9baca5124d440046bbe508f61d2839">vmaFreeMemory</a></div><div class="ttdeci">VMA_CALL_PRE void VMA_CALL_POST vmaFreeMemory(VmaAllocator VMA_NOT_NULL allocator, const VmaAllocation VMA_NULLABLE allocation)</div><div class="ttdoc">Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...</div></div>
</div><!-- fragment --><p>It is safe to pass null as buffer and/or allocation. </p>

</div>
</div>
<a id="ga2f6367e612daace5c5ecd7ef9e47c3fd" name="ga2f6367e612daace5c5ecd7ef9e47c3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f6367e612daace5c5ecd7ef9e47c3fd">&#9670;&#160;</a></span>vmaDestroyImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE void VMA_CALL_POST vmaDestroyImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage VMA_NULLABLE_NON_DISPATCHABLE&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys Vulkan image and frees allocated memory. </p>
<p>This is just a convenience function equivalent to:</p>
<div class="fragment"><div class="line">vkDestroyImage(device, image, allocationCallbacks);</div>
<div class="line"><a class="code hl_function" href="group__group__alloc.html#ga5c9baca5124d440046bbe508f61d2839">vmaFreeMemory</a>(allocator, allocation);</div>
</div><!-- fragment --><p>It is safe to pass null as image and/or allocation. </p>

</div>
</div>
<a id="gae419e366d1c015716165bdfd5aafef6f" name="gae419e366d1c015716165bdfd5aafef6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae419e366d1c015716165bdfd5aafef6f">&#9670;&#160;</a></span>vmaEndDefragmentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE void VMA_CALL_POST vmaEndDefragmentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_stats.html">VmaDefragmentationStats</a> *VMA_NULLABLE&#160;</td>
          <td class="paramname"><em>pStats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ends defragmentation process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>Context object that has been created by <a class="el" href="group__group__alloc.html#ga0cdd7b0b8653745fa95af9e78d919e70" title="Begins defragmentation process.">vmaBeginDefragmentation()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pStats</td><td>Optional stats for the defragmentation. Can be null.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this function to finish defragmentation started by <a class="el" href="group__group__alloc.html#ga0cdd7b0b8653745fa95af9e78d919e70" title="Begins defragmentation process.">vmaBeginDefragmentation()</a>. </p>

</div>
</div>
<a id="gabbc69db60f82972ddffaceb6653e344a" name="gabbc69db60f82972ddffaceb6653e344a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbc69db60f82972ddffaceb6653e344a">&#9670;&#160;</a></span>vmaEndDefragmentationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaEndDefragmentationPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pPassInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ends single defragmentation pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramname">context</td><td>Context object that has been created by <a class="el" href="group__group__alloc.html#ga0cdd7b0b8653745fa95af9e78d919e70" title="Begins defragmentation process.">vmaBeginDefragmentation()</a>. </td></tr>
    <tr><td class="paramname">pPassInfo</td><td>Computed information for current pass filled by <a class="el" href="group__group__alloc.html#gacbe4a77fdfa7ea29328d2f940d423ab7" title="Starts single defragmentation pass.">vmaBeginDefragmentationPass()</a> and possibly modified by you.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns <code>VK_SUCCESS</code> if no more moves are possible or <code>VK_INCOMPLETE</code> if more defragmentations are possible.</p>
<p>Ends incremental defragmentation pass and commits all defragmentation moves from <code>pPassInfo</code>. After this call:</p>
<ul>
<li>Allocations at <code>pPassInfo[i].srcAllocation</code> that had <code>pPassInfo[i].operation ==</code> <a class="el" href="group__group__alloc.html#ggada9e3861caf96f08894b0bcc160ec257ad4a06ac46c4cb1c67b0ebc1edfab9f18" title="Buffer/image has been recreated at dstTmpAllocation, data has been copied, old buffer/image has been ...">VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY</a> (which is the default) will be pointing to the new destination place.</li>
<li>Allocation at <code>pPassInfo[i].srcAllocation</code> that had <code>pPassInfo[i].operation ==</code> <a class="el" href="group__group__alloc.html#ggada9e3861caf96f08894b0bcc160ec257a9786f8492a9be2c03bd26395e352ab85" title="Set this value if you decide to abandon the allocation and you destroyed the buffer/image....">VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY</a> will be freed.</li>
</ul>
<p>If no more moves are possible you can end whole defragmentation. </p>

</div>
</div>
<a id="ga03cee2bfc7fef20382fa56f5870f3b2f" name="ga03cee2bfc7fef20382fa56f5870f3b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03cee2bfc7fef20382fa56f5870f3b2f">&#9670;&#160;</a></span>vmaFindMemoryTypeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>memoryTypeBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pAllocationCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pMemoryTypeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helps to find memoryTypeIndex, given memoryTypeBits and <a class="el" href="struct_vma_allocation_create_info.html" title="Parameters of new VmaAllocation.">VmaAllocationCreateInfo</a>. </p>
<p>This algorithm tries to find a memory type that:</p>
<ul>
<li>Is allowed by memoryTypeBits.</li>
<li>Contains all the flags from pAllocationCreateInfo-&gt;requiredFlags.</li>
<li>Matches intended usage.</li>
<li>Has as many flags from pAllocationCreateInfo-&gt;preferredFlags as possible.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result from this function or any other allocating function probably means that your device doesn't support any memory type with requested features for the specific type of resource you want to use it for. Please check parameters of your resource, like image layout (OPTIMAL versus LINEAR) or mip level count. </dd></dl>

</div>
</div>
<a id="ga723f5683b363c306bf860dab1861f299" name="ga723f5683b363c306bf860dab1861f299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga723f5683b363c306bf860dab1861f299">&#9670;&#160;</a></span>vmaFindMemoryTypeIndexForBufferInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndexForBufferInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pBufferCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pAllocationCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pMemoryTypeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helps to find memoryTypeIndex, given <a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a> and <a class="el" href="struct_vma_allocation_create_info.html" title="Parameters of new VmaAllocation.">VmaAllocationCreateInfo</a>. </p>
<p>It can be useful e.g. to determine value to be used as <a class="el" href="struct_vma_pool_create_info.html#a596fa76b685d3f1f688f84a709a5b319" title="Vulkan memory type index to allocate this pool from.">VmaPoolCreateInfo::memoryTypeIndex</a>. It internally creates a temporary, dummy buffer that never has memory bound. </p>

</div>
</div>
<a id="gaaf05345771a087328949b485ff2da4db" name="gaaf05345771a087328949b485ff2da4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf05345771a087328949b485ff2da4db">&#9670;&#160;</a></span>vmaFindMemoryTypeIndexForImageInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndexForImageInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vk_image_create_info.html">VkImageCreateInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pImageCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pAllocationCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pMemoryTypeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helps to find memoryTypeIndex, given <a class="el" href="struct_vk_image_create_info.html">VkImageCreateInfo</a> and <a class="el" href="struct_vma_allocation_create_info.html" title="Parameters of new VmaAllocation.">VmaAllocationCreateInfo</a>. </p>
<p>It can be useful e.g. to determine value to be used as <a class="el" href="struct_vma_pool_create_info.html#a596fa76b685d3f1f688f84a709a5b319" title="Vulkan memory type index to allocate this pool from.">VmaPoolCreateInfo::memoryTypeIndex</a>. It internally creates a temporary, dummy image that never has memory bound. </p>

</div>
</div>
<a id="gab8093faf3afb114596d964d4bd24cb4a" name="gab8093faf3afb114596d964d4bd24cb4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8093faf3afb114596d964d4bd24cb4a">&#9670;&#160;</a></span>vmaFlushAllocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaFlushAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes memory of given allocation. </p>
<p>Calls <code>vkFlushMappedMemoryRanges()</code> for memory associated with given range of given allocation. It needs to be called after writing to a mapped memory for memory types that are not <code>HOST_COHERENT</code>. Unmap operation doesn't do that automatically.</p>
<ul>
<li><code>offset</code> must be relative to the beginning of allocation.</li>
<li><code>size</code> can be <code>VK_WHOLE_SIZE</code>. It means all memory from <code>offset</code> the the end of given allocation.</li>
<li><code>offset</code> and <code>size</code> don't have to be aligned. They are internally rounded down/up to multiply of <code>nonCoherentAtomSize</code>.</li>
<li>If <code>size</code> is 0, this call is ignored.</li>
<li>If memory type that the <code>allocation</code> belongs to is not <code>HOST_VISIBLE</code> or it is <code>HOST_COHERENT</code>, this call is ignored.</li>
</ul>
<p>Warning! <code>offset</code> and <code>size</code> are relative to the contents of given <code>allocation</code>. If you mean whole allocation, you can pass 0 and <code>VK_WHOLE_SIZE</code>, respectively. Do not pass allocation's offset as <code>offset</code>!!!</p>
<p>This function returns the <code>VkResult</code> from <code>vkFlushMappedMemoryRanges</code> if it is called, otherwise <code>VK_SUCCESS</code>. </p>

</div>
</div>
<a id="ga09b0a57c5c45949a324ac7c0a4ec42d5" name="ga09b0a57c5c45949a324ac7c0a4ec42d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09b0a57c5c45949a324ac7c0a4ec42d5">&#9670;&#160;</a></span>vmaFlushAllocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaFlushAllocations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>allocationCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount)&#160;</td>
          <td class="paramname"><em>allocations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount)&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount)&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes memory of given set of allocations. </p>
<p>Calls <code>vkFlushMappedMemoryRanges()</code> for memory associated with given ranges of given allocations. For more information, see documentation of <a class="el" href="group__group__alloc.html#gab8093faf3afb114596d964d4bd24cb4a" title="Flushes memory of given allocation.">vmaFlushAllocation()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramname">allocationCount</td><td></td></tr>
    <tr><td class="paramname">allocations</td><td></td></tr>
    <tr><td class="paramname">offsets</td><td>If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero. </td></tr>
    <tr><td class="paramname">sizes</td><td>If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means <code>VK_WHOLE_SIZE</code> for all allocations.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the <code>VkResult</code> from <code>vkFlushMappedMemoryRanges</code> if it is called, otherwise <code>VK_SUCCESS</code>. </p>

</div>
</div>
<a id="ga5c9baca5124d440046bbe508f61d2839" name="ga5c9baca5124d440046bbe508f61d2839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c9baca5124d440046bbe508f61d2839">&#9670;&#160;</a></span>vmaFreeMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE void VMA_CALL_POST vmaFreeMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory previously allocated using <a class="el" href="group__group__alloc.html#gaf813f55a0667016a8cd68bb4b8b3b30c" title="General purpose memory allocation.">vmaAllocateMemory()</a>, <a class="el" href="group__group__alloc.html#gaf7010aa90a4ccdda56f83db8597b9896" title="Allocates memory suitable for given VkBuffer.">vmaAllocateMemoryForBuffer()</a>, or <a class="el" href="group__group__alloc.html#ga4b7f39281cb383c1496b68f97cb7f4c5" title="Allocates memory suitable for given VkImage.">vmaAllocateMemoryForImage()</a>. </p>
<p>Passing <code>VK_NULL_HANDLE</code> as <code>allocation</code> is valid. Such function call is just skipped. </p>

</div>
</div>
<a id="ga033c6727ed2efed0745ec24ce01d5e1b" name="ga033c6727ed2efed0745ec24ce01d5e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga033c6727ed2efed0745ec24ce01d5e1b">&#9670;&#160;</a></span>vmaFreeMemoryPages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE void VMA_CALL_POST vmaFreeMemoryPages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>allocationCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NULLABLE *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount)&#160;</td>
          <td class="paramname"><em>pAllocations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory and destroys multiple allocations. </p>
<p>Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding. It is just a general purpose function to free memory and destroy allocations made using e.g. <a class="el" href="group__group__alloc.html#gaf813f55a0667016a8cd68bb4b8b3b30c" title="General purpose memory allocation.">vmaAllocateMemory()</a>, <a class="el" href="group__group__alloc.html#gafe6834626398ff26264a94ab7581e150" title="General purpose memory allocation for multiple allocation objects at once.">vmaAllocateMemoryPages()</a> and other functions. It may be internally optimized to be more efficient than calling <a class="el" href="group__group__alloc.html#ga5c9baca5124d440046bbe508f61d2839" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a> <code>allocationCount</code> times.</p>
<p>Allocations in <code>pAllocations</code> array can come from any memory pools and types. Passing <code>VK_NULL_HANDLE</code> as elements of <code>pAllocations</code> array is valid. Such entries are just skipped. </p>

</div>
</div>
<a id="gab9c96ca6bb55ad9069829fe8355bbb79" name="gab9c96ca6bb55ad9069829fe8355bbb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9c96ca6bb55ad9069829fe8355bbb79">&#9670;&#160;</a></span>vmaGetAllocationInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE void VMA_CALL_POST vmaGetAllocationInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pAllocationInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current information about specified allocation. </p>
<p>Current parameters of given allocation are returned in <code>pAllocationInfo</code>.</p>
<p>Although this function doesn't lock any mutex, so it should be quite efficient, you should avoid calling it too often. You can retrieve same <a class="el" href="struct_vma_allocation_info.html" title="Parameters of VmaAllocation objects, that can be retrieved using function vmaGetAllocationInfo().">VmaAllocationInfo</a> structure while creating your resource, from function <a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="group__group__alloc.html#gaa76142ae43535c862ad9e194a6e38aaa" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>. You can remember it if you are sure parameters don't change (e.g. due to defragmentation). </p>

</div>
</div>
<a id="gaf6785483eda8b53561437e05e2177d7b" name="gaf6785483eda8b53561437e05e2177d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6785483eda8b53561437e05e2177d7b">&#9670;&#160;</a></span>vmaGetAllocationMemoryProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE void VMA_CALL_POST vmaGetAllocationMemoryProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkMemoryPropertyFlags *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an allocation, returns Property Flags of its memory type. </p>
<p>This is just a convenience function. Same information can be obtained using <a class="el" href="group__group__alloc.html#gab9c96ca6bb55ad9069829fe8355bbb79" title="Returns current information about specified allocation.">vmaGetAllocationInfo()</a> + <a class="el" href="group__group__init.html#ga33698c6107c0da349c1dbf43615284df">vmaGetMemoryProperties()</a>. </p>

</div>
</div>
<a id="ga77b2f609887eabcc36ab90e94230acbf" name="ga77b2f609887eabcc36ab90e94230acbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77b2f609887eabcc36ab90e94230acbf">&#9670;&#160;</a></span>vmaGetPoolName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE void VMA_CALL_POST vmaGetPoolName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool.html">VmaPool</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *VMA_NULLABLE *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>ppName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves name of a custom pool. </p>
<p>After the call <code>ppName</code> is either null or points to an internally-owned null-terminated string containing name of the pool that was previously set. The pointer becomes invalid when the pool is destroyed or its name is changed using <a class="el" href="group__group__alloc.html#gac0322f7ac6c6425492aec787397d5597" title="Sets name of a custom pool.">vmaSetPoolName()</a>. </p>

</div>
</div>
<a id="ga1059764930e85ac377a92b5237b5b919" name="ga1059764930e85ac377a92b5237b5b919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1059764930e85ac377a92b5237b5b919">&#9670;&#160;</a></span>vmaInvalidateAllocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaInvalidateAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidates memory of given allocation. </p>
<p>Calls <code>vkInvalidateMappedMemoryRanges()</code> for memory associated with given range of given allocation. It needs to be called before reading from a mapped memory for memory types that are not <code>HOST_COHERENT</code>. Map operation doesn't do that automatically.</p>
<ul>
<li><code>offset</code> must be relative to the beginning of allocation.</li>
<li><code>size</code> can be <code>VK_WHOLE_SIZE</code>. It means all memory from <code>offset</code> the the end of given allocation.</li>
<li><code>offset</code> and <code>size</code> don't have to be aligned. They are internally rounded down/up to multiply of <code>nonCoherentAtomSize</code>.</li>
<li>If <code>size</code> is 0, this call is ignored.</li>
<li>If memory type that the <code>allocation</code> belongs to is not <code>HOST_VISIBLE</code> or it is <code>HOST_COHERENT</code>, this call is ignored.</li>
</ul>
<p>Warning! <code>offset</code> and <code>size</code> are relative to the contents of given <code>allocation</code>. If you mean whole allocation, you can pass 0 and <code>VK_WHOLE_SIZE</code>, respectively. Do not pass allocation's offset as <code>offset</code>!!!</p>
<p>This function returns the <code>VkResult</code> from <code>vkInvalidateMappedMemoryRanges</code> if it is called, otherwise <code>VK_SUCCESS</code>. </p>

</div>
</div>
<a id="ga693a1ae5faed72fac89f12685e1d366f" name="ga693a1ae5faed72fac89f12685e1d366f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga693a1ae5faed72fac89f12685e1d366f">&#9670;&#160;</a></span>vmaInvalidateAllocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaInvalidateAllocations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>allocationCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount)&#160;</td>
          <td class="paramname"><em>allocations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount)&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount)&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidates memory of given set of allocations. </p>
<p>Calls <code>vkInvalidateMappedMemoryRanges()</code> for memory associated with given ranges of given allocations. For more information, see documentation of <a class="el" href="group__group__alloc.html#ga1059764930e85ac377a92b5237b5b919" title="Invalidates memory of given allocation.">vmaInvalidateAllocation()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramname">allocationCount</td><td></td></tr>
    <tr><td class="paramname">allocations</td><td></td></tr>
    <tr><td class="paramname">offsets</td><td>If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero. </td></tr>
    <tr><td class="paramname">sizes</td><td>If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means <code>VK_WHOLE_SIZE</code> for all allocations.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the <code>VkResult</code> from <code>vkInvalidateMappedMemoryRanges</code> if it is called, otherwise <code>VK_SUCCESS</code>. </p>

</div>
</div>
<a id="ga13b93ec0ed38ad7232300cb94931c8d2" name="ga13b93ec0ed38ad7232300cb94931c8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13b93ec0ed38ad7232300cb94931c8d2">&#9670;&#160;</a></span>vmaMapMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE VkResult VMA_CALL_POST vmaMapMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *VMA_NULLABLE *VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>ppData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps memory represented by given allocation and returns pointer to it. </p>
<p>Maps memory represented by given allocation to make it accessible to CPU code. When succeeded, <code>*ppData</code> contains pointer to first byte of this memory.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the allocation is part of a bigger <code>VkDeviceMemory</code> block, returned pointer is correctly offsetted to the beginning of region assigned to this particular allocation. Unlike the result of <code>vkMapMemory</code>, it points to the allocation, not to the beginning of the whole block. You should not add <a class="el" href="struct_vma_allocation_info.html#a4a3c732388dbdc7a23f9365b00825268" title="Offset in VkDeviceMemory object to the beginning of this allocation, in bytes. (deviceMemory,...">VmaAllocationInfo::offset</a> to it!</dd></dl>
<p>Mapping is internally reference-counted and synchronized, so despite raw Vulkan function <code>vkMapMemory()</code> cannot be used to map same block of <code>VkDeviceMemory</code> multiple times simultaneously, it is safe to call this function on allocations assigned to the same memory block. Actual Vulkan memory will be mapped on first mapping and unmapped on last unmapping.</p>
<p>If the function succeeded, you must call <a class="el" href="group__group__alloc.html#gaec4645c1787976e2b50d2dfd31279a2b" title="Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().">vmaUnmapMemory()</a> to unmap the allocation when mapping is no longer needed or before freeing the allocation, at the latest.</p>
<p>It also safe to call this function multiple times on the same allocation. You must call <a class="el" href="group__group__alloc.html#gaec4645c1787976e2b50d2dfd31279a2b" title="Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().">vmaUnmapMemory()</a> same number of times as you called <a class="el" href="group__group__alloc.html#ga13b93ec0ed38ad7232300cb94931c8d2" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>.</p>
<p>It is also safe to call this function on allocation created with <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a> flag. Its memory stays mapped all the time. You must still call <a class="el" href="group__group__alloc.html#gaec4645c1787976e2b50d2dfd31279a2b" title="Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().">vmaUnmapMemory()</a> same number of times as you called <a class="el" href="group__group__alloc.html#ga13b93ec0ed38ad7232300cb94931c8d2" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>. You must not call <a class="el" href="group__group__alloc.html#gaec4645c1787976e2b50d2dfd31279a2b" title="Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().">vmaUnmapMemory()</a> additional time to free the "0-th" mapping made automatically due to <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a> flag.</p>
<p>This function fails when used on allocation made in memory type that is not <code>HOST_VISIBLE</code>.</p>
<p>This function doesn't automatically flush or invalidate caches. If the allocation is made from a memory types that is not <code>HOST_COHERENT</code>, you also need to use <a class="el" href="group__group__alloc.html#ga1059764930e85ac377a92b5237b5b919" title="Invalidates memory of given allocation.">vmaInvalidateAllocation()</a> / <a class="el" href="group__group__alloc.html#gab8093faf3afb114596d964d4bd24cb4a" title="Flushes memory of given allocation.">vmaFlushAllocation()</a>, as required by Vulkan specification. </p>

</div>
</div>
<a id="ga29b210b1f39e49de844fc7b6944736d7" name="ga29b210b1f39e49de844fc7b6944736d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29b210b1f39e49de844fc7b6944736d7">&#9670;&#160;</a></span>vmaSetAllocationName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE void VMA_CALL_POST vmaSetAllocationName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *VMA_NULLABLE&#160;</td>
          <td class="paramname"><em>pName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets pName in given allocation to new value. </p>
<p><code>pName</code> must be either null, or pointer to a null-terminated string. The function makes local copy of the string and sets it as allocation's <code>pName</code>. String passed as pName doesn't need to be valid for whole lifetime of the allocation - you can free it after this call. String previously pointed by allocation's <code>pName</code> is freed from memory. </p>

</div>
</div>
<a id="gac1f392a3c70a647f0c53a9ddaa7a6f14" name="gac1f392a3c70a647f0c53a9ddaa7a6f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1f392a3c70a647f0c53a9ddaa7a6f14">&#9670;&#160;</a></span>vmaSetAllocationUserData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE void VMA_CALL_POST vmaSetAllocationUserData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *VMA_NULLABLE&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets pUserData in given allocation to new value. </p>
<p>The value of pointer <code>pUserData</code> is copied to allocation's <code>pUserData</code>. It is opaque, so you can use it however you want - e.g. as a pointer, ordinal number or some handle to you own data. </p>

</div>
</div>
<a id="gac0322f7ac6c6425492aec787397d5597" name="gac0322f7ac6c6425492aec787397d5597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0322f7ac6c6425492aec787397d5597">&#9670;&#160;</a></span>vmaSetPoolName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE void VMA_CALL_POST vmaSetPoolName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool.html">VmaPool</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *VMA_NULLABLE&#160;</td>
          <td class="paramname"><em>pName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets name of a custom pool. </p>
<p><code>pName</code> can be either null or pointer to a null-terminated string with new name for the pool. Function makes internal copy of the string, so it can be changed or freed immediately after this call. </p>

</div>
</div>
<a id="gaec4645c1787976e2b50d2dfd31279a2b" name="gaec4645c1787976e2b50d2dfd31279a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec4645c1787976e2b50d2dfd31279a2b">&#9670;&#160;</a></span>vmaUnmapMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VMA_CALL_PRE void VMA_CALL_POST vmaUnmapMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> VMA_NOT_NULL&#160;</td>
          <td class="paramname"><em>allocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmaps memory represented by given allocation, mapped previously using <a class="el" href="group__group__alloc.html#ga13b93ec0ed38ad7232300cb94931c8d2" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>. </p>
<p>For details, see description of <a class="el" href="group__group__alloc.html#ga13b93ec0ed38ad7232300cb94931c8d2" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>.</p>
<p>This function doesn't automatically flush or invalidate caches. If the allocation is made from a memory types that is not <code>HOST_COHERENT</code>, you also need to use <a class="el" href="group__group__alloc.html#ga1059764930e85ac377a92b5237b5b919" title="Invalidates memory of given allocation.">vmaInvalidateAllocation()</a> / <a class="el" href="group__group__alloc.html#gab8093faf3afb114596d964d4bd24cb4a" title="Flushes memory of given allocation.">vmaFlushAllocation()</a>, as required by Vulkan specification. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 9 2023 13:49:04 for Open 3D Engine Atom Gem API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
