<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine Atom Gem API Reference: Quick start</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-placeholder-text"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine Atom Gem API Reference
   &#160;<span id="projectnumber">24.09</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('quick_start.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Quick start </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="quick_start_project_setup"></a>
Project setup and initialization</h1>
<p>This is a small, standalone C++ library. It consists of a pair of 2 files: "D3D12MemAlloc.h" header file with public interface and "D3D12MemAlloc.cpp" with internal implementation. The only external dependencies are WinAPI, Direct3D 12, and parts of C/C++ standard library (but STL containers, exceptions, or RTTI are not used).</p>
<p>The library is developed and tested using Microsoft Visual Studio 2019, but it should work with other compilers as well. It is designed for 64-bit code.</p>
<p>To use the library in your project:</p>
<p>(1.) Copy files <code>D3D12MemAlloc.cpp</code>, <code>D3D12MemAlloc.h</code> to your project.</p>
<p>(2.) Make <code>D3D12MemAlloc.cpp</code> compiling as part of the project, as C++ code.</p>
<p>(3.) Include library header in each CPP file that needs to use the library.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;D3D12MemAlloc.h&quot;</span></div>
</div><!-- fragment --><p>(4.) Right after you created <code>ID3D12Device</code>, fill <a class="el" href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_o_r___d_e_s_c.html" title="Parameters of created Allocator object. To be used with CreateAllocator().">D3D12MA::ALLOCATOR_DESC</a> structure and call function D3D12MA::CreateAllocator to create the main <a class="el" href="class_d3_d12_m_a_1_1_allocator.html" title="Represents main object of this library initialized for particular ID3D12Device.">D3D12MA::Allocator</a> object.</p>
<p>Please note that all symbols of the library are declared inside #D3D12MA namespace.</p>
<div class="fragment"><div class="line">IDXGIAdapter* adapter = (...)</div>
<div class="line">ID3D12Device* device = (...)</div>
<div class="line"> </div>
<div class="line"><a class="code" href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_o_r___d_e_s_c.html">D3D12MA::ALLOCATOR_DESC</a> allocatorDesc = {};</div>
<div class="line">allocatorDesc.<a class="code" href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_o_r___d_e_s_c.html#ada1bf21205065b3aa0284b5a9ee1cb3c">pDevice</a> = device;</div>
<div class="line">allocatorDesc.<a class="code" href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_o_r___d_e_s_c.html#abf9a9f87f0ffea52816efd363c5fcd7b">pAdapter</a> = adapter;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="class_d3_d12_m_a_1_1_allocator.html">D3D12MA::Allocator</a>* allocator;</div>
<div class="line">HRESULT hr = D3D12MA::CreateAllocator(&amp;allocatorDesc, &amp;allocator);</div>
<div class="ttc" id="aclass_d3_d12_m_a_1_1_allocator_html"><div class="ttname"><a href="class_d3_d12_m_a_1_1_allocator.html">D3D12MA::Allocator</a></div><div class="ttdoc">Represents main object of this library initialized for particular ID3D12Device.</div><div class="ttdef"><b>Definition:</b> D3D12MemAlloc.h:1068</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_o_r___d_e_s_c_html"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_o_r___d_e_s_c.html">D3D12MA::ALLOCATOR_DESC</a></div><div class="ttdoc">Parameters of created Allocator object. To be used with CreateAllocator().</div><div class="ttdef"><b>Definition:</b> D3D12MemAlloc.h:1029</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_o_r___d_e_s_c_html_abf9a9f87f0ffea52816efd363c5fcd7b"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_o_r___d_e_s_c.html#abf9a9f87f0ffea52816efd363c5fcd7b">D3D12MA::ALLOCATOR_DESC::pAdapter</a></div><div class="ttdeci">IDXGIAdapter * pAdapter</div><div class="ttdef"><b>Definition:</b> D3D12MemAlloc.h:1055</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_o_r___d_e_s_c_html_ada1bf21205065b3aa0284b5a9ee1cb3c"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_o_r___d_e_s_c.html#ada1bf21205065b3aa0284b5a9ee1cb3c">D3D12MA::ALLOCATOR_DESC::pDevice</a></div><div class="ttdeci">ID3D12Device * pDevice</div><div class="ttdef"><b>Definition:</b> D3D12MemAlloc.h:1037</div></div>
</div><!-- fragment --><p>(5.) Right before destroying the D3D12 device, destroy the allocator object.</p>
<p>Objects of this library must be destroyed by calling <code>Release</code> method. They are somewhat compatible with COM: they implement <code>IUnknown</code> interface with its virtual methods: <code>AddRef</code>, <code>Release</code>, <code>QueryInterface</code>, and they are reference-counted internally. You can use smart pointers designed for COM with objects of this library - e.g. <code>CComPtr</code> or <code>Microsoft::WRL::ComPtr</code>. The reference counter is thread-safe. <code>QueryInterface</code> method supports only <code>IUnknown</code>, as classes of this library don't define their own GUIDs.</p>
<div class="fragment"><div class="line">allocator-&gt;Release();</div>
</div><!-- fragment --><h1><a class="anchor" id="quick_start_creating_resources"></a>
Creating resources</h1>
<p>To use the library for creating resources (textures and buffers), call method <a class="el" href="class_d3_d12_m_a_1_1_allocator.html#aa37d6b9fe8ea0864f7a35b9d68e8345a" title="Allocates memory and creates a D3D12 resource (buffer or texture). This is the main allocation functi...">D3D12MA::Allocator::CreateResource</a> in the place where you would previously call <code>ID3D12Device::CreateCommittedResource</code>.</p>
<p>The function has similar syntax, but it expects structure <a class="el" href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html" title="Parameters of created D3D12MA::Allocation object. To be used with Allocator::CreateResource.">D3D12MA::ALLOCATION_DESC</a> to be passed along with <code>D3D12_RESOURCE_DESC</code> and other parameters for created resource. This structure describes parameters of the desired memory allocation, including choice of <code>D3D12_HEAP_TYPE</code>.</p>
<p>The function returns a new object of type <a class="el" href="class_d3_d12_m_a_1_1_allocation.html" title="Represents single memory allocation.">D3D12MA::Allocation</a>. It represents allocated memory and can be queried for size, offset, <code>ID3D12Heap</code>. It also holds a reference to the <code>ID3D12Resource</code>, which can be accessed by calling <a class="el" href="class_d3_d12_m_a_1_1_allocation.html#a649a3bb1be1a981cbf3f61f3819addca" title="Returns D3D12 resource associated with this object.">D3D12MA::Allocation::GetResource()</a>.</p>
<div class="fragment"><div class="line">D3D12_RESOURCE_DESC resourceDesc = {};</div>
<div class="line">resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;</div>
<div class="line">resourceDesc.Alignment = 0;</div>
<div class="line">resourceDesc.Width = 1024;</div>
<div class="line">resourceDesc.Height = 1024;</div>
<div class="line">resourceDesc.DepthOrArraySize = 1;</div>
<div class="line">resourceDesc.MipLevels = 1;</div>
<div class="line">resourceDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;</div>
<div class="line">resourceDesc.SampleDesc.Count = 1;</div>
<div class="line">resourceDesc.SampleDesc.Quality = 0;</div>
<div class="line">resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;</div>
<div class="line">resourceDesc.Flags = D3D12_RESOURCE_FLAG_NONE;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html">D3D12MA::ALLOCATION_DESC</a> allocationDesc = {};</div>
<div class="line">allocationDesc.<a class="code" href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html#aa46b3c0456e5a23edef3328607ebf4d7">HeapType</a> = D3D12_HEAP_TYPE_DEFAULT;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="class_d3_d12_m_a_1_1_allocation.html">D3D12MA::Allocation</a>* allocation;</div>
<div class="line">HRESULT hr = allocator-&gt;<a class="code" href="class_d3_d12_m_a_1_1_allocator.html#aa37d6b9fe8ea0864f7a35b9d68e8345a">CreateResource</a>(</div>
<div class="line">    &amp;allocationDesc,</div>
<div class="line">    &amp;resourceDesc,</div>
<div class="line">    D3D12_RESOURCE_STATE_COPY_DEST,</div>
<div class="line">    NULL,</div>
<div class="line">    &amp;allocation,</div>
<div class="line">    IID_NULL, NULL);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use allocation-&gt;GetResource()...</span></div>
<div class="ttc" id="aclass_d3_d12_m_a_1_1_allocation_html"><div class="ttname"><a href="class_d3_d12_m_a_1_1_allocation.html">D3D12MA::Allocation</a></div><div class="ttdoc">Represents single memory allocation.</div><div class="ttdef"><b>Definition:</b> D3D12MemAlloc.h:462</div></div>
<div class="ttc" id="aclass_d3_d12_m_a_1_1_allocator_html_aa37d6b9fe8ea0864f7a35b9d68e8345a"><div class="ttname"><a href="class_d3_d12_m_a_1_1_allocator.html#aa37d6b9fe8ea0864f7a35b9d68e8345a">D3D12MA::Allocator::CreateResource</a></div><div class="ttdeci">HRESULT CreateResource(const ALLOCATION_DESC *pAllocDesc, const D3D12_RESOURCE_DESC *pResourceDesc, D3D12_RESOURCE_STATES InitialResourceState, const D3D12_CLEAR_VALUE *pOptimizedClearValue, Allocation **ppAllocation, REFIID riidResource, void **ppvResource)</div><div class="ttdoc">Allocates memory and creates a D3D12 resource (buffer or texture). This is the main allocation functi...</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_i_o_n___d_e_s_c_html"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html">D3D12MA::ALLOCATION_DESC</a></div><div class="ttdoc">Parameters of created D3D12MA::Allocation object. To be used with Allocator::CreateResource.</div><div class="ttdef"><b>Definition:</b> D3D12MemAlloc.h:278</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_i_o_n___d_e_s_c_html_aa46b3c0456e5a23edef3328607ebf4d7"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html#aa46b3c0456e5a23edef3328607ebf4d7">D3D12MA::ALLOCATION_DESC::HeapType</a></div><div class="ttdeci">D3D12_HEAP_TYPE HeapType</div><div class="ttdoc">The type of memory heap where the new allocation should be placed.</div><div class="ttdef"><b>Definition:</b> D3D12MemAlloc.h:287</div></div>
</div><!-- fragment --><p>You need to release the allocation object when no longer needed. This will also release the D3D12 resource.</p>
<div class="fragment"><div class="line">allocation-&gt;Release();</div>
</div><!-- fragment --><p>The advantage of using the allocator instead of creating committed resource, and the main purpose of this library, is that it can decide to allocate bigger memory heap internally using <code>ID3D12Device::CreateHeap</code> and place multiple resources in it, at different offsets, using <code>ID3D12Device::CreatePlacedResource</code>. The library manages its own collection of allocated memory blocks (heaps) and remembers which parts of them are occupied and which parts are free to be used for new resources.</p>
<p>It is important to remember that resources created as placed don't have their memory initialized to zeros, but may contain garbage data, so they need to be fully initialized before usage, e.g. using Clear (<code>ClearRenderTargetView</code>), Discard (<code>DiscardResource</code>), or copy (<code>CopyResource</code>).</p>
<p>The library also automatically handles resource heap tier. When <code>D3D12_FEATURE_DATA_D3D12_OPTIONS::ResourceHeapTier</code> equals <code>D3D12_RESOURCE_HEAP_TIER_1</code>, resources of 3 types: buffers, textures that are render targets or depth-stencil, and other textures must be kept in separate heaps. When <code>D3D12_RESOURCE_HEAP_TIER_2</code>, they can be kept together. By using this library, you don't need to handle this manually.</p>
<h1><a class="anchor" id="quick_start_resource_reference_counting"></a>
Resource reference counting</h1>
<p><code>ID3D12Resource</code> and other interfaces of Direct3D 12 use COM, so they are reference-counted. Objects of this library are reference-counted as well. An object of type <a class="el" href="class_d3_d12_m_a_1_1_allocation.html" title="Represents single memory allocation.">D3D12MA::Allocation</a> remembers the resource (buffer or texture) that was created together with this memory allocation and holds a reference to the <code>ID3D12Resource</code> object. (Note this is a difference to Vulkan Memory Allocator, where a <code><a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a></code> object has no connection with the buffer or image that was created with it.) Thus, it is important to manage the resource reference counter properly.</p>
<p><b>The simplest use case</b> is shown in the code snippet above. When only <a class="el" href="class_d3_d12_m_a_1_1_allocation.html" title="Represents single memory allocation.">D3D12MA::Allocation</a> object is obtained from a function call like <a class="el" href="class_d3_d12_m_a_1_1_allocator.html#aa37d6b9fe8ea0864f7a35b9d68e8345a" title="Allocates memory and creates a D3D12 resource (buffer or texture). This is the main allocation functi...">D3D12MA::Allocator::CreateResource</a>, it remembers the <code>ID3D12Resource</code> that was created with it and holds a reference to it. The resource can be obtained by calling <code>allocation-&gt;GetResource()</code>, which doesn't increment the resource reference counter. Calling <code>allocation-&gt;Release()</code> will decrease the resource reference counter, which is = 1 in this case, so the resource will be released.</p>
<p><b>Second option</b> is to retrieve a pointer to the resource along with <a class="el" href="class_d3_d12_m_a_1_1_allocation.html" title="Represents single memory allocation.">D3D12MA::Allocation</a>. Last parameters of the resource creation function can be used for this purpose.</p>
<div class="fragment"><div class="line"><a class="code" href="class_d3_d12_m_a_1_1_allocation.html">D3D12MA::Allocation</a>* allocation;</div>
<div class="line">ID3D12Resource* resource;</div>
<div class="line">HRESULT hr = allocator-&gt;<a class="code" href="class_d3_d12_m_a_1_1_allocator.html#aa37d6b9fe8ea0864f7a35b9d68e8345a">CreateResource</a>(</div>
<div class="line">    &amp;allocationDesc,</div>
<div class="line">    &amp;resourceDesc,</div>
<div class="line">    D3D12_RESOURCE_STATE_COPY_DEST,</div>
<div class="line">    NULL,</div>
<div class="line">    &amp;allocation,</div>
<div class="line">    IID_PPV_ARGS(&amp;resource));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use resource...</span></div>
</div><!-- fragment --><p>In this case, returned pointer <code>resource</code> is equal to <code>allocation-&gt;GetResource()</code>, but the creation function additionally increases resource reference counter for the purpose of returning it from this call (it actually calls <code>QueryInterface</code> internally), so the resource will have the counter = 2. The resource then need to be released along with the allocation, in this particular order, to make sure the resource is destroyed before its memory heap can potentially be freed.</p>
<div class="fragment"><div class="line">resource-&gt;Release();</div>
<div class="line">allocation-&gt;Release();</div>
</div><!-- fragment --><p><b>More advanced use cases</b> are possible when we consider that an <a class="el" href="class_d3_d12_m_a_1_1_allocation.html" title="Represents single memory allocation.">D3D12MA::Allocation</a> object can just hold a reference to any resource. It can be changed by calling <a class="el" href="class_d3_d12_m_a_1_1_allocation.html#a414a088c22bae0f29b1038f5f9346d14" title="Releases the resource currently pointed by the allocation (if any), sets it to new one,...">D3D12MA::Allocation::SetResource</a>. This function releases the old resource and calls <code>AddRef</code> on the new one.</p>
<p>Special care must be taken when performing <b>defragmentation</b>. The new resource created at the destination place should be set as <code>pass.pMoves[i].pDstTmpAllocation-&gt;SetResource(newRes)</code>, but it is moved to the source allocation at end of the defragmentation pass, while the old resource accessible through <code>pass.pMoves[i].pSrcAllocation-&gt;GetResource()</code> is then released. For more information, see documentation chapter <a class="el" href="defragmentation.html">Defragmentation</a>.</p>
<h1><a class="anchor" id="quick_start_mapping_memory"></a>
Mapping memory</h1>
<p>The process of getting regular CPU-side pointer to the memory of a resource in Direct3D is called "mapping". There are rules and restrictions to this process, as described in D3D12 documentation of <code>ID3D12Resource::Map</code> method.</p>
<p>Mapping happens on the level of particular resources, not entire memory heaps, and so it is out of scope of this library. Just as the documentation of the <code>Map</code> function says:</p>
<ul>
<li>Returned pointer refers to data of particular subresource, not entire memory heap.</li>
<li>You can map same resource multiple times. It is ref-counted internally.</li>
<li>Mapping is thread-safe.</li>
<li>Unmapping is not required before resource destruction.</li>
<li>Unmapping may not be required before using written data - some heap types on some platforms support resources persistently mapped.</li>
</ul>
<p>When using this library, you can map and use your resources normally without considering whether they are created as committed resources or placed resources in one large heap.</p>
<p>Example for buffer created and filled in <code>UPLOAD</code> heap type:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> UINT64 bufSize = 65536;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span>* bufData = (...);</div>
<div class="line"> </div>
<div class="line">D3D12_RESOURCE_DESC resourceDesc = {};</div>
<div class="line">resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;</div>
<div class="line">resourceDesc.Alignment = 0;</div>
<div class="line">resourceDesc.Width = bufSize;</div>
<div class="line">resourceDesc.Height = 1;</div>
<div class="line">resourceDesc.DepthOrArraySize = 1;</div>
<div class="line">resourceDesc.MipLevels = 1;</div>
<div class="line">resourceDesc.Format = DXGI_FORMAT_UNKNOWN;</div>
<div class="line">resourceDesc.SampleDesc.Count = 1;</div>
<div class="line">resourceDesc.SampleDesc.Quality = 0;</div>
<div class="line">resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;</div>
<div class="line">resourceDesc.Flags = D3D12_RESOURCE_FLAG_NONE;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html">D3D12MA::ALLOCATION_DESC</a> allocationDesc = {};</div>
<div class="line">allocationDesc.<a class="code" href="struct_d3_d12_m_a_1_1_a_l_l_o_c_a_t_i_o_n___d_e_s_c.html#aa46b3c0456e5a23edef3328607ebf4d7">HeapType</a> = D3D12_HEAP_TYPE_UPLOAD;</div>
<div class="line"> </div>
<div class="line">D3D12Resource* resource;</div>
<div class="line"><a class="code" href="class_d3_d12_m_a_1_1_allocation.html">D3D12MA::Allocation</a>* allocation;</div>
<div class="line">HRESULT hr = allocator-&gt;<a class="code" href="class_d3_d12_m_a_1_1_allocator.html#aa37d6b9fe8ea0864f7a35b9d68e8345a">CreateResource</a>(</div>
<div class="line">    &amp;allocationDesc,</div>
<div class="line">    &amp;resourceDesc,</div>
<div class="line">    D3D12_RESOURCE_STATE_GENERIC_READ,</div>
<div class="line">    NULL,</div>
<div class="line">    &amp;allocation,</div>
<div class="line">    IID_PPV_ARGS(&amp;resource));</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span>* mappedPtr;</div>
<div class="line">hr = resource-&gt;Map(0, NULL, &amp;mappedPtr);</div>
<div class="line"> </div>
<div class="line">memcpy(mappedPtr, bufData, bufSize);</div>
<div class="line"> </div>
<div class="line">resource-&gt;Unmap(0, NULL);</div>
</div><!-- fragment --><h1><a class="anchor" id="quick_start_project_setup"></a>
Project setup and initialization</h1>
<p>Vulkan Memory Allocator comes in form of a "stb-style" single header file. You don't need to build it as a separate library project. You can add this file directly to your project and submit it to code repository next to your other source files.</p>
<p>"Single header" doesn't mean that everything is contained in C/C++ declarations, like it tends to be in case of inline functions or C++ templates. It means that implementation is bundled with interface in a single file and needs to be extracted using preprocessor macro. If you don't do it properly, you will get linker errors.</p>
<p>To do it properly:</p>
<ol type="1">
<li>Include "vk_mem_alloc.h" file in each CPP file where you want to use the library. This includes declarations of all members of the library.</li>
<li>In exactly one CPP file define following macro before this include. It enables also internal definitions.</li>
</ol>
<div class="fragment"><div class="line"><span class="preprocessor">#define VMA_IMPLEMENTATION</span></div>
<div class="line"><span class="preprocessor">#include &quot;vk_mem_alloc.h&quot;</span></div>
</div><!-- fragment --><p>It may be a good idea to create dedicated CPP file just for this purpose.</p>
<p>This library includes header <code>&lt;vulkan/vulkan.h&gt;</code>, which in turn includes <code>&lt;windows.h&gt;</code> on Windows. If you need some specific macros defined before including these headers (like <code>WIN32_LEAN_AND_MEAN</code> or <code>WINVER</code> for Windows, <code>VK_USE_PLATFORM_WIN32_KHR</code> for Vulkan), you must define them before every <code>#include</code> of this library.</p>
<p>This library is written in C++, but has C-compatible interface. Thus you can include and use vk_mem_alloc.h in C or C++ code, but full implementation with <code>VMA_IMPLEMENTATION</code> macro must be compiled as C++, NOT as C. Some features of C++14 are used. STL containers, RTTI, or C++ exceptions are not used.</p>
<h1><a class="anchor" id="quick_start_initialization"></a>
Initialization</h1>
<p>At program startup:</p>
<ol type="1">
<li>Initialize Vulkan to have <code>VkPhysicalDevice</code>, <code>VkDevice</code> and <code>VkInstance</code> object.</li>
<li>Fill <a class="el" href="struct_vma_allocator_create_info.html" title="Description of a Allocator to be created.">VmaAllocatorCreateInfo</a> structure and create <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a> object by calling <a class="el" href="group__group__init.html#gaf77c946fbecfcc54d02c3d1c1e7e23e7" title="Creates VmaAllocator object.">vmaCreateAllocator()</a>.</li>
</ol>
<p>Only members <code>physicalDevice</code>, <code>device</code>, <code>instance</code> are required. However, you should inform the library which Vulkan version do you use by setting <a class="el" href="struct_vma_allocator_create_info.html#ae0ffc55139b54520a6bb704b29ffc285" title="Optional. The highest version of Vulkan that the application is designed to use.">VmaAllocatorCreateInfo::vulkanApiVersion</a> and which extensions did you enable by setting <a class="el" href="struct_vma_allocator_create_info.html#a392ea2ecbaff93f91a7c49f735ad4346" title="Flags for created allocator. Use VmaAllocatorCreateFlagBits enum.">VmaAllocatorCreateInfo::flags</a> (like <a class="el" href="group__group__init.html#gga4f87c9100d154a65a4ad495f7763cf7ca5f1b28b0414319d1687e1f2b30ab0089">VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</a> for VK_KHR_buffer_device_address). Otherwise, VMA would use only features of Vulkan 1.0 core with no extensions.</p>
<h2><a class="anchor" id="quick_start_initialization_selecting_vulkan_version"></a>
Selecting Vulkan version</h2>
<p>VMA supports Vulkan version down to 1.0, for backward compatibility. If you want to use higher version, you need to inform the library about it. This is a two-step process.</p>
<p><b>Step 1: Compile time.</b> By default, VMA compiles with code supporting the highest Vulkan version found in the included <code>&lt;vulkan/vulkan.h&gt;</code> that is also supported by the library. If this is OK, you don't need to do anything. However, if you want to compile VMA as if only some lower Vulkan version was available, define macro <code>VMA_VULKAN_VERSION</code> before every <code>#include "vk_mem_alloc.h"</code>. It should have decimal numeric value in form of ABBBCCC, where A = major, BBB = minor, CCC = patch Vulkan version. For example, to compile against Vulkan 1.2:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define VMA_VULKAN_VERSION 1002000 </span><span class="comment">// Vulkan 1.2</span></div>
<div class="line">#include &quot;vk_mem_alloc.h&quot;</div>
</div><!-- fragment --><p><b>Step 2: Runtime.</b> Even when compiled with higher Vulkan version available, VMA can use only features of a lower version, which is configurable during creation of the <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a> object. By default, only Vulkan 1.0 is used. To initialize the allocator with support for higher Vulkan version, you need to set member <a class="el" href="struct_vma_allocator_create_info.html#ae0ffc55139b54520a6bb704b29ffc285" title="Optional. The highest version of Vulkan that the application is designed to use.">VmaAllocatorCreateInfo::vulkanApiVersion</a> to an appropriate value, e.g. using constants like <code>VK_API_VERSION_1_2</code>. See code sample below.</p>
<h2><a class="anchor" id="quick_start_initialization_importing_vulkan_functions"></a>
Importing Vulkan functions</h2>
<p>You may need to configure importing Vulkan functions. There are 3 ways to do this:</p>
<ol type="1">
<li><b>If you link with Vulkan static library</b> (e.g. "vulkan-1.lib" on Windows):<ul>
<li>You don't need to do anything.</li>
<li>VMA will use these, as macro <code>VMA_STATIC_VULKAN_FUNCTIONS</code> is defined to 1 by default.</li>
</ul>
</li>
<li><b>If you want VMA to fetch pointers to Vulkan functions dynamically</b> using <code>vkGetInstanceProcAddr</code>, <code>vkGetDeviceProcAddr</code> (this is the option presented in the example below):<ul>
<li>Define <code>VMA_STATIC_VULKAN_FUNCTIONS</code> to 0, <code>VMA_DYNAMIC_VULKAN_FUNCTIONS</code> to 1.</li>
<li>Provide pointers to these two functions via <a class="el" href="struct_vma_vulkan_functions.html#a2ee50e592de96365bd2a56885d04a20e" title="Required when using VMA_DYNAMIC_VULKAN_FUNCTIONS.">VmaVulkanFunctions::vkGetInstanceProcAddr</a>, <a class="el" href="struct_vma_vulkan_functions.html#a5619d8409f652f337efd902a9f5470df" title="Required when using VMA_DYNAMIC_VULKAN_FUNCTIONS.">VmaVulkanFunctions::vkGetDeviceProcAddr</a>.</li>
<li>The library will fetch pointers to all other functions it needs internally.</li>
</ul>
</li>
<li><b>If you fetch pointers to all Vulkan functions in a custom way</b>, e.g. using some loader like <a href="https://github.com/zeux/volk">Volk</a>:<ul>
<li>Define <code>VMA_STATIC_VULKAN_FUNCTIONS</code> and <code>VMA_DYNAMIC_VULKAN_FUNCTIONS</code> to 0.</li>
<li>Pass these pointers via structure <a class="el" href="struct_vma_vulkan_functions.html" title="Pointers to some Vulkan functions - a subset used by the library.">VmaVulkanFunctions</a>.</li>
</ul>
</li>
</ol>
<p>Example for case 2:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define VMA_STATIC_VULKAN_FUNCTIONS 0</span></div>
<div class="line"><span class="preprocessor">#define VMA_DYNAMIC_VULKAN_FUNCTIONS 1</span></div>
<div class="line"><span class="preprocessor">#include &quot;vk_mem_alloc.h&quot;</span></div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">VmaVulkanFunctions vulkanFunctions = {};</div>
<div class="line">vulkanFunctions.vkGetInstanceProcAddr = &amp;vkGetInstanceProcAddr;</div>
<div class="line">vulkanFunctions.vkGetDeviceProcAddr = &amp;vkGetDeviceProcAddr;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="struct_vma_allocator_create_info.html">VmaAllocatorCreateInfo</a> allocatorCreateInfo = {};</div>
<div class="line">allocatorCreateInfo.<a class="code" href="struct_vma_allocator_create_info.html#ae0ffc55139b54520a6bb704b29ffc285">vulkanApiVersion</a> = VK_API_VERSION_1_2;</div>
<div class="line">allocatorCreateInfo.<a class="code" href="struct_vma_allocator_create_info.html#ad09ce637aa92cb7c8c2a742943668087">physicalDevice</a> = physicalDevice;</div>
<div class="line">allocatorCreateInfo.<a class="code" href="struct_vma_allocator_create_info.html#ac35aa355d3bfcbf6bb2eb88ccf68125c">device</a> = device;</div>
<div class="line">allocatorCreateInfo.<a class="code" href="struct_vma_allocator_create_info.html#aa2d4e3d86e6828834a56cf9f9406149a">instance</a> = instance;</div>
<div class="line">allocatorCreateInfo.<a class="code" href="struct_vma_allocator_create_info.html#a5e45da0879451e58bee2f3a975f228f5">pVulkanFunctions</a> = &amp;vulkanFunctions;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="struct_vma_allocator.html">VmaAllocator</a> allocator;</div>
<div class="line"><a class="code" href="group__group__init.html#gaf77c946fbecfcc54d02c3d1c1e7e23e7">vmaCreateAllocator</a>(&amp;allocatorCreateInfo, &amp;allocator);</div>
<div class="ttc" id="agroup__group__init_html_gaf77c946fbecfcc54d02c3d1c1e7e23e7"><div class="ttname"><a href="group__group__init.html#gaf77c946fbecfcc54d02c3d1c1e7e23e7">vmaCreateAllocator</a></div><div class="ttdeci">VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateAllocator(const VmaAllocatorCreateInfo *VMA_NOT_NULL pCreateInfo, VmaAllocator VMA_NULLABLE *VMA_NOT_NULL pAllocator)</div><div class="ttdoc">Creates VmaAllocator object.</div></div>
<div class="ttc" id="astruct_vma_allocator_create_info_html"><div class="ttname"><a href="struct_vma_allocator_create_info.html">VmaAllocatorCreateInfo</a></div><div class="ttdoc">Description of a Allocator to be created.</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:998</div></div>
<div class="ttc" id="astruct_vma_allocator_create_info_html_a5e45da0879451e58bee2f3a975f228f5"><div class="ttname"><a href="struct_vma_allocator_create_info.html#a5e45da0879451e58bee2f3a975f228f5">VmaAllocatorCreateInfo::pVulkanFunctions</a></div><div class="ttdeci">const VmaVulkanFunctions *VMA_NULLABLE pVulkanFunctions</div><div class="ttdoc">Pointers to Vulkan functions. Can be null.</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:1046</div></div>
<div class="ttc" id="astruct_vma_allocator_create_info_html_aa2d4e3d86e6828834a56cf9f9406149a"><div class="ttname"><a href="struct_vma_allocator_create_info.html#aa2d4e3d86e6828834a56cf9f9406149a">VmaAllocatorCreateInfo::instance</a></div><div class="ttdeci">VkInstance VMA_NOT_NULL instance</div><div class="ttdoc">Handle to Vulkan instance object.</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:1051</div></div>
<div class="ttc" id="astruct_vma_allocator_create_info_html_ac35aa355d3bfcbf6bb2eb88ccf68125c"><div class="ttname"><a href="struct_vma_allocator_create_info.html#ac35aa355d3bfcbf6bb2eb88ccf68125c">VmaAllocatorCreateInfo::device</a></div><div class="ttdeci">VkDevice VMA_NOT_NULL device</div><div class="ttdoc">Vulkan device.</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:1006</div></div>
<div class="ttc" id="astruct_vma_allocator_create_info_html_ad09ce637aa92cb7c8c2a742943668087"><div class="ttname"><a href="struct_vma_allocator_create_info.html#ad09ce637aa92cb7c8c2a742943668087">VmaAllocatorCreateInfo::physicalDevice</a></div><div class="ttdeci">VkPhysicalDevice VMA_NOT_NULL physicalDevice</div><div class="ttdoc">Vulkan physical device.</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:1003</div></div>
<div class="ttc" id="astruct_vma_allocator_create_info_html_ae0ffc55139b54520a6bb704b29ffc285"><div class="ttname"><a href="struct_vma_allocator_create_info.html#ae0ffc55139b54520a6bb704b29ffc285">VmaAllocatorCreateInfo::vulkanApiVersion</a></div><div class="ttdeci">uint32_t vulkanApiVersion</div><div class="ttdoc">Optional. The highest version of Vulkan that the application is designed to use.</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:1060</div></div>
<div class="ttc" id="astruct_vma_allocator_html"><div class="ttname"><a href="struct_vma_allocator.html">VmaAllocator</a></div><div class="ttdoc">Represents main object of this library initialized.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="quick_start_resource_allocation"></a>
Resource allocation</h1>
<p>When you want to create a buffer or image:</p>
<ol type="1">
<li>Fill <code><a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a></code> / <code><a class="el" href="struct_vk_image_create_info.html">VkImageCreateInfo</a></code> structure.</li>
<li>Fill <a class="el" href="struct_vma_allocation_create_info.html" title="Parameters of new VmaAllocation.">VmaAllocationCreateInfo</a> structure.</li>
<li>Call <a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a> / <a class="el" href="group__group__alloc.html#gaa76142ae43535c862ad9e194a6e38aaa" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a> to get <code>VkBuffer</code>/<code>VkImage</code> with memory already allocated and bound to it, plus <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a> objects that represents its underlying memory.</li>
</ol>
<div class="fragment"><div class="line"><a class="code" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a> bufferInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };</div>
<div class="line">bufferInfo.size = 65536;</div>
<div class="line">bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> allocInfo = {};</div>
<div class="line">allocInfo.<a class="code" href="struct_vma_allocation_create_info.html#accb8b06b1f677d858cb9af20705fa910">usage</a> = <a class="code" href="group__group__alloc.html#ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e">VMA_MEMORY_USAGE_AUTO</a>;</div>
<div class="line"> </div>
<div class="line">VkBuffer buffer;</div>
<div class="line"><a class="code" href="struct_vma_allocation.html">VmaAllocation</a> allocation;</div>
<div class="line"><a class="code" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9">vmaCreateBuffer</a>(allocator, &amp;bufferInfo, &amp;allocInfo, &amp;buffer, &amp;allocation, <span class="keyword">nullptr</span>);</div>
<div class="ttc" id="agroup__group__alloc_html_gae9773fe0ef8582e23136d2d83c336ab9"><div class="ttname"><a href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9">vmaCreateBuffer</a></div><div class="ttdeci">VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateBuffer(VmaAllocator VMA_NOT_NULL allocator, const VkBufferCreateInfo *VMA_NOT_NULL pBufferCreateInfo, const VmaAllocationCreateInfo *VMA_NOT_NULL pAllocationCreateInfo, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pBuffer, VmaAllocation VMA_NULLABLE *VMA_NOT_NULL pAllocation, VmaAllocationInfo *VMA_NULLABLE pAllocationInfo)</div><div class="ttdoc">Creates a new VkBuffer, allocates and binds memory for it.</div></div>
<div class="ttc" id="agroup__group__alloc_html_ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e"><div class="ttname"><a href="group__group__alloc.html#ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e">VMA_MEMORY_USAGE_AUTO</a></div><div class="ttdeci">@ VMA_MEMORY_USAGE_AUTO</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:489</div></div>
<div class="ttc" id="astruct_vk_buffer_create_info_html"><div class="ttname"><a href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan.h:9995</div></div>
<div class="ttc" id="astruct_vma_allocation_create_info_html"><div class="ttname"><a href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a></div><div class="ttdoc">Parameters of new VmaAllocation.</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:1219</div></div>
<div class="ttc" id="astruct_vma_allocation_create_info_html_accb8b06b1f677d858cb9af20705fa910"><div class="ttname"><a href="struct_vma_allocation_create_info.html#accb8b06b1f677d858cb9af20705fa910">VmaAllocationCreateInfo::usage</a></div><div class="ttdeci">VmaMemoryUsage usage</div><div class="ttdoc">Intended usage of memory.</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:1227</div></div>
<div class="ttc" id="astruct_vma_allocation_html"><div class="ttname"><a href="struct_vma_allocation.html">VmaAllocation</a></div><div class="ttdoc">Represents single memory allocation.</div></div>
</div><!-- fragment --><p>Don't forget to destroy your objects when no longer needed:</p>
<div class="fragment"><div class="line"><a class="code" href="group__group__alloc.html#gafcc45e5a6388ab35daa9a46688baee20">vmaDestroyBuffer</a>(allocator, buffer, allocation);</div>
<div class="line"><a class="code" href="group__group__init.html#ga0383c8c957625914e9b89bd165ff13f3">vmaDestroyAllocator</a>(allocator);</div>
<div class="ttc" id="agroup__group__alloc_html_gafcc45e5a6388ab35daa9a46688baee20"><div class="ttname"><a href="group__group__alloc.html#gafcc45e5a6388ab35daa9a46688baee20">vmaDestroyBuffer</a></div><div class="ttdeci">VMA_CALL_PRE void VMA_CALL_POST vmaDestroyBuffer(VmaAllocator VMA_NOT_NULL allocator, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE buffer, VmaAllocation VMA_NULLABLE allocation)</div><div class="ttdoc">Destroys Vulkan buffer and frees allocated memory.</div></div>
<div class="ttc" id="agroup__group__init_html_ga0383c8c957625914e9b89bd165ff13f3"><div class="ttname"><a href="group__group__init.html#ga0383c8c957625914e9b89bd165ff13f3">vmaDestroyAllocator</a></div><div class="ttdeci">VMA_CALL_PRE void VMA_CALL_POST vmaDestroyAllocator(VmaAllocator VMA_NULLABLE allocator)</div><div class="ttdoc">Destroys allocator object.</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 8 2024 21:27:29 for Open 3D Engine Atom Gem API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
