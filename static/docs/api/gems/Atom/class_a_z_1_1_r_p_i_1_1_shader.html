<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine Atom Gem API Reference: AZ::RPI::Shader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Open 3D Engine Atom Gem API Reference<span id="projectnumber">&#160;23.10.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_a_z_1_1_r_p_i_1_1_shader.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_a_z_1_1_r_p_i_1_1_shader-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AZ::RPI::Shader Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;Shader.h&gt;</code></p>

<p>Inherits Data::InstanceData, Data::AssetBus::Handler, and ShaderVariantFinderNotificationBus::Handler.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abf455dc20d9990e545f102c057da5d4e"><td class="memItemLeft" align="right" valign="top"><a id="abf455dc20d9990e545f102c057da5d4e" name="abf455dc20d9990e545f102c057da5d4e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_INSTANCE_DATA</b> (<a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a>, &quot;{232D8BD6-3BD4-4842-ABD2-F380BD5B0863}&quot;)</td></tr>
<tr class="separator:abf455dc20d9990e545f102c057da5d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5132d22dcf956efbfef1e660393cf5e"><td class="memItemLeft" align="right" valign="top"><a id="ae5132d22dcf956efbfef1e660393cf5e" name="ae5132d22dcf956efbfef1e660393cf5e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_CLASS_ALLOCATOR</b> (<a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a>, SystemAllocator)</td></tr>
<tr class="separator:ae5132d22dcf956efbfef1e660393cf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cca2fab422754c10c889ce6b63ac3b"><td class="memItemLeft" align="right" valign="top"><a id="aa7cca2fab422754c10c889ce6b63ac3b" name="aa7cca2fab422754c10c889ce6b63ac3b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_DISABLE_COPY_MOVE</b> (<a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a>)</td></tr>
<tr class="separator:aa7cca2fab422754c10c889ce6b63ac3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181873f00118926b1d752200a07716bf"><td class="memItemLeft" align="right" valign="top"><a id="a181873f00118926b1d752200a07716bf" name="a181873f00118926b1d752200a07716bf"></a>
<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">SupervariantIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetSupervariantIndex</b> () const</td></tr>
<tr class="memdesc:a181873f00118926b1d752200a07716bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the SupervariantIndex that corresponds to the given supervariant name given at instantiation. <br /></td></tr>
<tr class="separator:a181873f00118926b1d752200a07716bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99869e38b85d03c4b1c12d7026c67ef5"><td class="memItemLeft" align="right" valign="top"><a id="a99869e38b85d03c4b1c12d7026c67ef5" name="a99869e38b85d03c4b1c12d7026c67ef5"></a>
<a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_option_group.html">ShaderOptionGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CreateShaderOptionGroup</b> () const</td></tr>
<tr class="memdesc:a99869e38b85d03c4b1c12d7026c67ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a shader option group suitable to generate a shader variant key for this shader. <br /></td></tr>
<tr class="separator:a99869e38b85d03c4b1c12d7026c67ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b800982a3866aac2d7ae5aafc6dec3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#aa7b800982a3866aac2d7ae5aafc6dec3">GetVariant</a> (const <a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_variant_id.html">ShaderVariantId</a> &amp;shaderVariantId)</td></tr>
<tr class="separator:aa7b800982a3866aac2d7ae5aafc6dec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2511e12233eb7c359abb63789632dbc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_variant_search_result.html">ShaderVariantSearchResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#a2511e12233eb7c359abb63789632dbc4">FindVariantStableId</a> (const <a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_variant_id.html">ShaderVariantId</a> &amp;shaderVariantId) const</td></tr>
<tr class="separator:a2511e12233eb7c359abb63789632dbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a02235de720da375c82c5b1abd2947"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#ab8a02235de720da375c82c5b1abd2947">GetVariant</a> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderVariantStableId</a> shaderVariantStableId)</td></tr>
<tr class="separator:ab8a02235de720da375c82c5b1abd2947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0c3563c4a3a22aecf2974760099a60"><td class="memItemLeft" align="right" valign="top"><a id="aea0c3563c4a3a22aecf2974760099a60" name="aea0c3563c4a3a22aecf2974760099a60"></a>
const <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetRootVariant</b> ()</td></tr>
<tr class="memdesc:aea0c3563c4a3a22aecf2974760099a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the root variant. <br /></td></tr>
<tr class="separator:aea0c3563c4a3a22aecf2974760099a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fa65893e413704b726244abcb7c77b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#a37fa65893e413704b726244abcb7c77b">GetDefaultVariant</a> ()</td></tr>
<tr class="separator:a37fa65893e413704b726244abcb7c77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef98f2294736773cc046baf85754532b"><td class="memItemLeft" align="right" valign="top"><a id="aef98f2294736773cc046baf85754532b" name="aef98f2294736773cc046baf85754532b"></a>
<a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_option_group.html">ShaderOptionGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetDefaultShaderOptions</b> () const</td></tr>
<tr class="memdesc:aef98f2294736773cc046baf85754532b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default shader option values. <br /></td></tr>
<tr class="separator:aef98f2294736773cc046baf85754532b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6259837e04ee8b1f81647eaf5c10061c"><td class="memItemLeft" align="right" valign="top"><a id="a6259837e04ee8b1f81647eaf5c10061c" name="a6259837e04ee8b1f81647eaf5c10061c"></a>
RHI::PipelineStateType&#160;</td><td class="memItemRight" valign="bottom"><b>GetPipelineStateType</b> () const</td></tr>
<tr class="memdesc:a6259837e04ee8b1f81647eaf5c10061c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pipeline state type generated by variants of this shader. <br /></td></tr>
<tr class="separator:a6259837e04ee8b1f81647eaf5c10061c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab40f706d3d1e80a88a8097134213f2"><td class="memItemLeft" align="right" valign="top"><a id="abab40f706d3d1e80a88a8097134213f2" name="abab40f706d3d1e80a88a8097134213f2"></a>
const <a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_input_contract.html">ShaderInputContract</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetInputContract</b> () const</td></tr>
<tr class="memdesc:abab40f706d3d1e80a88a8097134213f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_input_contract.html" title="Describes the set of inputs required by a shader.">ShaderInputContract</a> which describes which inputs the shader requires. <br /></td></tr>
<tr class="separator:abab40f706d3d1e80a88a8097134213f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a151b76bb68ee05274c03a30a18246"><td class="memItemLeft" align="right" valign="top"><a id="a27a151b76bb68ee05274c03a30a18246" name="a27a151b76bb68ee05274c03a30a18246"></a>
const <a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_output_contract.html">ShaderOutputContract</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetOutputContract</b> () const</td></tr>
<tr class="memdesc:a27a151b76bb68ee05274c03a30a18246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_output_contract.html" title="Describes the set of outputs required by a shader, which the render pipeline must bind.">ShaderOutputContract</a> which describes which outputs the shader requires. <br /></td></tr>
<tr class="separator:a27a151b76bb68ee05274c03a30a18246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f87493332cbdd3b2cb5f239effe6d1a"><td class="memItemLeft" align="right" valign="top"><a id="a6f87493332cbdd3b2cb5f239effe6d1a" name="a6f87493332cbdd3b2cb5f239effe6d1a"></a>
const <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state.html">RHI::PipelineState</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>AcquirePipelineState</b> (const <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state_descriptor.html">RHI::PipelineStateDescriptor</a> &amp;descriptor) const</td></tr>
<tr class="memdesc:a6f87493332cbdd3b2cb5f239effe6d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires a pipeline state directly from a descriptor. <br /></td></tr>
<tr class="separator:a6f87493332cbdd3b2cb5f239effe6d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8962c04478d59dbaaae16082be1cc9"><td class="memItemLeft" align="right" valign="top"><a id="a4f8962c04478d59dbaaae16082be1cc9" name="a4f8962c04478d59dbaaae16082be1cc9"></a>
const RHI::Ptr&lt; <a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_layout.html">RHI::ShaderResourceGroupLayout</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>FindShaderResourceGroupLayout</b> (const Name &amp;shaderResourceGroupName) const</td></tr>
<tr class="memdesc:a4f8962c04478d59dbaaae16082be1cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns the shader resource group asset with the requested name. Returns an empty handle if no matching group was found. <br /></td></tr>
<tr class="separator:a4f8962c04478d59dbaaae16082be1cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aea0ce34391f92b20e0515d97cc21c1"><td class="memItemLeft" align="right" valign="top"><a id="a5aea0ce34391f92b20e0515d97cc21c1" name="a5aea0ce34391f92b20e0515d97cc21c1"></a>
const RHI::Ptr&lt; <a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_layout.html">RHI::ShaderResourceGroupLayout</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>FindShaderResourceGroupLayout</b> (uint32_t bindingSlot) const</td></tr>
<tr class="memdesc:a5aea0ce34391f92b20e0515d97cc21c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns the shader resource group asset associated with the requested binding slot. Returns an empty handle if no matching group was found. <br /></td></tr>
<tr class="separator:a5aea0ce34391f92b20e0515d97cc21c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97ac451fa74f7c4416636a38237ca3f"><td class="memItemLeft" align="right" valign="top"><a id="af97ac451fa74f7c4416636a38237ca3f" name="af97ac451fa74f7c4416636a38237ca3f"></a>
const RHI::Ptr&lt; <a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_layout.html">RHI::ShaderResourceGroupLayout</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>FindFallbackShaderResourceGroupLayout</b> () const</td></tr>
<tr class="memdesc:af97ac451fa74f7c4416636a38237ca3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns the shader resource group asset designated as a ShaderVariantKey fallback. <br /></td></tr>
<tr class="separator:af97ac451fa74f7c4416636a38237ca3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca940b9f75a47e6ca446a7e3e82a8a4"><td class="memItemLeft" align="right" valign="top"><a id="a6ca940b9f75a47e6ca446a7e3e82a8a4" name="a6ca940b9f75a47e6ca446a7e3e82a8a4"></a>
AZStd::span&lt; const RHI::Ptr&lt; <a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_layout.html">RHI::ShaderResourceGroupLayout</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetShaderResourceGroupLayouts</b> () const</td></tr>
<tr class="memdesc:a6ca940b9f75a47e6ca446a7e3e82a8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of shader resource groups referenced by all variants in the shader asset. <br /></td></tr>
<tr class="separator:a6ca940b9f75a47e6ca446a7e3e82a8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d9904efffeb09dd9b5fb4d0e50d523"><td class="memItemLeft" align="right" valign="top">Data::Instance&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_resource_group.html">ShaderResourceGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#a47d9904efffeb09dd9b5fb4d0e50d523">CreateDrawSrgForShaderVariant</a> (const <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_option_group.html">ShaderOptionGroup</a> &amp;shaderOptions, bool compileTheSrg)</td></tr>
<tr class="separator:a47d9904efffeb09dd9b5fb4d0e50d523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3b238446eac639ee1e45e1254fca33"><td class="memItemLeft" align="right" valign="top">Data::Instance&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_resource_group.html">ShaderResourceGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#aae3b238446eac639ee1e45e1254fca33">CreateDefaultDrawSrg</a> (bool compileTheSrg)</td></tr>
<tr class="separator:aae3b238446eac639ee1e45e1254fca33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928999bb275aeaab406486c92d5f5df1"><td class="memItemLeft" align="right" valign="top"><a id="a928999bb275aeaab406486c92d5f5df1" name="a928999bb275aeaab406486c92d5f5df1"></a>
const <a class="el" href="class_a_z_1_1_data_1_1_asset.html">Data::Asset</a>&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_asset.html">ShaderAsset</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetAsset</b> () const</td></tr>
<tr class="memdesc:a928999bb275aeaab406486c92d5f5df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the asset used to initialize this shader. <br /></td></tr>
<tr class="separator:a928999bb275aeaab406486c92d5f5df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad14c8c63c7e09e1974723c2994add3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">RHI::DrawListTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#a1ad14c8c63c7e09e1974723c2994add3">GetDrawListTag</a> () const</td></tr>
<tr class="separator:a1ad14c8c63c7e09e1974723c2994add3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1a881a9cc6b8df14652b20f460b1c177"><td class="memItemLeft" align="right" valign="top"><a id="a1a881a9cc6b8df14652b20f460b1c177" name="a1a881a9cc6b8df14652b20f460b1c177"></a>
static Data::Instance&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FindOrCreate</b> (const <a class="el" href="class_a_z_1_1_data_1_1_asset.html">Data::Asset</a>&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_asset.html">ShaderAsset</a> &gt; &amp;shaderAsset, const Name &amp;supervariantName)</td></tr>
<tr class="memdesc:a1a881a9cc6b8df14652b20f460b1c177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the shader instance associated with the provided asset. <br /></td></tr>
<tr class="separator:a1a881a9cc6b8df14652b20f460b1c177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab862fd2814f36c1be030f8711361b42c"><td class="memItemLeft" align="right" valign="top"><a id="ab862fd2814f36c1be030f8711361b42c" name="ab862fd2814f36c1be030f8711361b42c"></a>
static Data::Instance&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FindOrCreate</b> (const <a class="el" href="class_a_z_1_1_data_1_1_asset.html">Data::Asset</a>&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_asset.html">ShaderAsset</a> &gt; &amp;shaderAsset)</td></tr>
<tr class="memdesc:ab862fd2814f36c1be030f8711361b42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but uses the default supervariant. <br /></td></tr>
<tr class="separator:ab862fd2814f36c1be030f8711361b42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a70b04e69b416446a007ccf02ad66e61a"><td class="memItemLeft" align="right" valign="top"><a id="a70b04e69b416446a007ccf02ad66e61a" name="a70b04e69b416446a007ccf02ad66e61a"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ShaderSystem</b></td></tr>
<tr class="separator:a70b04e69b416446a007ccf02ad66e61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a> is effectively an 'uber-shader' containing a collection of 'variants'. Variants are designed to be 'variations' on the same core shader technique. To enforce this, every variant in the shader shares the same pipeline layout (i.e. set of shader resource groups).</p>
<p>A shader owns a library of pipeline states. When a variant is resolved to a pipeline state, its lifetime is determined by the lifetime of the <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a> (unless an explicit reference is taken). If an asset reload event occurs, the pipeline state cache is reset.</p>
<p>To use <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a>: 1) Construct a <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_option_group.html">ShaderOptionGroup</a> instance using CreateShaderOptionGroup. 2) Configure the group by setting values on shader options. 3) Find the ShaderVariantStableId using the <a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_variant_id.html">ShaderVariantId</a> generated from the configured <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_option_group.html">ShaderOptionGroup</a>. 4) Acquire the <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> instance using the ShaderVariantStableId. 5) Configure a pipeline state descriptor on the variant; make local overrides as necessary (e.g. to configure runtime render state). 6) Acquire a <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state.html">RHI::PipelineState</a> instance from the shader using the configured pipeline state descriptor.</p>
<p>Remember that the returned <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state.html">RHI::PipelineState</a> instance lifetime is tied to the <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a> lifetime. If you need guarantee lifetime, it is safe to take a reference on the returned pipeline state. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aae3b238446eac639ee1e45e1254fca33" name="aae3b238446eac639ee1e45e1254fca33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3b238446eac639ee1e45e1254fca33">&#9670;&#160;</a></span>CreateDefaultDrawSrg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Data::Instance&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_resource_group.html">ShaderResourceGroup</a> &gt; AZ::RPI::Shader::CreateDefaultDrawSrg </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compileTheSrg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a DrawSrg that contains the shader variant fallback key, initialized to the default shader options values. This SRG must be included in the DrawPacket for any shader that has shader options, otherwise the CommandList will fail validation for SRG being null. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compileTheSrg</td><td>If you need to set other values in the SRG, set this to false, and the call Compile() when you are done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The DrawSrg instance, or null if the shader does not include a DrawSrg. </dd></dl>

</div>
</div>
<a id="a47d9904efffeb09dd9b5fb4d0e50d523" name="a47d9904efffeb09dd9b5fb4d0e50d523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d9904efffeb09dd9b5fb4d0e50d523">&#9670;&#160;</a></span>CreateDrawSrgForShaderVariant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Data::Instance&lt; <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_resource_group.html">ShaderResourceGroup</a> &gt; AZ::RPI::Shader::CreateDrawSrgForShaderVariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_option_group.html">ShaderOptionGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>shaderOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compileTheSrg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a DrawSrg that contains the shader variant fallback key. This SRG must be included in the DrawPacket for any shader that has shader options, otherwise the CommandList will fail validation for SRG being null. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shaderOptions</td><td>The shader option values will be stored in the SRG's shader variant fallback key (if there is one). </td></tr>
    <tr><td class="paramname">compileTheSrg</td><td>If you need to set other values in the SRG, set this to false, and the call Compile() when you are done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The DrawSrg instance, or null if the shader does not include a DrawSrg. </dd></dl>

</div>
</div>
<a id="a2511e12233eb7c359abb63789632dbc4" name="a2511e12233eb7c359abb63789632dbc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2511e12233eb7c359abb63789632dbc4">&#9670;&#160;</a></span>FindVariantStableId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_variant_search_result.html">ShaderVariantSearchResult</a> AZ::RPI::Shader::FindVariantStableId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_variant_id.html">ShaderVariantId</a> &amp;&#160;</td>
          <td class="paramname"><em>shaderVariantId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the best matching shader variant asset and returns its StableId. In cases where you can't cache the <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a>, and recurrently you may need the same <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> at different times, then it can be convenient (and more performant) to call this method to cache the ShaderVariantStableId and call <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#ab8a02235de720da375c82c5b1abd2947">GetVariant(ShaderVariantStableId)</a> when needed. If the asset is not immediately found in the file system, it will return the StableId of the root variant. Callers should listen to ShaderReloadNotificationBus to get notified whenever the exact variant is loaded and available or if a variant changes, etc. </p>

</div>
</div>
<a id="a37fa65893e413704b726244abcb7c77b" name="a37fa65893e413704b726244abcb7c77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fa65893e413704b726244abcb7c77b">&#9670;&#160;</a></span>GetDefaultVariant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> &amp; AZ::RPI::Shader::GetDefaultVariant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the closest variant that uses the default shader option values. This could return the root variant or a fallback variant if there is no variant baked for that combination of option values. </p>

</div>
</div>
<a id="a1ad14c8c63c7e09e1974723c2994add3" name="a1ad14c8c63c7e09e1974723c2994add3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad14c8c63c7e09e1974723c2994add3">&#9670;&#160;</a></span>GetDrawListTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">RHI::DrawListTag</a> AZ::RPI::Shader::GetDrawListTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the DrawListTag that identifies which <a class="el" href="class_a_z_1_1_r_p_i_1_1_pass.html">Pass</a> and <a class="el" href="class_a_z_1_1_r_p_i_1_1_view.html">View</a> objects will process this shader. This tag corresponds to the <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_asset.html">ShaderAsset</a> object's DrawListName. </p>

</div>
</div>
<a id="aa7b800982a3866aac2d7ae5aafc6dec3" name="aa7b800982a3866aac2d7ae5aafc6dec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b800982a3866aac2d7ae5aafc6dec3">&#9670;&#160;</a></span>GetVariant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> &amp; AZ::RPI::Shader::GetVariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_variant_id.html">ShaderVariantId</a> &amp;&#160;</td>
          <td class="paramname"><em>shaderVariantId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the best matching <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> for the given shaderVariantId, If the variant is loaded and ready it will return the corresponding <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a>. If the variant is not yet available it will return the root <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a>. Callers should listen to ShaderReloadNotificationBus to get notified whenever the exact variant is loaded and available or if a variant changes, etc. This function should be your one stop shop to get a <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> from a <a class="el" href="struct_a_z_1_1_r_p_i_1_1_shader_variant_id.html">ShaderVariantId</a>. Alternatively: You can call <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#a2511e12233eb7c359abb63789632dbc4">FindVariantStableId()</a> followed by GetVariant(shaderVariantStableId). </p>

</div>
</div>
<a id="ab8a02235de720da375c82c5b1abd2947" name="ab8a02235de720da375c82c5b1abd2947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a02235de720da375c82c5b1abd2947">&#9670;&#160;</a></span>GetVariant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader_variant.html">ShaderVariant</a> &amp; AZ::RPI::Shader::GetVariant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderVariantStableId</a>&#160;</td>
          <td class="paramname"><em>shaderVariantStableId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the variant associated with the provided StableId. You should call <a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html#a2511e12233eb7c359abb63789632dbc4">FindVariantStableId()</a> which caches the variant, later when this function is called the variant is fetched from a local map. If the variant is not found, the root variant is returned. "Alternatively: a more convenient approach is to call GetVariant(ShaderVariantId) which does both, the find and the get." </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Gems/Atom/RPI/Code/Include/Atom/RPI.Public/Shader/Shader.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><b>RPI</b></li><li class="navelem"><a class="el" href="class_a_z_1_1_r_p_i_1_1_shader.html">Shader</a></li>
    <li class="footer">Generated on Mon Oct 9 2023 13:49:08 for Open 3D Engine Atom Gem API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
