<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine Atom Gem API Reference: MaskedOcclusionCulling Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-placeholder-text"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine Atom Gem API Reference
   &#160;<span id="projectnumber">24.09</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_masked_occlusion_culling.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_masked_occlusion_culling-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MaskedOcclusionCulling Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Inherited by <a class="el" href="class_masked_occlusion_culling_private.html">MaskedOcclusionCullingPrivate</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_masked_occlusion_culling_1_1_occlusion_culling_statistics.html">OcclusionCullingStatistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_masked_occlusion_culling_1_1_scissor_rect.html">ScissorRect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_masked_occlusion_culling_1_1_tri_list.html">TriList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a45f29275099296b3b5d0cce506f759bd"><td class="memItemLeft" align="right" valign="top"><a id="a45f29275099296b3b5d0cce506f759bd"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Implementation</b> { <b>SSE2</b> = 0
, <b>SSE41</b> = 1
, <b>AVX2</b> = 2
, <b>AVX512</b> = 3
 }</td></tr>
<tr class="separator:a45f29275099296b3b5d0cce506f759bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8492bae7e15c3c6491466acf06eef488"><td class="memItemLeft" align="right" valign="top"><a id="a8492bae7e15c3c6491466acf06eef488"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BackfaceWinding</b> { <b>BACKFACE_NONE</b> = 0
, <b>BACKFACE_CW</b> = 1
, <b>BACKFACE_CCW</b> = 2
 }</td></tr>
<tr class="separator:a8492bae7e15c3c6491466acf06eef488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d289b9e1152750707dea597c294d3a3"><td class="memItemLeft" align="right" valign="top"><a id="a0d289b9e1152750707dea597c294d3a3"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>CullingResult</b> { <b>VISIBLE</b> = 0x0
, <b>OCCLUDED</b> = 0x1
, <b>VIEW_CULLED</b> = 0x3
 }</td></tr>
<tr class="separator:a0d289b9e1152750707dea597c294d3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80af7d22acd7b23f0fc87aa2ac852f9"><td class="memItemLeft" align="right" valign="top"><a id="af80af7d22acd7b23f0fc87aa2ac852f9"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ClipPlanes</b> { <br />
&#160;&#160;<b>CLIP_PLANE_NONE</b> = 0x00
, <b>CLIP_PLANE_NEAR</b> = 0x01
, <b>CLIP_PLANE_LEFT</b> = 0x02
, <b>CLIP_PLANE_RIGHT</b> = 0x04
, <br />
&#160;&#160;<b>CLIP_PLANE_BOTTOM</b> = 0x08
, <b>CLIP_PLANE_TOP</b> = 0x10
, <b>CLIP_PLANE_SIDES</b> = (CLIP_PLANE_LEFT | CLIP_PLANE_RIGHT | CLIP_PLANE_BOTTOM | CLIP_PLANE_TOP)
, <b>CLIP_PLANE_ALL</b> = (CLIP_PLANE_LEFT | CLIP_PLANE_RIGHT | CLIP_PLANE_BOTTOM | CLIP_PLANE_TOP | CLIP_PLANE_NEAR)
<br />
 }</td></tr>
<tr class="separator:af80af7d22acd7b23f0fc87aa2ac852f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ff9e33a4f87a3791eb5b7dd1b8e16c"><td class="memItemLeft" align="right" valign="top"><a id="a89ff9e33a4f87a3791eb5b7dd1b8e16c"></a>
typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><b>pfnAlignedAlloc</b>) (size_t alignment, size_t size)</td></tr>
<tr class="separator:a89ff9e33a4f87a3791eb5b7dd1b8e16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecb44fd14619ed0ebc8f547a21b11df"><td class="memItemLeft" align="right" valign="top"><a id="adecb44fd14619ed0ebc8f547a21b11df"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>pfnAlignedFree</b>) (void *ptr)</td></tr>
<tr class="separator:adecb44fd14619ed0ebc8f547a21b11df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a31dc21213cfe983afc64856a574e72e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a31dc21213cfe983afc64856a574e72e6">SetResolution</a> (unsigned int width, unsigned int height)=0</td></tr>
<tr class="memdesc:a31dc21213cfe983afc64856a574e72e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the resolution of the hierarchical depth buffer. This function will re-allocate the current depth buffer (if present). The contents of the buffer is undefined until <a class="el" href="class_masked_occlusion_culling.html#a8ca38e929880fefba257f96a87212288" title="Clears the hierarchical depth buffer.">ClearBuffer()</a> is called.  <a href="class_masked_occlusion_culling.html#a31dc21213cfe983afc64856a574e72e6">More...</a><br /></td></tr>
<tr class="separator:a31dc21213cfe983afc64856a574e72e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66073be3b909a4c9d6b057c984b5ab0b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a66073be3b909a4c9d6b057c984b5ab0b">GetResolution</a> (unsigned int &amp;width, unsigned int &amp;height) const =0</td></tr>
<tr class="memdesc:a66073be3b909a4c9d6b057c984b5ab0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the resolution of the hierarchical depth buffer.  <a href="class_masked_occlusion_culling.html#a66073be3b909a4c9d6b057c984b5ab0b">More...</a><br /></td></tr>
<tr class="separator:a66073be3b909a4c9d6b057c984b5ab0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5605061cd58ee62cf71d18fe84229aff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a5605061cd58ee62cf71d18fe84229aff">ComputeBinWidthHeight</a> (unsigned int nBinsW, unsigned int nBinsH, unsigned int &amp;outBinWidth, unsigned int &amp;outBinHeight)=0</td></tr>
<tr class="memdesc:a5605061cd58ee62cf71d18fe84229aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tile size for the current implementation.  <a href="class_masked_occlusion_culling.html#a5605061cd58ee62cf71d18fe84229aff">More...</a><br /></td></tr>
<tr class="separator:a5605061cd58ee62cf71d18fe84229aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aff6b2f29f019d64cc6f8c0acc00ad8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a4aff6b2f29f019d64cc6f8c0acc00ad8">SetNearClipPlane</a> (float nearDist)=0</td></tr>
<tr class="memdesc:a4aff6b2f29f019d64cc6f8c0acc00ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the distance for the near clipping plane. Default is nearDist = 0.  <a href="class_masked_occlusion_culling.html#a4aff6b2f29f019d64cc6f8c0acc00ad8">More...</a><br /></td></tr>
<tr class="separator:a4aff6b2f29f019d64cc6f8c0acc00ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3fde45cfd7c3044a3b1157d9654f2d"><td class="memItemLeft" align="right" valign="top"><a id="a4a3fde45cfd7c3044a3b1157d9654f2d"></a>
virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a4a3fde45cfd7c3044a3b1157d9654f2d">GetNearClipPlane</a> () const =0</td></tr>
<tr class="memdesc:a4a3fde45cfd7c3044a3b1157d9654f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the distance for the near clipping plane. <br /></td></tr>
<tr class="separator:a4a3fde45cfd7c3044a3b1157d9654f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca38e929880fefba257f96a87212288"><td class="memItemLeft" align="right" valign="top"><a id="a8ca38e929880fefba257f96a87212288"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a8ca38e929880fefba257f96a87212288">ClearBuffer</a> ()=0</td></tr>
<tr class="memdesc:a8ca38e929880fefba257f96a87212288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the hierarchical depth buffer. <br /></td></tr>
<tr class="separator:a8ca38e929880fefba257f96a87212288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac485575dc75d718699cefb0b8a182ea8"><td class="memItemLeft" align="right" valign="top"><a id="ac485575dc75d718699cefb0b8a182ea8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#ac485575dc75d718699cefb0b8a182ea8">MergeBuffer</a> (<a class="el" href="class_masked_occlusion_culling.html">MaskedOcclusionCulling</a> *BufferB)=0</td></tr>
<tr class="memdesc:ac485575dc75d718699cefb0b8a182ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge a second hierarchical depth buffer into the main buffer. <br /></td></tr>
<tr class="separator:ac485575dc75d718699cefb0b8a182ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125dfdd5057dd6ae541720c63ccbd097"><td class="memItemLeft" align="right" valign="top">virtual CullingResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a125dfdd5057dd6ae541720c63ccbd097">RenderTriangles</a> (const float *inVtx, const unsigned int *inTris, int nTris, const float *modelToClipMatrix=nullptr, BackfaceWinding bfWinding=BACKFACE_CW, ClipPlanes clipPlaneMask=CLIP_PLANE_ALL, const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;vtxLayout=<a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a>(16, 4, 12))=0</td></tr>
<tr class="memdesc:a125dfdd5057dd6ae541720c63ccbd097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a mesh of occluder triangles and updates the hierarchical z buffer with conservative depth values.  <a href="class_masked_occlusion_culling.html#a125dfdd5057dd6ae541720c63ccbd097">More...</a><br /></td></tr>
<tr class="separator:a125dfdd5057dd6ae541720c63ccbd097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaac101042e8262a81d19ac3064a8d17"><td class="memItemLeft" align="right" valign="top">virtual CullingResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#afaac101042e8262a81d19ac3064a8d17">TestRect</a> (float xmin, float ymin, float xmax, float ymax, float wmin) const =0</td></tr>
<tr class="memdesc:afaac101042e8262a81d19ac3064a8d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Occlusion query for a rectangle with a given depth. The rectangle is given in normalized device coordinates where (x,y) coordinates between [-1,1] map to the visible screen area. The query uses a GREATER_EQUAL (reversed) depth test meaning that depth values equal to the contents of the depth buffer are counted as visible.  <a href="class_masked_occlusion_culling.html#afaac101042e8262a81d19ac3064a8d17">More...</a><br /></td></tr>
<tr class="separator:afaac101042e8262a81d19ac3064a8d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a0a8e302f5649ec090240580a6aca5"><td class="memItemLeft" align="right" valign="top">virtual CullingResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a37a0a8e302f5649ec090240580a6aca5">TestTriangles</a> (const float *inVtx, const unsigned int *inTris, int nTris, const float *modelToClipMatrix=nullptr, BackfaceWinding bfWinding=BACKFACE_CW, ClipPlanes clipPlaneMask=CLIP_PLANE_ALL, const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;vtxLayout=<a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a>(16, 4, 12))=0</td></tr>
<tr class="memdesc:a37a0a8e302f5649ec090240580a6aca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is similar to <a class="el" href="class_masked_occlusion_culling.html#a125dfdd5057dd6ae541720c63ccbd097" title="Renders a mesh of occluder triangles and updates the hierarchical z buffer with conservative depth va...">RenderTriangles()</a>, but performs an occlusion query instead and does not update the hierarchical z buffer. The query uses a GREATER_EQUAL (reversed) depth test meaning that depth values equal to the contents of the depth buffer are counted as visible.  <a href="class_masked_occlusion_culling.html#a37a0a8e302f5649ec090240580a6aca5">More...</a><br /></td></tr>
<tr class="separator:a37a0a8e302f5649ec090240580a6aca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666fb7b9205a16c0c2df3117f9bc632c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a666fb7b9205a16c0c2df3117f9bc632c">BinTriangles</a> (const float *inVtx, const unsigned int *inTris, int nTris, <a class="el" href="struct_masked_occlusion_culling_1_1_tri_list.html">TriList</a> *triLists, unsigned int nBinsW, unsigned int nBinsH, const float *modelToClipMatrix=nullptr, BackfaceWinding bfWinding=BACKFACE_CW, ClipPlanes clipPlaneMask=CLIP_PLANE_ALL, const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;vtxLayout=<a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a>(16, 4, 12))=0</td></tr>
<tr class="memdesc:a666fb7b9205a16c0c2df3117f9bc632c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform input assembly, clipping , projection, triangle setup, and write triangles to the screen space bins they overlap. This function can be used to distribute work for threading (See the CullingThreadpool class for an example)  <a href="class_masked_occlusion_culling.html#a666fb7b9205a16c0c2df3117f9bc632c">More...</a><br /></td></tr>
<tr class="separator:a666fb7b9205a16c0c2df3117f9bc632c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bed9467e6022bed44af7e240cba5e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a976bed9467e6022bed44af7e240cba5e">RenderTrilist</a> (const <a class="el" href="struct_masked_occlusion_culling_1_1_tri_list.html">TriList</a> &amp;triList, const <a class="el" href="struct_masked_occlusion_culling_1_1_scissor_rect.html">ScissorRect</a> *scissor)=0</td></tr>
<tr class="memdesc:a976bed9467e6022bed44af7e240cba5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders all occluder triangles in a trilist. This function can be used in combination with <a class="el" href="class_masked_occlusion_culling.html#a666fb7b9205a16c0c2df3117f9bc632c" title="Perform input assembly, clipping , projection, triangle setup, and write triangles to the screen spac...">BinTriangles()</a> to create a threded (binning) rasterizer. The bins can be processed independently by different threads without risking writing to overlapping memory regions.  <a href="class_masked_occlusion_culling.html#a976bed9467e6022bed44af7e240cba5e">More...</a><br /></td></tr>
<tr class="separator:a976bed9467e6022bed44af7e240cba5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6ed10a1f5eeab63769ca015443b5e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a4b6ed10a1f5eeab63769ca015443b5e7">ComputePixelDepthBuffer</a> (float *depthData, bool flipY)=0</td></tr>
<tr class="memdesc:a4b6ed10a1f5eeab63769ca015443b5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a per-pixel depth buffer from the hierarchical z buffer representation. Intended for visualizing the hierarchical depth buffer for debugging. The buffer is written in scanline order, from the top to bottom (D3D) or bottom to top (OGL) of the surface. See the USE_D3D define.  <a href="class_masked_occlusion_culling.html#a4b6ed10a1f5eeab63769ca015443b5e7">More...</a><br /></td></tr>
<tr class="separator:a4b6ed10a1f5eeab63769ca015443b5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14ab2651b1246cc3add7371bded7121"><td class="memItemLeft" align="right" valign="top"><a id="aa14ab2651b1246cc3add7371bded7121"></a>
virtual <a class="el" href="struct_masked_occlusion_culling_1_1_occlusion_culling_statistics.html">OcclusionCullingStatistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#aa14ab2651b1246cc3add7371bded7121">GetStatistics</a> ()=0</td></tr>
<tr class="memdesc:aa14ab2651b1246cc3add7371bded7121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch occlusion culling statistics, returns zeroes if ENABLE_STATS define is not defined. The statistics can be used for profiling or debugging. <br /></td></tr>
<tr class="separator:aa14ab2651b1246cc3add7371bded7121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f3d406fcaf82ac4e80a196a9556cd1"><td class="memItemLeft" align="right" valign="top"><a id="a82f3d406fcaf82ac4e80a196a9556cd1"></a>
virtual Implementation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a82f3d406fcaf82ac4e80a196a9556cd1">GetImplementation</a> ()=0</td></tr>
<tr class="memdesc:a82f3d406fcaf82ac4e80a196a9556cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the implementation (CPU instruction set) version of this object. <br /></td></tr>
<tr class="separator:a82f3d406fcaf82ac4e80a196a9556cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51f2ec3444351a3576da99ccf157213"><td class="memItemLeft" align="right" valign="top"><a id="af51f2ec3444351a3576da99ccf157213"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#af51f2ec3444351a3576da99ccf157213">GetAllocFreeCallback</a> (pfnAlignedAlloc &amp;allocCallback, pfnAlignedFree &amp;freeCallback)</td></tr>
<tr class="memdesc:af51f2ec3444351a3576da99ccf157213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get used memory alloc/free callbacks. <br /></td></tr>
<tr class="separator:af51f2ec3444351a3576da99ccf157213"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a234f5d08c60646a0b524b18efe4d113c"><td class="memItemLeft" align="right" valign="top"><a id="a234f5d08c60646a0b524b18efe4d113c"></a>
static <a class="el" href="class_masked_occlusion_culling.html">MaskedOcclusionCulling</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a234f5d08c60646a0b524b18efe4d113c">Create</a> (Implementation RequestedSIMD=AVX512)</td></tr>
<tr class="memdesc:a234f5d08c60646a0b524b18efe4d113c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object with default state, no z buffer attached/allocated. <br /></td></tr>
<tr class="separator:a234f5d08c60646a0b524b18efe4d113c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3d6187c1d9d2435d593840bab422e4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_masked_occlusion_culling.html">MaskedOcclusionCulling</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a0f3d6187c1d9d2435d593840bab422e4">Create</a> (Implementation RequestedSIMD, pfnAlignedAlloc alignedAlloc, pfnAlignedFree alignedFree)</td></tr>
<tr class="memdesc:a0f3d6187c1d9d2435d593840bab422e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object with default state, no z buffer attached/allocated.  <a href="class_masked_occlusion_culling.html#a0f3d6187c1d9d2435d593840bab422e4">More...</a><br /></td></tr>
<tr class="separator:a0f3d6187c1d9d2435d593840bab422e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b58c7c50559afb190ea7b212164962c"><td class="memItemLeft" align="right" valign="top"><a id="a6b58c7c50559afb190ea7b212164962c"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a6b58c7c50559afb190ea7b212164962c">Destroy</a> (<a class="el" href="class_masked_occlusion_culling.html">MaskedOcclusionCulling</a> *moc)</td></tr>
<tr class="memdesc:a6b58c7c50559afb190ea7b212164962c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an object and frees the z buffer memory. Note that you cannot use the delete operator, and should rather use this function to free up memory. <br /></td></tr>
<tr class="separator:a6b58c7c50559afb190ea7b212164962c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91b40d11fd7323fc8a9556608fadce5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#ac91b40d11fd7323fc8a9556608fadce5">TransformVertices</a> (const float *mtx, const float *inVtx, float *xfVtx, unsigned int nVtx, const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;vtxLayout=<a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a>(12, 4, 8))</td></tr>
<tr class="memdesc:ac91b40d11fd7323fc8a9556608fadce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for transforming vertices and outputting them to an (x,y,z,w) format suitable for the occluder rasterization and occludee testing functions.  <a href="class_masked_occlusion_culling.html#ac91b40d11fd7323fc8a9556608fadce5">More...</a><br /></td></tr>
<tr class="separator:ac91b40d11fd7323fc8a9556608fadce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a42e0b9f44bc170702f1d04dd319c1707"><td class="memItemLeft" align="right" valign="top"><a id="a42e0b9f44bc170702f1d04dd319c1707"></a>
pfnAlignedAlloc&#160;</td><td class="memItemRight" valign="bottom"><b>mAlignedAllocCallback</b></td></tr>
<tr class="separator:a42e0b9f44bc170702f1d04dd319c1707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754a3d68084b5d7833ccecde6b9881be"><td class="memItemLeft" align="right" valign="top"><a id="a754a3d68084b5d7833ccecde6b9881be"></a>
pfnAlignedFree&#160;</td><td class="memItemRight" valign="bottom"><b>mAlignedFreeCallback</b></td></tr>
<tr class="separator:a754a3d68084b5d7833ccecde6b9881be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c70a3e8f3b764d5237eecdabccc8d6"><td class="memItemLeft" align="right" valign="top"><a id="a55c70a3e8f3b764d5237eecdabccc8d6"></a>
<a class="el" href="struct_masked_occlusion_culling_1_1_occlusion_culling_statistics.html">OcclusionCullingStatistics</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mStats</b></td></tr>
<tr class="separator:a55c70a3e8f3b764d5237eecdabccc8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a666fb7b9205a16c0c2df3117f9bc632c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666fb7b9205a16c0c2df3117f9bc632c">&#9670;&nbsp;</a></span>BinTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MaskedOcclusionCulling::BinTriangles </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>inVtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>inTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_masked_occlusion_culling_1_1_tri_list.html">TriList</a> *&#160;</td>
          <td class="paramname"><em>triLists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nBinsW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nBinsH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>modelToClipMatrix</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackfaceWinding&#160;</td>
          <td class="paramname"><em>bfWinding</em> = <code>BACKFACE_CW</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ClipPlanes&#160;</td>
          <td class="paramname"><em>clipPlaneMask</em> = <code>CLIP_PLANE_ALL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>vtxLayout</em> = <code><a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a>(16,&#160;4,&#160;12)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform input assembly, clipping , projection, triangle setup, and write triangles to the screen space bins they overlap. This function can be used to distribute work for threading (See the CullingThreadpool class for an example) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inVtx</td><td>Pointer to an array of input vertices, should point to the x component of the first vertex. The input vertices are given as (x,y,w) coordinates in clip space. The memory layout can be changed using vtxLayout. </td></tr>
    <tr><td class="paramname">inTris</td><td>Pointer to an array of vertex indices. Each triangle is created from three indices consecutively fetched from the array. </td></tr>
    <tr><td class="paramname">nTris</td><td>The number of triangles to render (inTris must contain atleast 3*nTris entries) </td></tr>
    <tr><td class="paramname">triLists</td><td>Pointer to an array of <a class="el" href="struct_masked_occlusion_culling_1_1_tri_list.html">TriList</a> objects with one <a class="el" href="struct_masked_occlusion_culling_1_1_tri_list.html">TriList</a> object per bin. If a triangle overlaps a bin, it will be written to the corresponding trilist. Note that this method appends the triangles to the current list, to start writing from the beginning of the list, set triList.mTriIdx = 0 </td></tr>
    <tr><td class="paramname">nBinsW</td><td>Number of vertical bins, the screen is divided into nBinsW x nBinsH rectangular bins. </td></tr>
    <tr><td class="paramname">nBinsH</td><td>Number of horizontal bins, the screen is divided into nBinsW x nBinsH rectangular bins. </td></tr>
    <tr><td class="paramname">modelToClipMatrix</td><td>all vertices will be transformed by this matrix before performing projection. If nullptr is passed the transform step will be skipped </td></tr>
    <tr><td class="paramname">clipPlaneMask</td><td>A mask indicating which clip planes should be considered by the triangle clipper. Can be used as an optimization if your application can determine (for example during culling) that a group of triangles does not intersect a certain frustum plane. However, setting an incorrect mask may cause out of bounds memory accesses. </td></tr>
    <tr><td class="paramname">vtxLayout</td><td>A struct specifying the vertex layout (see struct for detailed description). For best performance, it is advisable to store position data as compactly in memory as possible. </td></tr>
    <tr><td class="paramname">bfWinding</td><td>Sets triangle winding order to consider backfacing, must be one one of (BACKFACE_NONE, BACKFACE_CW and BACKFACE_CCW). Back-facing triangles are culled and will not be binned / rasterized. You may use BACKFACE_NONE to disable culling for double sided geometry </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_masked_occlusion_culling_private.html#aa88cf80ede8f35e985388fb196ba0455">MaskedOcclusionCullingPrivate</a>, and <a class="el" href="class_masked_occlusion_culling_private.html#a176c871898b85c724dc068f76456a37d">MaskedOcclusionCullingPrivate</a>.</p>

</div>
</div>
<a id="a5605061cd58ee62cf71d18fe84229aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5605061cd58ee62cf71d18fe84229aff">&#9670;&nbsp;</a></span>ComputeBinWidthHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MaskedOcclusionCulling::ComputeBinWidthHeight </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nBinsW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nBinsH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>outBinWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>outBinHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tile size for the current implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nBinsW</td><td>Number of vertical bins, the screen is divided into nBinsW x nBinsH rectangular bins. </td></tr>
    <tr><td class="paramname">nBinsH</td><td>Number of horizontal bins, the screen is divided into nBinsW x nBinsH rectangular bins. </td></tr>
    <tr><td class="paramname">outBinWidth</td><td>Output: The width of the single bin in pixels (except for the rightmost bin width, which is extended to resolution width) </td></tr>
    <tr><td class="paramname">outBinHeight</td><td>Output: The height of the single bin in pixels (except for the bottommost bin height, which is extended to resolution height) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_masked_occlusion_culling_private.html#a67c8e5e75f8d96c6e8e9bb8394bde412">MaskedOcclusionCullingPrivate</a>.</p>

</div>
</div>
<a id="a4b6ed10a1f5eeab63769ca015443b5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6ed10a1f5eeab63769ca015443b5e7">&#9670;&nbsp;</a></span>ComputePixelDepthBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MaskedOcclusionCulling::ComputePixelDepthBuffer </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>depthData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a per-pixel depth buffer from the hierarchical z buffer representation. Intended for visualizing the hierarchical depth buffer for debugging. The buffer is written in scanline order, from the top to bottom (D3D) or bottom to top (OGL) of the surface. See the USE_D3D define. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthData</td><td>Pointer to memory where the per-pixel depth data is written. Must hold storage for atleast width*height elements as set by setResolution. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_masked_occlusion_culling_private.html#ab9fc1fc20aa42debd379c537676b78c9">MaskedOcclusionCullingPrivate</a>.</p>

</div>
</div>
<a id="a0f3d6187c1d9d2435d593840bab422e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3d6187c1d9d2435d593840bab422e4">&#9670;&nbsp;</a></span>Create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_masked_occlusion_culling.html">MaskedOcclusionCulling</a>* MaskedOcclusionCulling::Create </td>
          <td>(</td>
          <td class="paramtype">Implementation&#160;</td>
          <td class="paramname"><em>RequestedSIMD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pfnAlignedAlloc&#160;</td>
          <td class="paramname"><em>alignedAlloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pfnAlignedFree&#160;</td>
          <td class="paramname"><em>alignedFree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object with default state, no z buffer attached/allocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alignedAlloc</td><td>Pointer to a callback function used when allocating memory </td></tr>
    <tr><td class="paramname">alignedFree</td><td>Pointer to a callback function used when freeing memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66073be3b909a4c9d6b057c984b5ab0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66073be3b909a4c9d6b057c984b5ab0b">&#9670;&nbsp;</a></span>GetResolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MaskedOcclusionCulling::GetResolution </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the resolution of the hierarchical depth buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">witdh</td><td>Output: The width of the buffer in pixels </td></tr>
    <tr><td class="paramname">height</td><td>Output: The height of the buffer in pixels </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_masked_occlusion_culling_private.html#a26145c22cf52281d84b501a09ead3802">MaskedOcclusionCullingPrivate</a>.</p>

</div>
</div>
<a id="a125dfdd5057dd6ae541720c63ccbd097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125dfdd5057dd6ae541720c63ccbd097">&#9670;&nbsp;</a></span>RenderTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CullingResult MaskedOcclusionCulling::RenderTriangles </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>inVtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>inTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>modelToClipMatrix</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackfaceWinding&#160;</td>
          <td class="paramname"><em>bfWinding</em> = <code>BACKFACE_CW</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ClipPlanes&#160;</td>
          <td class="paramname"><em>clipPlaneMask</em> = <code>CLIP_PLANE_ALL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>vtxLayout</em> = <code><a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a>(16,&#160;4,&#160;12)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a mesh of occluder triangles and updates the hierarchical z buffer with conservative depth values. </p>
<p>This function is optimized for vertex layouts with stride 16 and y and w offsets of 4 and 12 bytes, respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inVtx</td><td>Pointer to an array of input vertices, should point to the x component of the first vertex. The input vertices are given as (x,y,w) coordinates in clip space. The memory layout can be changed using vtxLayout. </td></tr>
    <tr><td class="paramname">inTris</td><td>Pointer to an array of vertex indices. Each triangle is created from three indices consecutively fetched from the array. </td></tr>
    <tr><td class="paramname">nTris</td><td>The number of triangles to render (inTris must contain atleast 3*nTris entries) </td></tr>
    <tr><td class="paramname">modelToClipMatrix</td><td>all vertices will be transformed by this matrix before performing projection. If nullptr is passed the transform step will be skipped </td></tr>
    <tr><td class="paramname">bfWinding</td><td>Sets triangle winding order to consider backfacing, must be one one of (BACKFACE_NONE, BACKFACE_CW and BACKFACE_CCW). Back-facing triangles are culled and will not be rasterized. You may use BACKFACE_NONE to disable culling for double sided geometry </td></tr>
    <tr><td class="paramname">clipPlaneMask</td><td>A mask indicating which clip planes should be considered by the triangle clipper. Can be used as an optimization if your application can determine (for example during culling) that a group of triangles does not intersect a certain frustum plane. However, setting an incorrect mask may cause out of bounds memory accesses. </td></tr>
    <tr><td class="paramname">vtxLayout</td><td>A struct specifying the vertex layout (see struct for detailed description). For best performance, it is advisable to store position data as compactly in memory as possible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Will return VIEW_CULLED if all triangles are either outside the frustum or backface culled, returns VISIBLE otherwise. </dd></dl>

<p>Implemented in <a class="el" href="class_masked_occlusion_culling_private.html#ae73becb905c8d1dc3af3635330f3e002">MaskedOcclusionCullingPrivate</a>, and <a class="el" href="class_masked_occlusion_culling_private.html#a8d7e4a3b07720c3c8fd69c0590435d79">MaskedOcclusionCullingPrivate</a>.</p>

</div>
</div>
<a id="a976bed9467e6022bed44af7e240cba5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976bed9467e6022bed44af7e240cba5e">&#9670;&nbsp;</a></span>RenderTrilist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MaskedOcclusionCulling::RenderTrilist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_masked_occlusion_culling_1_1_tri_list.html">TriList</a> &amp;&#160;</td>
          <td class="paramname"><em>triList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_masked_occlusion_culling_1_1_scissor_rect.html">ScissorRect</a> *&#160;</td>
          <td class="paramname"><em>scissor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders all occluder triangles in a trilist. This function can be used in combination with <a class="el" href="class_masked_occlusion_culling.html#a666fb7b9205a16c0c2df3117f9bc632c" title="Perform input assembly, clipping , projection, triangle setup, and write triangles to the screen spac...">BinTriangles()</a> to create a threded (binning) rasterizer. The bins can be processed independently by different threads without risking writing to overlapping memory regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triLists</td><td>A triangle list, filled using the <a class="el" href="class_masked_occlusion_culling.html#a666fb7b9205a16c0c2df3117f9bc632c" title="Perform input assembly, clipping , projection, triangle setup, and write triangles to the screen spac...">BinTriangles()</a> function that is to be rendered. </td></tr>
    <tr><td class="paramname">scissor</td><td>A scissor box limiting the rendering region to the bin. The size of each bin must be a multiple of 32x8 pixels due to implementation constraints. For a render target with (width, height) resolution and (nBinsW, nBinsH) bins, the size of a bin is: binWidth = (width / nBinsW) - (width / nBinsW) % 32; binHeight = (height / nBinsH) - (height / nBinsH) % 8; The last row and column of tiles have a different size: lastColBinWidth = width - (nBinsW-1)*binWidth; lastRowBinHeight = height - (nBinsH-1)*binHeight; </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_masked_occlusion_culling_private.html#ac0157e0f6969772f3c7184b01fcc0ca6">MaskedOcclusionCullingPrivate</a>.</p>

</div>
</div>
<a id="a4aff6b2f29f019d64cc6f8c0acc00ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aff6b2f29f019d64cc6f8c0acc00ad8">&#9670;&nbsp;</a></span>SetNearClipPlane()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MaskedOcclusionCulling::SetNearClipPlane </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>nearDist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the distance for the near clipping plane. Default is nearDist = 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nearDist</td><td>The distance to the near clipping plane, given as clip space w </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_masked_occlusion_culling_private.html#a01823add2c1ecb901aea5156e3e3113f">MaskedOcclusionCullingPrivate</a>.</p>

</div>
</div>
<a id="a31dc21213cfe983afc64856a574e72e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31dc21213cfe983afc64856a574e72e6">&#9670;&nbsp;</a></span>SetResolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MaskedOcclusionCulling::SetResolution </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the resolution of the hierarchical depth buffer. This function will re-allocate the current depth buffer (if present). The contents of the buffer is undefined until <a class="el" href="class_masked_occlusion_culling.html#a8ca38e929880fefba257f96a87212288" title="Clears the hierarchical depth buffer.">ClearBuffer()</a> is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">witdh</td><td>The width of the buffer in pixels, must be a multiple of 8 </td></tr>
    <tr><td class="paramname">height</td><td>The height of the buffer in pixels, must be a multiple of 4 </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_masked_occlusion_culling_private.html#a941f778b10002a256bf081231279e4b9">MaskedOcclusionCullingPrivate</a>.</p>

</div>
</div>
<a id="afaac101042e8262a81d19ac3064a8d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaac101042e8262a81d19ac3064a8d17">&#9670;&nbsp;</a></span>TestRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CullingResult MaskedOcclusionCulling::TestRect </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ymin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ymax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>wmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Occlusion query for a rectangle with a given depth. The rectangle is given in normalized device coordinates where (x,y) coordinates between [-1,1] map to the visible screen area. The query uses a GREATER_EQUAL (reversed) depth test meaning that depth values equal to the contents of the depth buffer are counted as visible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xmin</td><td>NDC coordinate of the left side of the rectangle. </td></tr>
    <tr><td class="paramname">ymin</td><td>NDC coordinate of the bottom side of the rectangle. </td></tr>
    <tr><td class="paramname">xmax</td><td>NDC coordinate of the right side of the rectangle. </td></tr>
    <tr><td class="paramname">ymax</td><td>NDC coordinate of the top side of the rectangle. </td></tr>
    <tr><td class="paramname">ymax</td><td>NDC coordinate of the top side of the rectangle. </td></tr>
    <tr><td class="paramname">wmin</td><td>Clip space W coordinate for the rectangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The query will return VISIBLE if the rectangle may be visible, OCCLUDED if the rectangle is occluded by a previously rendered object, or VIEW_CULLED if the rectangle is outside the view frustum. </dd></dl>

<p>Implemented in <a class="el" href="class_masked_occlusion_culling_private.html#afc56812ccfe60650d96cd43a19b690a0">MaskedOcclusionCullingPrivate</a>.</p>

</div>
</div>
<a id="a37a0a8e302f5649ec090240580a6aca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a0a8e302f5649ec090240580a6aca5">&#9670;&nbsp;</a></span>TestTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CullingResult MaskedOcclusionCulling::TestTriangles </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>inVtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>inTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>modelToClipMatrix</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackfaceWinding&#160;</td>
          <td class="paramname"><em>bfWinding</em> = <code>BACKFACE_CW</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ClipPlanes&#160;</td>
          <td class="paramname"><em>clipPlaneMask</em> = <code>CLIP_PLANE_ALL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>vtxLayout</em> = <code><a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a>(16,&#160;4,&#160;12)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is similar to <a class="el" href="class_masked_occlusion_culling.html#a125dfdd5057dd6ae541720c63ccbd097" title="Renders a mesh of occluder triangles and updates the hierarchical z buffer with conservative depth va...">RenderTriangles()</a>, but performs an occlusion query instead and does not update the hierarchical z buffer. The query uses a GREATER_EQUAL (reversed) depth test meaning that depth values equal to the contents of the depth buffer are counted as visible. </p>
<p>This function is optimized for vertex layouts with stride 16 and y and w offsets of 4 and 12 bytes, respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inVtx</td><td>Pointer to an array of input vertices, should point to the x component of the first vertex. The input vertices are given as (x,y,w) coordinates in clip space. The memory layout can be changed using vtxLayout. </td></tr>
    <tr><td class="paramname">inTris</td><td>Pointer to an array of triangle indices. Each triangle is created from three indices consecutively fetched from the array. </td></tr>
    <tr><td class="paramname">nTris</td><td>The number of triangles to render (inTris must contain atleast 3*nTris entries) </td></tr>
    <tr><td class="paramname">modelToClipMatrix</td><td>all vertices will be transformed by this matrix before performing projection. If nullptr is passed the transform step will be skipped </td></tr>
    <tr><td class="paramname">bfWinding</td><td>Sets triangle winding order to consider backfacing, must be one one of (BACKFACE_NONE, BACKFACE_CW and BACKFACE_CCW). Back-facing triangles are culled and will not be occlusion tested. You may use BACKFACE_NONE to disable culling for double sided geometry </td></tr>
    <tr><td class="paramname">clipPlaneMask</td><td>A mask indicating which clip planes should be considered by the triangle clipper. Can be used as an optimization if your application can determine (for example during culling) that a group of triangles does not intersect a certain frustum plane. However, setting an incorrect mask may cause out of bounds memory accesses. </td></tr>
    <tr><td class="paramname">vtxLayout</td><td>A struct specifying the vertex layout (see struct for detailed description). For best performance, it is advisable to store position data as compactly in memory as possible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The query will return VISIBLE if the triangle mesh may be visible, OCCLUDED if the mesh is occluded by a previously rendered object, or VIEW_CULLED if all triangles are entirely outside the view frustum or backface culled. </dd></dl>

<p>Implemented in <a class="el" href="class_masked_occlusion_culling_private.html#ab2b6b262c419d39ce69676839e8c734c">MaskedOcclusionCullingPrivate</a>.</p>

</div>
</div>
<a id="ac91b40d11fd7323fc8a9556608fadce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91b40d11fd7323fc8a9556608fadce5">&#9670;&nbsp;</a></span>TransformVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MaskedOcclusionCulling::TransformVertices </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>inVtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>xfVtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nVtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>vtxLayout</em> = <code><a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a>(12,&#160;4,&#160;8)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function for transforming vertices and outputting them to an (x,y,z,w) format suitable for the occluder rasterization and occludee testing functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to matrix data. The matrix should column major for post multiplication (OGL) and row major for pre-multiplication (DX). This is consistent with OpenGL / DirectX behavior. </td></tr>
    <tr><td class="paramname">inVtx</td><td>Pointer to an array of input vertices. The input vertices are given as (x,y,z) coordinates. The memory layout can be changed using vtxLayout. </td></tr>
    <tr><td class="paramname">xfVtx</td><td>Pointer to an array to store transformed vertices. The transformed vertices are always stored as array of structs (AoS) (x,y,z,w) packed in memory. </td></tr>
    <tr><td class="paramname">nVtx</td><td>Number of vertices to transform. </td></tr>
    <tr><td class="paramname">vtxLayout</td><td>A struct specifying the vertex layout (see struct for detailed description). For best performance, it is advisable to store position data as compactly in memory as possible. Note that for this function, the w-component is assumed to be 1.0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Gems/Atom/RPI/Code/External/MaskedOcclusionCulling/<a class="el" href="_masked_occlusion_culling_8h.html">MaskedOcclusionCulling.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_masked_occlusion_culling.html">MaskedOcclusionCulling</a></li>
    <li class="footer">Generated on Tue Oct 8 2024 21:27:29 for Open 3D Engine Atom Gem API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
