<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine Atom Gem API Reference: MaskedOcclusionCullingPrivate Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-placeholder-text"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine Atom Gem API Reference
   &#160;<span id="projectnumber">24.09</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_masked_occlusion_culling_private.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_masked_occlusion_culling_private-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MaskedOcclusionCullingPrivate Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Inherits <a class="el" href="class_masked_occlusion_culling.html">MaskedOcclusionCulling</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_masked_occlusion_culling_private_1_1_z_tile.html">ZTile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3a0ddc1154cc08265fa2fb6831f9a18c"><td class="memItemLeft" align="right" valign="top"><a id="a3a0ddc1154cc08265fa2fb6831f9a18c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MaskedOcclusionCullingPrivate</b> (pfnAlignedAlloc alignedAlloc, pfnAlignedFree alignedFree)</td></tr>
<tr class="separator:a3a0ddc1154cc08265fa2fb6831f9a18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941f778b10002a256bf081231279e4b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#a941f778b10002a256bf081231279e4b9">SetResolution</a> (unsigned int width, unsigned int height) override</td></tr>
<tr class="memdesc:a941f778b10002a256bf081231279e4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the resolution of the hierarchical depth buffer. This function will re-allocate the current depth buffer (if present). The contents of the buffer is undefined until <a class="el" href="class_masked_occlusion_culling_private.html#a5340952213b62181ac66d6dfa8bb3760" title="Clears the hierarchical depth buffer.">ClearBuffer()</a> is called.  <a href="class_masked_occlusion_culling_private.html#a941f778b10002a256bf081231279e4b9">More...</a><br /></td></tr>
<tr class="separator:a941f778b10002a256bf081231279e4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26145c22cf52281d84b501a09ead3802"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#a26145c22cf52281d84b501a09ead3802">GetResolution</a> (unsigned int &amp;width, unsigned int &amp;height) const override</td></tr>
<tr class="memdesc:a26145c22cf52281d84b501a09ead3802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the resolution of the hierarchical depth buffer.  <a href="class_masked_occlusion_culling_private.html#a26145c22cf52281d84b501a09ead3802">More...</a><br /></td></tr>
<tr class="separator:a26145c22cf52281d84b501a09ead3802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c8e5e75f8d96c6e8e9bb8394bde412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#a67c8e5e75f8d96c6e8e9bb8394bde412">ComputeBinWidthHeight</a> (unsigned int nBinsW, unsigned int nBinsH, unsigned int &amp;outBinWidth, unsigned int &amp;outBinHeight) override</td></tr>
<tr class="memdesc:a67c8e5e75f8d96c6e8e9bb8394bde412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tile size for the current implementation.  <a href="class_masked_occlusion_culling_private.html#a67c8e5e75f8d96c6e8e9bb8394bde412">More...</a><br /></td></tr>
<tr class="separator:a67c8e5e75f8d96c6e8e9bb8394bde412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01823add2c1ecb901aea5156e3e3113f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#a01823add2c1ecb901aea5156e3e3113f">SetNearClipPlane</a> (float nearDist) override</td></tr>
<tr class="memdesc:a01823add2c1ecb901aea5156e3e3113f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the distance for the near clipping plane. Default is nearDist = 0.  <a href="class_masked_occlusion_culling_private.html#a01823add2c1ecb901aea5156e3e3113f">More...</a><br /></td></tr>
<tr class="separator:a01823add2c1ecb901aea5156e3e3113f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630958c9164488ac24c23f36482a69fb"><td class="memItemLeft" align="right" valign="top"><a id="a630958c9164488ac24c23f36482a69fb"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#a630958c9164488ac24c23f36482a69fb">GetNearClipPlane</a> () const override</td></tr>
<tr class="memdesc:a630958c9164488ac24c23f36482a69fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the distance for the near clipping plane. <br /></td></tr>
<tr class="separator:a630958c9164488ac24c23f36482a69fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5340952213b62181ac66d6dfa8bb3760"><td class="memItemLeft" align="right" valign="top"><a id="a5340952213b62181ac66d6dfa8bb3760"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#a5340952213b62181ac66d6dfa8bb3760">ClearBuffer</a> () override</td></tr>
<tr class="memdesc:a5340952213b62181ac66d6dfa8bb3760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the hierarchical depth buffer. <br /></td></tr>
<tr class="separator:a5340952213b62181ac66d6dfa8bb3760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd0f537e4c237976eb8633d7113b606"><td class="memItemLeft" align="right" valign="top"><a id="a3dd0f537e4c237976eb8633d7113b606"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#a3dd0f537e4c237976eb8633d7113b606">MergeBuffer</a> (<a class="el" href="class_masked_occlusion_culling.html">MaskedOcclusionCulling</a> *BufferB) override</td></tr>
<tr class="memdesc:a3dd0f537e4c237976eb8633d7113b606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge a second hierarchical depth buffer into the main buffer. <br /></td></tr>
<tr class="separator:a3dd0f537e4c237976eb8633d7113b606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bf862ec03da3e347a8b6754fc2373f"><td class="memItemLeft" align="right" valign="top"><a id="ab3bf862ec03da3e347a8b6754fc2373f"></a>
FORCE_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><b>ClipPolygon</b> (__m128 *outVtx, __m128 *inVtx, const __m128 &amp;plane, int n) const</td></tr>
<tr class="separator:ab3bf862ec03da3e347a8b6754fc2373f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8617a46f5434dcf0b88be68cecb9b3"><td class="memTemplParams" colspan="2"><a id="a7c8617a46f5434dcf0b88be68cecb9b3"></a>
template&lt;ClipPlanes CLIP_PLANE&gt; </td></tr>
<tr class="memitem:a7c8617a46f5434dcf0b88be68cecb9b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TestClipPlane</b> (__mw *vtxX, __mw *vtxY, __mw *vtxW, unsigned int &amp;straddleMask, unsigned int &amp;triMask, ClipPlanes clipPlaneMask)</td></tr>
<tr class="separator:a7c8617a46f5434dcf0b88be68cecb9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61f84555db7c7236f02732baa799379"><td class="memItemLeft" align="right" valign="top"><a id="aa61f84555db7c7236f02732baa799379"></a>
FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>ClipTriangleAndAddToBuffer</b> (__mw *vtxX, __mw *vtxY, __mw *vtxW, __m128 *clippedTrisBuffer, int &amp;clipWriteIdx, unsigned int &amp;triMask, unsigned int triClipMask, ClipPlanes clipPlaneMask)</td></tr>
<tr class="separator:aa61f84555db7c7236f02732baa799379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60cef90eb34564e8b54f7c2e17de6dc"><td class="memItemLeft" align="right" valign="top"><a id="ab60cef90eb34564e8b54f7c2e17de6dc"></a>
FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>TransformVerts</b> (__mw *vtxX, __mw *vtxY, __mw *vtxW, const float *modelToClipMatrix)</td></tr>
<tr class="separator:ab60cef90eb34564e8b54f7c2e17de6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b5a5fb2d4650dbb926f7e2601c6801"><td class="memItemLeft" align="right" valign="top"><a id="a25b5a5fb2d4650dbb926f7e2601c6801"></a>
FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>ProjectVertices</b> (__mw *pVtxX, __mw *pVtxY, __mw *pVtxZ, const __mw *vtxX, const __mw *vtxY, const __mw *vtxW)</td></tr>
<tr class="separator:a25b5a5fb2d4650dbb926f7e2601c6801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22b21d1d0f194fe478117dd5713427c"><td class="memItemLeft" align="right" valign="top"><a id="aa22b21d1d0f194fe478117dd5713427c"></a>
FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>GatherVerticesFast</b> (__mw *vtxX, __mw *vtxY, __mw *vtxW, const float *inVtx, const unsigned int *inTrisPtr, int numLanes)</td></tr>
<tr class="separator:aa22b21d1d0f194fe478117dd5713427c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6418bf5578ea199deba02257659c5d6"><td class="memItemLeft" align="right" valign="top"><a id="af6418bf5578ea199deba02257659c5d6"></a>
FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeBoundingBox</b> (__mwi &amp;bbminX, __mwi &amp;bbminY, __mwi &amp;bbmaxX, __mwi &amp;bbmaxY, const __mw *vX, const __mw *vY, const <a class="el" href="struct_masked_occlusion_culling_1_1_scissor_rect.html">ScissorRect</a> *scissor)</td></tr>
<tr class="separator:af6418bf5578ea199deba02257659c5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea37ac336a271a39c097bc76fe89d15"><td class="memItemLeft" align="right" valign="top"><a id="a7ea37ac336a271a39c097bc76fe89d15"></a>
FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>SortVertices</b> (__mw *vX, __mw *vY)</td></tr>
<tr class="separator:a7ea37ac336a271a39c097bc76fe89d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0986354f10ce48578e3da7c078a7118"><td class="memItemLeft" align="right" valign="top"><a id="ad0986354f10ce48578e3da7c078a7118"></a>
FORCE_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><b>CullBackfaces</b> (__mw *pVtxX, __mw *pVtxY, __mw *pVtxZ, const __mw &amp;ccwMask, BackfaceWinding bfWinding)</td></tr>
<tr class="separator:ad0986354f10ce48578e3da7c078a7118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d3defb725ce604e1934a54a3fbd1ef"><td class="memItemLeft" align="right" valign="top"><a id="af3d3defb725ce604e1934a54a3fbd1ef"></a>
FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeDepthPlane</b> (const __mw *pVtxX, const __mw *pVtxY, const __mw *pVtxZ, __mw &amp;zPixelDx, __mw &amp;zPixelDy) const</td></tr>
<tr class="separator:af3d3defb725ce604e1934a54a3fbd1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df89ec329553b38b9d3d8f6c173988"><td class="memItemLeft" align="right" valign="top"><a id="a06df89ec329553b38b9d3d8f6c173988"></a>
FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateTileQuick</b> (int tileIdx, const __mwi &amp;coverage, const __mw &amp;zTriv)</td></tr>
<tr class="separator:a06df89ec329553b38b9d3d8f6c173988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d2a1e7780ebf08304e6d2e451503da"><td class="memItemLeft" align="right" valign="top"><a id="ab7d2a1e7780ebf08304e6d2e451503da"></a>
FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateTileAccurate</b> (int tileIdx, const __mwi &amp;coverage, const __mw &amp;zTriv)</td></tr>
<tr class="separator:ab7d2a1e7780ebf08304e6d2e451503da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195b65661dcd43492cca558b8abd9932"><td class="memTemplParams" colspan="2"><a id="a195b65661dcd43492cca558b8abd9932"></a>
template&lt;int TEST_Z, int NRIGHT, int NLEFT&gt; </td></tr>
<tr class="memitem:a195b65661dcd43492cca558b8abd9932"><td class="memTemplItemLeft" align="right" valign="top">FORCE_INLINE int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TraverseScanline</b> (int leftOffset, int rightOffset, int tileIdx, int rightEvent, int leftEvent, const __mwi *events, const __mw &amp;zTriMin, const __mw &amp;zTriMax, const __mw &amp;iz0, float zx)</td></tr>
<tr class="separator:a195b65661dcd43492cca558b8abd9932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318d001224210a7a2e3ebc39748925fe"><td class="memTemplParams" colspan="2"><a id="a318d001224210a7a2e3ebc39748925fe"></a>
template&lt;int TEST_Z, int TIGHT_TRAVERSAL, int MID_VTX_RIGHT&gt; </td></tr>
<tr class="memitem:a318d001224210a7a2e3ebc39748925fe"><td class="memTemplItemLeft" align="right" valign="top">FORCE_INLINE int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RasterizeTriangle</b> (unsigned int triIdx, int bbWidth, int tileRowIdx, int tileMidRowIdx, int tileEndRowIdx, const __mwi *eventStart, const __mwi *slope, const __mwi *slopeTileDelta, const __mw &amp;zTriMin, const __mw &amp;zTriMax, __mw &amp;z0, float zx, float zy)</td></tr>
<tr class="separator:a318d001224210a7a2e3ebc39748925fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596e675c0e39d0d451a4293a4c75510e"><td class="memTemplParams" colspan="2"><a id="a596e675c0e39d0d451a4293a4c75510e"></a>
template&lt;bool TEST_Z&gt; </td></tr>
<tr class="memitem:a596e675c0e39d0d451a4293a4c75510e"><td class="memTemplItemLeft" align="right" valign="top">FORCE_INLINE int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RasterizeTriangleBatch</b> (__mw pVtxX[3], __mw pVtxY[3], __mw pVtxZ[3], unsigned int triMask, const <a class="el" href="struct_masked_occlusion_culling_1_1_scissor_rect.html">ScissorRect</a> *scissor)</td></tr>
<tr class="separator:a596e675c0e39d0d451a4293a4c75510e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7e4a3b07720c3c8fd69c0590435d79"><td class="memTemplParams" colspan="2">template&lt;int TEST_Z, int FAST_GATHER&gt; </td></tr>
<tr class="memitem:a8d7e4a3b07720c3c8fd69c0590435d79"><td class="memTemplItemLeft" align="right" valign="top">FORCE_INLINE CullingResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#a8d7e4a3b07720c3c8fd69c0590435d79">RenderTriangles</a> (const float *inVtx, const unsigned int *inTris, int nTris, const float *modelToClipMatrix, BackfaceWinding bfWinding, ClipPlanes clipPlaneMask, const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;vtxLayout)</td></tr>
<tr class="memdesc:a8d7e4a3b07720c3c8fd69c0590435d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a mesh of occluder triangles and updates the hierarchical z buffer with conservative depth values.  <a href="class_masked_occlusion_culling_private.html#a8d7e4a3b07720c3c8fd69c0590435d79">More...</a><br /></td></tr>
<tr class="separator:a8d7e4a3b07720c3c8fd69c0590435d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73becb905c8d1dc3af3635330f3e002"><td class="memItemLeft" align="right" valign="top">CullingResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#ae73becb905c8d1dc3af3635330f3e002">RenderTriangles</a> (const float *inVtx, const unsigned int *inTris, int nTris, const float *modelToClipMatrix, BackfaceWinding bfWinding, ClipPlanes clipPlaneMask, const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;vtxLayout) override</td></tr>
<tr class="memdesc:ae73becb905c8d1dc3af3635330f3e002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a mesh of occluder triangles and updates the hierarchical z buffer with conservative depth values.  <a href="class_masked_occlusion_culling_private.html#ae73becb905c8d1dc3af3635330f3e002">More...</a><br /></td></tr>
<tr class="separator:ae73becb905c8d1dc3af3635330f3e002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b6b262c419d39ce69676839e8c734c"><td class="memItemLeft" align="right" valign="top">CullingResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#ab2b6b262c419d39ce69676839e8c734c">TestTriangles</a> (const float *inVtx, const unsigned int *inTris, int nTris, const float *modelToClipMatrix, BackfaceWinding bfWinding, ClipPlanes clipPlaneMask, const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;vtxLayout) override</td></tr>
<tr class="memdesc:ab2b6b262c419d39ce69676839e8c734c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is similar to <a class="el" href="class_masked_occlusion_culling_private.html#a8d7e4a3b07720c3c8fd69c0590435d79" title="Renders a mesh of occluder triangles and updates the hierarchical z buffer with conservative depth va...">RenderTriangles()</a>, but performs an occlusion query instead and does not update the hierarchical z buffer. The query uses a GREATER_EQUAL (reversed) depth test meaning that depth values equal to the contents of the depth buffer are counted as visible.  <a href="class_masked_occlusion_culling_private.html#ab2b6b262c419d39ce69676839e8c734c">More...</a><br /></td></tr>
<tr class="separator:ab2b6b262c419d39ce69676839e8c734c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc56812ccfe60650d96cd43a19b690a0"><td class="memItemLeft" align="right" valign="top">CullingResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#afc56812ccfe60650d96cd43a19b690a0">TestRect</a> (float xmin, float ymin, float xmax, float ymax, float wmin) const override</td></tr>
<tr class="memdesc:afc56812ccfe60650d96cd43a19b690a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Occlusion query for a rectangle with a given depth. The rectangle is given in normalized device coordinates where (x,y) coordinates between [-1,1] map to the visible screen area. The query uses a GREATER_EQUAL (reversed) depth test meaning that depth values equal to the contents of the depth buffer are counted as visible.  <a href="class_masked_occlusion_culling_private.html#afc56812ccfe60650d96cd43a19b690a0">More...</a><br /></td></tr>
<tr class="separator:afc56812ccfe60650d96cd43a19b690a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176c871898b85c724dc068f76456a37d"><td class="memTemplParams" colspan="2">template&lt;bool FAST_GATHER&gt; </td></tr>
<tr class="memitem:a176c871898b85c724dc068f76456a37d"><td class="memTemplItemLeft" align="right" valign="top">FORCE_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#a176c871898b85c724dc068f76456a37d">BinTriangles</a> (const float *inVtx, const unsigned int *inTris, int nTris, <a class="el" href="struct_masked_occlusion_culling_1_1_tri_list.html">TriList</a> *triLists, unsigned int nBinsW, unsigned int nBinsH, const float *modelToClipMatrix, BackfaceWinding bfWinding, ClipPlanes clipPlaneMask, const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;vtxLayout)</td></tr>
<tr class="memdesc:a176c871898b85c724dc068f76456a37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform input assembly, clipping , projection, triangle setup, and write triangles to the screen space bins they overlap. This function can be used to distribute work for threading (See the CullingThreadpool class for an example)  <a href="class_masked_occlusion_culling_private.html#a176c871898b85c724dc068f76456a37d">More...</a><br /></td></tr>
<tr class="separator:a176c871898b85c724dc068f76456a37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88cf80ede8f35e985388fb196ba0455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#aa88cf80ede8f35e985388fb196ba0455">BinTriangles</a> (const float *inVtx, const unsigned int *inTris, int nTris, <a class="el" href="struct_masked_occlusion_culling_1_1_tri_list.html">TriList</a> *triLists, unsigned int nBinsW, unsigned int nBinsH, const float *modelToClipMatrix, BackfaceWinding bfWinding, ClipPlanes clipPlaneMask, const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;vtxLayout) override</td></tr>
<tr class="memdesc:aa88cf80ede8f35e985388fb196ba0455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform input assembly, clipping , projection, triangle setup, and write triangles to the screen space bins they overlap. This function can be used to distribute work for threading (See the CullingThreadpool class for an example)  <a href="class_masked_occlusion_culling_private.html#aa88cf80ede8f35e985388fb196ba0455">More...</a><br /></td></tr>
<tr class="separator:aa88cf80ede8f35e985388fb196ba0455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb017e8d86a0fe3149798da6d41fdf6"><td class="memTemplParams" colspan="2"><a id="a6eb017e8d86a0fe3149798da6d41fdf6"></a>
template&lt;int FAST_GATHER&gt; </td></tr>
<tr class="memitem:a6eb017e8d86a0fe3149798da6d41fdf6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GatherTransformClip</b> (int &amp;clipHead, int &amp;clipTail, int &amp;numLanes, int nTris, int &amp;triIndex, __mw *vtxX, __mw *vtxY, __mw *vtxW, const float *inVtx, const unsigned int *&amp;inTrisPtr, const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;vtxLayout, const float *modelToClipMatrix, __m128 *clipTriBuffer, unsigned int &amp;triMask, ClipPlanes clipPlaneMask)</td></tr>
<tr class="separator:a6eb017e8d86a0fe3149798da6d41fdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0157e0f6969772f3c7184b01fcc0ca6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#ac0157e0f6969772f3c7184b01fcc0ca6">RenderTrilist</a> (const <a class="el" href="struct_masked_occlusion_culling_1_1_tri_list.html">TriList</a> &amp;triList, const <a class="el" href="struct_masked_occlusion_culling_1_1_scissor_rect.html">ScissorRect</a> *scissor) override</td></tr>
<tr class="memdesc:ac0157e0f6969772f3c7184b01fcc0ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders all occluder triangles in a trilist. This function can be used in combination with <a class="el" href="class_masked_occlusion_culling_private.html#a176c871898b85c724dc068f76456a37d" title="Perform input assembly, clipping , projection, triangle setup, and write triangles to the screen spac...">BinTriangles()</a> to create a threded (binning) rasterizer. The bins can be processed independently by different threads without risking writing to overlapping memory regions.  <a href="class_masked_occlusion_culling_private.html#ac0157e0f6969772f3c7184b01fcc0ca6">More...</a><br /></td></tr>
<tr class="separator:ac0157e0f6969772f3c7184b01fcc0ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642307b82a3951aee3ca89942dcc189c"><td class="memItemLeft" align="right" valign="top"><a id="a642307b82a3951aee3ca89942dcc189c"></a>
MaskedOcclusionCulling::Implementation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#a642307b82a3951aee3ca89942dcc189c">GetImplementation</a> () override</td></tr>
<tr class="memdesc:a642307b82a3951aee3ca89942dcc189c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the implementation (CPU instruction set) version of this object. <br /></td></tr>
<tr class="separator:a642307b82a3951aee3ca89942dcc189c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fc1fc20aa42debd379c537676b78c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#ab9fc1fc20aa42debd379c537676b78c9">ComputePixelDepthBuffer</a> (float *depthData, bool flipY) override</td></tr>
<tr class="memdesc:ab9fc1fc20aa42debd379c537676b78c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a per-pixel depth buffer from the hierarchical z buffer representation. Intended for visualizing the hierarchical depth buffer for debugging. The buffer is written in scanline order, from the top to bottom (D3D) or bottom to top (OGL) of the surface. See the USE_D3D define.  <a href="class_masked_occlusion_culling_private.html#ab9fc1fc20aa42debd379c537676b78c9">More...</a><br /></td></tr>
<tr class="separator:ab9fc1fc20aa42debd379c537676b78c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049499f2bf17bda2af28cb2874849e22"><td class="memItemLeft" align="right" valign="top"><a id="a049499f2bf17bda2af28cb2874849e22"></a>
<a class="el" href="struct_masked_occlusion_culling_1_1_occlusion_culling_statistics.html">OcclusionCullingStatistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling_private.html#a049499f2bf17bda2af28cb2874849e22">GetStatistics</a> () override</td></tr>
<tr class="memdesc:a049499f2bf17bda2af28cb2874849e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch occlusion culling statistics, returns zeroes if ENABLE_STATS define is not defined. The statistics can be used for profiling or debugging. <br /></td></tr>
<tr class="separator:a049499f2bf17bda2af28cb2874849e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_masked_occlusion_culling"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_masked_occlusion_culling')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_masked_occlusion_culling.html">MaskedOcclusionCulling</a></td></tr>
<tr class="memitem:af51f2ec3444351a3576da99ccf157213 inherit pub_methods_class_masked_occlusion_culling"><td class="memItemLeft" align="right" valign="top"><a id="af51f2ec3444351a3576da99ccf157213"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#af51f2ec3444351a3576da99ccf157213">GetAllocFreeCallback</a> (pfnAlignedAlloc &amp;allocCallback, pfnAlignedFree &amp;freeCallback)</td></tr>
<tr class="memdesc:af51f2ec3444351a3576da99ccf157213 inherit pub_methods_class_masked_occlusion_culling"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get used memory alloc/free callbacks. <br /></td></tr>
<tr class="separator:af51f2ec3444351a3576da99ccf157213 inherit pub_methods_class_masked_occlusion_culling"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a20e14bfd979b467617d57154556dc105"><td class="memItemLeft" align="right" valign="top"><a id="a20e14bfd979b467617d57154556dc105"></a>
__mw&#160;</td><td class="memItemRight" valign="bottom"><b>mHalfWidth</b></td></tr>
<tr class="separator:a20e14bfd979b467617d57154556dc105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3560051250d06ca2df7f7f28fceadf14"><td class="memItemLeft" align="right" valign="top"><a id="a3560051250d06ca2df7f7f28fceadf14"></a>
__mw&#160;</td><td class="memItemRight" valign="bottom"><b>mHalfHeight</b></td></tr>
<tr class="separator:a3560051250d06ca2df7f7f28fceadf14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675291b59415006a3e19e7021f17a58f"><td class="memItemLeft" align="right" valign="top"><a id="a675291b59415006a3e19e7021f17a58f"></a>
__mw&#160;</td><td class="memItemRight" valign="bottom"><b>mCenterX</b></td></tr>
<tr class="separator:a675291b59415006a3e19e7021f17a58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74780d83cd952baf520767e57a70703a"><td class="memItemLeft" align="right" valign="top"><a id="a74780d83cd952baf520767e57a70703a"></a>
__mw&#160;</td><td class="memItemRight" valign="bottom"><b>mCenterY</b></td></tr>
<tr class="separator:a74780d83cd952baf520767e57a70703a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8fbfa6dd5d76382a17cea09cec17d0"><td class="memItemLeft" align="right" valign="top"><a id="a4a8fbfa6dd5d76382a17cea09cec17d0"></a>
__m128&#160;</td><td class="memItemRight" valign="bottom"><b>mCSFrustumPlanes</b> [5]</td></tr>
<tr class="separator:a4a8fbfa6dd5d76382a17cea09cec17d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204be50bf23b2c6d4cca726b259fe27f"><td class="memItemLeft" align="right" valign="top"><a id="a204be50bf23b2c6d4cca726b259fe27f"></a>
__m128&#160;</td><td class="memItemRight" valign="bottom"><b>mIHalfSize</b></td></tr>
<tr class="separator:a204be50bf23b2c6d4cca726b259fe27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb555ddbb5803f1b12edb5d4a68ec94e"><td class="memItemLeft" align="right" valign="top"><a id="acb555ddbb5803f1b12edb5d4a68ec94e"></a>
__m128&#160;</td><td class="memItemRight" valign="bottom"><b>mICenter</b></td></tr>
<tr class="separator:acb555ddbb5803f1b12edb5d4a68ec94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2483fb8ed81735a1a5b95c576263702c"><td class="memItemLeft" align="right" valign="top"><a id="a2483fb8ed81735a1a5b95c576263702c"></a>
__m128i&#160;</td><td class="memItemRight" valign="bottom"><b>mIScreenSize</b></td></tr>
<tr class="separator:a2483fb8ed81735a1a5b95c576263702c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a45ffa9738f9a1f6618b16af45211e0"><td class="memItemLeft" align="right" valign="top"><a id="a0a45ffa9738f9a1f6618b16af45211e0"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>mNearDist</b></td></tr>
<tr class="separator:a0a45ffa9738f9a1f6618b16af45211e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197bd86f91d62ec8a30fbf3ca8713957"><td class="memItemLeft" align="right" valign="top"><a id="a197bd86f91d62ec8a30fbf3ca8713957"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mWidth</b></td></tr>
<tr class="separator:a197bd86f91d62ec8a30fbf3ca8713957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5fa8851d73cac13ea79a9fdd5a0d91"><td class="memItemLeft" align="right" valign="top"><a id="a3f5fa8851d73cac13ea79a9fdd5a0d91"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mHeight</b></td></tr>
<tr class="separator:a3f5fa8851d73cac13ea79a9fdd5a0d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a48d8de93796419706e5aea71637f67"><td class="memItemLeft" align="right" valign="top"><a id="a3a48d8de93796419706e5aea71637f67"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mTilesWidth</b></td></tr>
<tr class="separator:a3a48d8de93796419706e5aea71637f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae336139e3d3d7fbddcd8df302b94d88f"><td class="memItemLeft" align="right" valign="top"><a id="ae336139e3d3d7fbddcd8df302b94d88f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mTilesHeight</b></td></tr>
<tr class="separator:ae336139e3d3d7fbddcd8df302b94d88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e157f15d674218c5d9bad46ac31be8a"><td class="memItemLeft" align="right" valign="top"><a id="a3e157f15d674218c5d9bad46ac31be8a"></a>
<a class="el" href="struct_masked_occlusion_culling_private_1_1_z_tile.html">ZTile</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mMaskedHiZBuffer</b></td></tr>
<tr class="separator:a3e157f15d674218c5d9bad46ac31be8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43590bc6f70e2eb7f29b12bebc69f31"><td class="memItemLeft" align="right" valign="top"><a id="ac43590bc6f70e2eb7f29b12bebc69f31"></a>
<a class="el" href="struct_masked_occlusion_culling_1_1_scissor_rect.html">ScissorRect</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mFullscreenScissor</b></td></tr>
<tr class="separator:ac43590bc6f70e2eb7f29b12bebc69f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_class_masked_occlusion_culling"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_masked_occlusion_culling')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_masked_occlusion_culling.html">MaskedOcclusionCulling</a></td></tr>
<tr class="memitem:a45f29275099296b3b5d0cce506f759bd inherit pub_types_class_masked_occlusion_culling"><td class="memItemLeft" align="right" valign="top"><a id="a45f29275099296b3b5d0cce506f759bd"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Implementation</b> { <b>SSE2</b> = 0
, <b>SSE41</b> = 1
, <b>AVX2</b> = 2
, <b>AVX512</b> = 3
 }</td></tr>
<tr class="separator:a45f29275099296b3b5d0cce506f759bd inherit pub_types_class_masked_occlusion_culling"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8492bae7e15c3c6491466acf06eef488 inherit pub_types_class_masked_occlusion_culling"><td class="memItemLeft" align="right" valign="top"><a id="a8492bae7e15c3c6491466acf06eef488"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BackfaceWinding</b> { <b>BACKFACE_NONE</b> = 0
, <b>BACKFACE_CW</b> = 1
, <b>BACKFACE_CCW</b> = 2
 }</td></tr>
<tr class="separator:a8492bae7e15c3c6491466acf06eef488 inherit pub_types_class_masked_occlusion_culling"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d289b9e1152750707dea597c294d3a3 inherit pub_types_class_masked_occlusion_culling"><td class="memItemLeft" align="right" valign="top"><a id="a0d289b9e1152750707dea597c294d3a3"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>CullingResult</b> { <b>VISIBLE</b> = 0x0
, <b>OCCLUDED</b> = 0x1
, <b>VIEW_CULLED</b> = 0x3
 }</td></tr>
<tr class="separator:a0d289b9e1152750707dea597c294d3a3 inherit pub_types_class_masked_occlusion_culling"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80af7d22acd7b23f0fc87aa2ac852f9 inherit pub_types_class_masked_occlusion_culling"><td class="memItemLeft" align="right" valign="top"><a id="af80af7d22acd7b23f0fc87aa2ac852f9"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ClipPlanes</b> { <br />
&#160;&#160;<b>CLIP_PLANE_NONE</b> = 0x00
, <b>CLIP_PLANE_NEAR</b> = 0x01
, <b>CLIP_PLANE_LEFT</b> = 0x02
, <b>CLIP_PLANE_RIGHT</b> = 0x04
, <br />
&#160;&#160;<b>CLIP_PLANE_BOTTOM</b> = 0x08
, <b>CLIP_PLANE_TOP</b> = 0x10
, <b>CLIP_PLANE_SIDES</b> = (CLIP_PLANE_LEFT | CLIP_PLANE_RIGHT | CLIP_PLANE_BOTTOM | CLIP_PLANE_TOP)
, <b>CLIP_PLANE_ALL</b> = (CLIP_PLANE_LEFT | CLIP_PLANE_RIGHT | CLIP_PLANE_BOTTOM | CLIP_PLANE_TOP | CLIP_PLANE_NEAR)
<br />
 }</td></tr>
<tr class="separator:af80af7d22acd7b23f0fc87aa2ac852f9 inherit pub_types_class_masked_occlusion_culling"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ff9e33a4f87a3791eb5b7dd1b8e16c inherit pub_types_class_masked_occlusion_culling"><td class="memItemLeft" align="right" valign="top"><a id="a89ff9e33a4f87a3791eb5b7dd1b8e16c"></a>
typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><b>pfnAlignedAlloc</b>) (size_t alignment, size_t size)</td></tr>
<tr class="separator:a89ff9e33a4f87a3791eb5b7dd1b8e16c inherit pub_types_class_masked_occlusion_culling"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecb44fd14619ed0ebc8f547a21b11df inherit pub_types_class_masked_occlusion_culling"><td class="memItemLeft" align="right" valign="top"><a id="adecb44fd14619ed0ebc8f547a21b11df"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>pfnAlignedFree</b>) (void *ptr)</td></tr>
<tr class="separator:adecb44fd14619ed0ebc8f547a21b11df inherit pub_types_class_masked_occlusion_culling"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_masked_occlusion_culling"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_masked_occlusion_culling')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_masked_occlusion_culling.html">MaskedOcclusionCulling</a></td></tr>
<tr class="memitem:a234f5d08c60646a0b524b18efe4d113c inherit pub_static_methods_class_masked_occlusion_culling"><td class="memItemLeft" align="right" valign="top"><a id="a234f5d08c60646a0b524b18efe4d113c"></a>
static <a class="el" href="class_masked_occlusion_culling.html">MaskedOcclusionCulling</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a234f5d08c60646a0b524b18efe4d113c">Create</a> (Implementation RequestedSIMD=AVX512)</td></tr>
<tr class="memdesc:a234f5d08c60646a0b524b18efe4d113c inherit pub_static_methods_class_masked_occlusion_culling"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object with default state, no z buffer attached/allocated. <br /></td></tr>
<tr class="separator:a234f5d08c60646a0b524b18efe4d113c inherit pub_static_methods_class_masked_occlusion_culling"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3d6187c1d9d2435d593840bab422e4 inherit pub_static_methods_class_masked_occlusion_culling"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_masked_occlusion_culling.html">MaskedOcclusionCulling</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a0f3d6187c1d9d2435d593840bab422e4">Create</a> (Implementation RequestedSIMD, pfnAlignedAlloc alignedAlloc, pfnAlignedFree alignedFree)</td></tr>
<tr class="memdesc:a0f3d6187c1d9d2435d593840bab422e4 inherit pub_static_methods_class_masked_occlusion_culling"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object with default state, no z buffer attached/allocated.  <a href="class_masked_occlusion_culling.html#a0f3d6187c1d9d2435d593840bab422e4">More...</a><br /></td></tr>
<tr class="separator:a0f3d6187c1d9d2435d593840bab422e4 inherit pub_static_methods_class_masked_occlusion_culling"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b58c7c50559afb190ea7b212164962c inherit pub_static_methods_class_masked_occlusion_culling"><td class="memItemLeft" align="right" valign="top"><a id="a6b58c7c50559afb190ea7b212164962c"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#a6b58c7c50559afb190ea7b212164962c">Destroy</a> (<a class="el" href="class_masked_occlusion_culling.html">MaskedOcclusionCulling</a> *moc)</td></tr>
<tr class="memdesc:a6b58c7c50559afb190ea7b212164962c inherit pub_static_methods_class_masked_occlusion_culling"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an object and frees the z buffer memory. Note that you cannot use the delete operator, and should rather use this function to free up memory. <br /></td></tr>
<tr class="separator:a6b58c7c50559afb190ea7b212164962c inherit pub_static_methods_class_masked_occlusion_culling"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91b40d11fd7323fc8a9556608fadce5 inherit pub_static_methods_class_masked_occlusion_culling"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_masked_occlusion_culling.html#ac91b40d11fd7323fc8a9556608fadce5">TransformVertices</a> (const float *mtx, const float *inVtx, float *xfVtx, unsigned int nVtx, const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;vtxLayout=<a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a>(12, 4, 8))</td></tr>
<tr class="memdesc:ac91b40d11fd7323fc8a9556608fadce5 inherit pub_static_methods_class_masked_occlusion_culling"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for transforming vertices and outputting them to an (x,y,z,w) format suitable for the occluder rasterization and occludee testing functions.  <a href="class_masked_occlusion_culling.html#ac91b40d11fd7323fc8a9556608fadce5">More...</a><br /></td></tr>
<tr class="separator:ac91b40d11fd7323fc8a9556608fadce5 inherit pub_static_methods_class_masked_occlusion_culling"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_masked_occlusion_culling"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_masked_occlusion_culling')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_masked_occlusion_culling.html">MaskedOcclusionCulling</a></td></tr>
<tr class="memitem:a42e0b9f44bc170702f1d04dd319c1707 inherit pro_attribs_class_masked_occlusion_culling"><td class="memItemLeft" align="right" valign="top"><a id="a42e0b9f44bc170702f1d04dd319c1707"></a>
pfnAlignedAlloc&#160;</td><td class="memItemRight" valign="bottom"><b>mAlignedAllocCallback</b></td></tr>
<tr class="separator:a42e0b9f44bc170702f1d04dd319c1707 inherit pro_attribs_class_masked_occlusion_culling"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754a3d68084b5d7833ccecde6b9881be inherit pro_attribs_class_masked_occlusion_culling"><td class="memItemLeft" align="right" valign="top"><a id="a754a3d68084b5d7833ccecde6b9881be"></a>
pfnAlignedFree&#160;</td><td class="memItemRight" valign="bottom"><b>mAlignedFreeCallback</b></td></tr>
<tr class="separator:a754a3d68084b5d7833ccecde6b9881be inherit pro_attribs_class_masked_occlusion_culling"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c70a3e8f3b764d5237eecdabccc8d6 inherit pro_attribs_class_masked_occlusion_culling"><td class="memItemLeft" align="right" valign="top"><a id="a55c70a3e8f3b764d5237eecdabccc8d6"></a>
<a class="el" href="struct_masked_occlusion_culling_1_1_occlusion_culling_statistics.html">OcclusionCullingStatistics</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mStats</b></td></tr>
<tr class="separator:a55c70a3e8f3b764d5237eecdabccc8d6 inherit pro_attribs_class_masked_occlusion_culling"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a176c871898b85c724dc068f76456a37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176c871898b85c724dc068f76456a37d">&#9670;&nbsp;</a></span>BinTriangles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool FAST_GATHER&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FORCE_INLINE void MaskedOcclusionCullingPrivate::BinTriangles </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>inVtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>inTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_masked_occlusion_culling_1_1_tri_list.html">TriList</a> *&#160;</td>
          <td class="paramname"><em>triLists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nBinsW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nBinsH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>modelToClipMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackfaceWinding&#160;</td>
          <td class="paramname"><em>bfWinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ClipPlanes&#160;</td>
          <td class="paramname"><em>clipPlaneMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>vtxLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform input assembly, clipping , projection, triangle setup, and write triangles to the screen space bins they overlap. This function can be used to distribute work for threading (See the CullingThreadpool class for an example) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inVtx</td><td>Pointer to an array of input vertices, should point to the x component of the first vertex. The input vertices are given as (x,y,w) coordinates in clip space. The memory layout can be changed using vtxLayout. </td></tr>
    <tr><td class="paramname">inTris</td><td>Pointer to an array of vertex indices. Each triangle is created from three indices consecutively fetched from the array. </td></tr>
    <tr><td class="paramname">nTris</td><td>The number of triangles to render (inTris must contain atleast 3*nTris entries) </td></tr>
    <tr><td class="paramname">triLists</td><td>Pointer to an array of TriList objects with one TriList object per bin. If a triangle overlaps a bin, it will be written to the corresponding trilist. Note that this method appends the triangles to the current list, to start writing from the beginning of the list, set triList.mTriIdx = 0 </td></tr>
    <tr><td class="paramname">nBinsW</td><td>Number of vertical bins, the screen is divided into nBinsW x nBinsH rectangular bins. </td></tr>
    <tr><td class="paramname">nBinsH</td><td>Number of horizontal bins, the screen is divided into nBinsW x nBinsH rectangular bins. </td></tr>
    <tr><td class="paramname">modelToClipMatrix</td><td>all vertices will be transformed by this matrix before performing projection. If nullptr is passed the transform step will be skipped </td></tr>
    <tr><td class="paramname">clipPlaneMask</td><td>A mask indicating which clip planes should be considered by the triangle clipper. Can be used as an optimization if your application can determine (for example during culling) that a group of triangles does not intersect a certain frustum plane. However, setting an incorrect mask may cause out of bounds memory accesses. </td></tr>
    <tr><td class="paramname">vtxLayout</td><td>A struct specifying the vertex layout (see struct for detailed description). For best performance, it is advisable to store position data as compactly in memory as possible. </td></tr>
    <tr><td class="paramname">bfWinding</td><td>Sets triangle winding order to consider backfacing, must be one one of (BACKFACE_NONE, BACKFACE_CW and BACKFACE_CCW). Back-facing triangles are culled and will not be binned / rasterized. You may use BACKFACE_NONE to disable culling for double sided geometry </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_masked_occlusion_culling.html#a666fb7b9205a16c0c2df3117f9bc632c">MaskedOcclusionCulling</a>.</p>

</div>
</div>
<a id="aa88cf80ede8f35e985388fb196ba0455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88cf80ede8f35e985388fb196ba0455">&#9670;&nbsp;</a></span>BinTriangles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MaskedOcclusionCullingPrivate::BinTriangles </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>inVtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>inTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_masked_occlusion_culling_1_1_tri_list.html">TriList</a> *&#160;</td>
          <td class="paramname"><em>triLists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nBinsW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nBinsH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>modelToClipMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackfaceWinding&#160;</td>
          <td class="paramname"><em>bfWinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ClipPlanes&#160;</td>
          <td class="paramname"><em>clipPlaneMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>vtxLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform input assembly, clipping , projection, triangle setup, and write triangles to the screen space bins they overlap. This function can be used to distribute work for threading (See the CullingThreadpool class for an example) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inVtx</td><td>Pointer to an array of input vertices, should point to the x component of the first vertex. The input vertices are given as (x,y,w) coordinates in clip space. The memory layout can be changed using vtxLayout. </td></tr>
    <tr><td class="paramname">inTris</td><td>Pointer to an array of vertex indices. Each triangle is created from three indices consecutively fetched from the array. </td></tr>
    <tr><td class="paramname">nTris</td><td>The number of triangles to render (inTris must contain atleast 3*nTris entries) </td></tr>
    <tr><td class="paramname">triLists</td><td>Pointer to an array of TriList objects with one TriList object per bin. If a triangle overlaps a bin, it will be written to the corresponding trilist. Note that this method appends the triangles to the current list, to start writing from the beginning of the list, set triList.mTriIdx = 0 </td></tr>
    <tr><td class="paramname">nBinsW</td><td>Number of vertical bins, the screen is divided into nBinsW x nBinsH rectangular bins. </td></tr>
    <tr><td class="paramname">nBinsH</td><td>Number of horizontal bins, the screen is divided into nBinsW x nBinsH rectangular bins. </td></tr>
    <tr><td class="paramname">modelToClipMatrix</td><td>all vertices will be transformed by this matrix before performing projection. If nullptr is passed the transform step will be skipped </td></tr>
    <tr><td class="paramname">clipPlaneMask</td><td>A mask indicating which clip planes should be considered by the triangle clipper. Can be used as an optimization if your application can determine (for example during culling) that a group of triangles does not intersect a certain frustum plane. However, setting an incorrect mask may cause out of bounds memory accesses. </td></tr>
    <tr><td class="paramname">vtxLayout</td><td>A struct specifying the vertex layout (see struct for detailed description). For best performance, it is advisable to store position data as compactly in memory as possible. </td></tr>
    <tr><td class="paramname">bfWinding</td><td>Sets triangle winding order to consider backfacing, must be one one of (BACKFACE_NONE, BACKFACE_CW and BACKFACE_CCW). Back-facing triangles are culled and will not be binned / rasterized. You may use BACKFACE_NONE to disable culling for double sided geometry </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_masked_occlusion_culling.html#a666fb7b9205a16c0c2df3117f9bc632c">MaskedOcclusionCulling</a>.</p>

</div>
</div>
<a id="a67c8e5e75f8d96c6e8e9bb8394bde412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c8e5e75f8d96c6e8e9bb8394bde412">&#9670;&nbsp;</a></span>ComputeBinWidthHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MaskedOcclusionCullingPrivate::ComputeBinWidthHeight </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nBinsW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nBinsH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>outBinWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>outBinHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tile size for the current implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nBinsW</td><td>Number of vertical bins, the screen is divided into nBinsW x nBinsH rectangular bins. </td></tr>
    <tr><td class="paramname">nBinsH</td><td>Number of horizontal bins, the screen is divided into nBinsW x nBinsH rectangular bins. </td></tr>
    <tr><td class="paramname">outBinWidth</td><td>Output: The width of the single bin in pixels (except for the rightmost bin width, which is extended to resolution width) </td></tr>
    <tr><td class="paramname">outBinHeight</td><td>Output: The height of the single bin in pixels (except for the bottommost bin height, which is extended to resolution height) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_masked_occlusion_culling.html#a5605061cd58ee62cf71d18fe84229aff">MaskedOcclusionCulling</a>.</p>

</div>
</div>
<a id="ab9fc1fc20aa42debd379c537676b78c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fc1fc20aa42debd379c537676b78c9">&#9670;&nbsp;</a></span>ComputePixelDepthBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MaskedOcclusionCullingPrivate::ComputePixelDepthBuffer </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>depthData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a per-pixel depth buffer from the hierarchical z buffer representation. Intended for visualizing the hierarchical depth buffer for debugging. The buffer is written in scanline order, from the top to bottom (D3D) or bottom to top (OGL) of the surface. See the USE_D3D define. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthData</td><td>Pointer to memory where the per-pixel depth data is written. Must hold storage for atleast width*height elements as set by setResolution. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_masked_occlusion_culling.html#a4b6ed10a1f5eeab63769ca015443b5e7">MaskedOcclusionCulling</a>.</p>

</div>
</div>
<a id="a26145c22cf52281d84b501a09ead3802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26145c22cf52281d84b501a09ead3802">&#9670;&nbsp;</a></span>GetResolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MaskedOcclusionCullingPrivate::GetResolution </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the resolution of the hierarchical depth buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">witdh</td><td>Output: The width of the buffer in pixels </td></tr>
    <tr><td class="paramname">height</td><td>Output: The height of the buffer in pixels </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_masked_occlusion_culling.html#a66073be3b909a4c9d6b057c984b5ab0b">MaskedOcclusionCulling</a>.</p>

</div>
</div>
<a id="a8d7e4a3b07720c3c8fd69c0590435d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7e4a3b07720c3c8fd69c0590435d79">&#9670;&nbsp;</a></span>RenderTriangles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int TEST_Z, int FAST_GATHER&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FORCE_INLINE CullingResult MaskedOcclusionCullingPrivate::RenderTriangles </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>inVtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>inTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>modelToClipMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackfaceWinding&#160;</td>
          <td class="paramname"><em>bfWinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ClipPlanes&#160;</td>
          <td class="paramname"><em>clipPlaneMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>vtxLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a mesh of occluder triangles and updates the hierarchical z buffer with conservative depth values. </p>
<p>This function is optimized for vertex layouts with stride 16 and y and w offsets of 4 and 12 bytes, respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inVtx</td><td>Pointer to an array of input vertices, should point to the x component of the first vertex. The input vertices are given as (x,y,w) coordinates in clip space. The memory layout can be changed using vtxLayout. </td></tr>
    <tr><td class="paramname">inTris</td><td>Pointer to an array of vertex indices. Each triangle is created from three indices consecutively fetched from the array. </td></tr>
    <tr><td class="paramname">nTris</td><td>The number of triangles to render (inTris must contain atleast 3*nTris entries) </td></tr>
    <tr><td class="paramname">modelToClipMatrix</td><td>all vertices will be transformed by this matrix before performing projection. If nullptr is passed the transform step will be skipped </td></tr>
    <tr><td class="paramname">bfWinding</td><td>Sets triangle winding order to consider backfacing, must be one one of (BACKFACE_NONE, BACKFACE_CW and BACKFACE_CCW). Back-facing triangles are culled and will not be rasterized. You may use BACKFACE_NONE to disable culling for double sided geometry </td></tr>
    <tr><td class="paramname">clipPlaneMask</td><td>A mask indicating which clip planes should be considered by the triangle clipper. Can be used as an optimization if your application can determine (for example during culling) that a group of triangles does not intersect a certain frustum plane. However, setting an incorrect mask may cause out of bounds memory accesses. </td></tr>
    <tr><td class="paramname">vtxLayout</td><td>A struct specifying the vertex layout (see struct for detailed description). For best performance, it is advisable to store position data as compactly in memory as possible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Will return VIEW_CULLED if all triangles are either outside the frustum or backface culled, returns VISIBLE otherwise. </dd></dl>

<p>Implements <a class="el" href="class_masked_occlusion_culling.html#a125dfdd5057dd6ae541720c63ccbd097">MaskedOcclusionCulling</a>.</p>

</div>
</div>
<a id="ae73becb905c8d1dc3af3635330f3e002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73becb905c8d1dc3af3635330f3e002">&#9670;&nbsp;</a></span>RenderTriangles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CullingResult MaskedOcclusionCullingPrivate::RenderTriangles </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>inVtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>inTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>modelToClipMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackfaceWinding&#160;</td>
          <td class="paramname"><em>bfWinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ClipPlanes&#160;</td>
          <td class="paramname"><em>clipPlaneMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>vtxLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a mesh of occluder triangles and updates the hierarchical z buffer with conservative depth values. </p>
<p>This function is optimized for vertex layouts with stride 16 and y and w offsets of 4 and 12 bytes, respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inVtx</td><td>Pointer to an array of input vertices, should point to the x component of the first vertex. The input vertices are given as (x,y,w) coordinates in clip space. The memory layout can be changed using vtxLayout. </td></tr>
    <tr><td class="paramname">inTris</td><td>Pointer to an array of vertex indices. Each triangle is created from three indices consecutively fetched from the array. </td></tr>
    <tr><td class="paramname">nTris</td><td>The number of triangles to render (inTris must contain atleast 3*nTris entries) </td></tr>
    <tr><td class="paramname">modelToClipMatrix</td><td>all vertices will be transformed by this matrix before performing projection. If nullptr is passed the transform step will be skipped </td></tr>
    <tr><td class="paramname">bfWinding</td><td>Sets triangle winding order to consider backfacing, must be one one of (BACKFACE_NONE, BACKFACE_CW and BACKFACE_CCW). Back-facing triangles are culled and will not be rasterized. You may use BACKFACE_NONE to disable culling for double sided geometry </td></tr>
    <tr><td class="paramname">clipPlaneMask</td><td>A mask indicating which clip planes should be considered by the triangle clipper. Can be used as an optimization if your application can determine (for example during culling) that a group of triangles does not intersect a certain frustum plane. However, setting an incorrect mask may cause out of bounds memory accesses. </td></tr>
    <tr><td class="paramname">vtxLayout</td><td>A struct specifying the vertex layout (see struct for detailed description). For best performance, it is advisable to store position data as compactly in memory as possible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Will return VIEW_CULLED if all triangles are either outside the frustum or backface culled, returns VISIBLE otherwise. </dd></dl>

<p>Implements <a class="el" href="class_masked_occlusion_culling.html#a125dfdd5057dd6ae541720c63ccbd097">MaskedOcclusionCulling</a>.</p>

</div>
</div>
<a id="ac0157e0f6969772f3c7184b01fcc0ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0157e0f6969772f3c7184b01fcc0ca6">&#9670;&nbsp;</a></span>RenderTrilist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MaskedOcclusionCullingPrivate::RenderTrilist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_masked_occlusion_culling_1_1_tri_list.html">TriList</a> &amp;&#160;</td>
          <td class="paramname"><em>triList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_masked_occlusion_culling_1_1_scissor_rect.html">ScissorRect</a> *&#160;</td>
          <td class="paramname"><em>scissor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders all occluder triangles in a trilist. This function can be used in combination with <a class="el" href="class_masked_occlusion_culling_private.html#a176c871898b85c724dc068f76456a37d" title="Perform input assembly, clipping , projection, triangle setup, and write triangles to the screen spac...">BinTriangles()</a> to create a threded (binning) rasterizer. The bins can be processed independently by different threads without risking writing to overlapping memory regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triLists</td><td>A triangle list, filled using the <a class="el" href="class_masked_occlusion_culling_private.html#a176c871898b85c724dc068f76456a37d" title="Perform input assembly, clipping , projection, triangle setup, and write triangles to the screen spac...">BinTriangles()</a> function that is to be rendered. </td></tr>
    <tr><td class="paramname">scissor</td><td>A scissor box limiting the rendering region to the bin. The size of each bin must be a multiple of 32x8 pixels due to implementation constraints. For a render target with (width, height) resolution and (nBinsW, nBinsH) bins, the size of a bin is: binWidth = (width / nBinsW) - (width / nBinsW) % 32; binHeight = (height / nBinsH) - (height / nBinsH) % 8; The last row and column of tiles have a different size: lastColBinWidth = width - (nBinsW-1)*binWidth; lastRowBinHeight = height - (nBinsH-1)*binHeight; </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_masked_occlusion_culling.html#a976bed9467e6022bed44af7e240cba5e">MaskedOcclusionCulling</a>.</p>

</div>
</div>
<a id="a01823add2c1ecb901aea5156e3e3113f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01823add2c1ecb901aea5156e3e3113f">&#9670;&nbsp;</a></span>SetNearClipPlane()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MaskedOcclusionCullingPrivate::SetNearClipPlane </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>nearDist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the distance for the near clipping plane. Default is nearDist = 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nearDist</td><td>The distance to the near clipping plane, given as clip space w </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_masked_occlusion_culling.html#a4aff6b2f29f019d64cc6f8c0acc00ad8">MaskedOcclusionCulling</a>.</p>

</div>
</div>
<a id="a941f778b10002a256bf081231279e4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941f778b10002a256bf081231279e4b9">&#9670;&nbsp;</a></span>SetResolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MaskedOcclusionCullingPrivate::SetResolution </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the resolution of the hierarchical depth buffer. This function will re-allocate the current depth buffer (if present). The contents of the buffer is undefined until <a class="el" href="class_masked_occlusion_culling_private.html#a5340952213b62181ac66d6dfa8bb3760" title="Clears the hierarchical depth buffer.">ClearBuffer()</a> is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">witdh</td><td>The width of the buffer in pixels, must be a multiple of 8 </td></tr>
    <tr><td class="paramname">height</td><td>The height of the buffer in pixels, must be a multiple of 4 </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_masked_occlusion_culling.html#a31dc21213cfe983afc64856a574e72e6">MaskedOcclusionCulling</a>.</p>

</div>
</div>
<a id="afc56812ccfe60650d96cd43a19b690a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc56812ccfe60650d96cd43a19b690a0">&#9670;&nbsp;</a></span>TestRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CullingResult MaskedOcclusionCullingPrivate::TestRect </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ymin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ymax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>wmin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Occlusion query for a rectangle with a given depth. The rectangle is given in normalized device coordinates where (x,y) coordinates between [-1,1] map to the visible screen area. The query uses a GREATER_EQUAL (reversed) depth test meaning that depth values equal to the contents of the depth buffer are counted as visible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xmin</td><td>NDC coordinate of the left side of the rectangle. </td></tr>
    <tr><td class="paramname">ymin</td><td>NDC coordinate of the bottom side of the rectangle. </td></tr>
    <tr><td class="paramname">xmax</td><td>NDC coordinate of the right side of the rectangle. </td></tr>
    <tr><td class="paramname">ymax</td><td>NDC coordinate of the top side of the rectangle. </td></tr>
    <tr><td class="paramname">ymax</td><td>NDC coordinate of the top side of the rectangle. </td></tr>
    <tr><td class="paramname">wmin</td><td>Clip space W coordinate for the rectangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The query will return VISIBLE if the rectangle may be visible, OCCLUDED if the rectangle is occluded by a previously rendered object, or VIEW_CULLED if the rectangle is outside the view frustum. </dd></dl>

<p>Implements <a class="el" href="class_masked_occlusion_culling.html#afaac101042e8262a81d19ac3064a8d17">MaskedOcclusionCulling</a>.</p>

</div>
</div>
<a id="ab2b6b262c419d39ce69676839e8c734c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b6b262c419d39ce69676839e8c734c">&#9670;&nbsp;</a></span>TestTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CullingResult MaskedOcclusionCullingPrivate::TestTriangles </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>inVtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>inTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>modelToClipMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackfaceWinding&#160;</td>
          <td class="paramname"><em>bfWinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ClipPlanes&#160;</td>
          <td class="paramname"><em>clipPlaneMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_masked_occlusion_culling_1_1_vertex_layout.html">VertexLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>vtxLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is similar to <a class="el" href="class_masked_occlusion_culling_private.html#a8d7e4a3b07720c3c8fd69c0590435d79" title="Renders a mesh of occluder triangles and updates the hierarchical z buffer with conservative depth va...">RenderTriangles()</a>, but performs an occlusion query instead and does not update the hierarchical z buffer. The query uses a GREATER_EQUAL (reversed) depth test meaning that depth values equal to the contents of the depth buffer are counted as visible. </p>
<p>This function is optimized for vertex layouts with stride 16 and y and w offsets of 4 and 12 bytes, respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inVtx</td><td>Pointer to an array of input vertices, should point to the x component of the first vertex. The input vertices are given as (x,y,w) coordinates in clip space. The memory layout can be changed using vtxLayout. </td></tr>
    <tr><td class="paramname">inTris</td><td>Pointer to an array of triangle indices. Each triangle is created from three indices consecutively fetched from the array. </td></tr>
    <tr><td class="paramname">nTris</td><td>The number of triangles to render (inTris must contain atleast 3*nTris entries) </td></tr>
    <tr><td class="paramname">modelToClipMatrix</td><td>all vertices will be transformed by this matrix before performing projection. If nullptr is passed the transform step will be skipped </td></tr>
    <tr><td class="paramname">bfWinding</td><td>Sets triangle winding order to consider backfacing, must be one one of (BACKFACE_NONE, BACKFACE_CW and BACKFACE_CCW). Back-facing triangles are culled and will not be occlusion tested. You may use BACKFACE_NONE to disable culling for double sided geometry </td></tr>
    <tr><td class="paramname">clipPlaneMask</td><td>A mask indicating which clip planes should be considered by the triangle clipper. Can be used as an optimization if your application can determine (for example during culling) that a group of triangles does not intersect a certain frustum plane. However, setting an incorrect mask may cause out of bounds memory accesses. </td></tr>
    <tr><td class="paramname">vtxLayout</td><td>A struct specifying the vertex layout (see struct for detailed description). For best performance, it is advisable to store position data as compactly in memory as possible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The query will return VISIBLE if the triangle mesh may be visible, OCCLUDED if the mesh is occluded by a previously rendered object, or VIEW_CULLED if all triangles are entirely outside the view frustum or backface culled. </dd></dl>

<p>Implements <a class="el" href="class_masked_occlusion_culling.html#a37a0a8e302f5649ec090240580a6aca5">MaskedOcclusionCulling</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Gems/Atom/RPI/Code/External/MaskedOcclusionCulling/MaskedOcclusionCullingCommon.inl</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_masked_occlusion_culling_private.html">MaskedOcclusionCullingPrivate</a></li>
    <li class="footer">Generated on Tue Oct 8 2024 21:27:29 for Open 3D Engine Atom Gem API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
