<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine Atom Gem API Reference: AZ::RHI::ShaderResourceGroupData Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Open 3D Engine Atom Gem API Reference<span id="projectnumber">&#160;23.10.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_a_z_1_1_r_h_i_1_1_shader_resource_group_data.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_data-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AZ::RHI::ShaderResourceGroupData Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;ShaderResourceGroupData.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_r_h_i_1_1_shader_resource_group_data_1_1_bindless_resource_views.html">BindlessResourceViews</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abf93e63d8fa2114c794e065c7399f4b2"><td class="memItemLeft" align="right" valign="top"><a id="abf93e63d8fa2114c794e065c7399f4b2" name="abf93e63d8fa2114c794e065c7399f4b2"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>ResourceType</b> : uint32_t { <br />
&#160;&#160;<b>ConstantData</b>
, <b>BufferView</b>
, <b>ImageView</b>
, <b>BufferViewUnboundedArray</b>
, <br />
&#160;&#160;<b>ImageViewUnboundedArray</b>
, <b>Sampler</b>
, <b>Count</b>
<br />
 }</td></tr>
<tr class="separator:abf93e63d8fa2114c794e065c7399f4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3104a96b63ee46b1f1416c0c73bff402"><td class="memItemLeft" align="right" valign="top"><a id="a3104a96b63ee46b1f1416c0c73bff402" name="a3104a96b63ee46b1f1416c0c73bff402"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>ResourceTypeMask</b> : uint32_t { <br />
&#160;&#160;<b>None</b> = 0
, <b>ConstantDataMask</b> = AZ_BIT(static_cast&lt;uint32_t&gt;(ResourceType::ConstantData))
, <b>BufferViewMask</b> = AZ_BIT(static_cast&lt;uint32_t&gt;(ResourceType::BufferView))
, <b>ImageViewMask</b> = AZ_BIT(static_cast&lt;uint32_t&gt;(ResourceType::ImageView))
, <br />
&#160;&#160;<b>BufferViewUnboundedArrayMask</b> = AZ_BIT(static_cast&lt;uint32_t&gt;(ResourceType::BufferViewUnboundedArray))
, <b>ImageViewUnboundedArrayMask</b> = AZ_BIT(static_cast&lt;uint32_t&gt;(ResourceType::ImageViewUnboundedArray))
, <b>SamplerMask</b> = AZ_BIT(static_cast&lt;uint32_t&gt;(ResourceType::Sampler))
<br />
 }</td></tr>
<tr class="separator:a3104a96b63ee46b1f1416c0c73bff402"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2515081ae4e39dfabca45af690e36b61"><td class="memItemLeft" align="right" valign="top"><a id="a2515081ae4e39dfabca45af690e36b61" name="a2515081ae4e39dfabca45af690e36b61"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ShaderResourceGroupData</b> ()</td></tr>
<tr class="memdesc:a2515081ae4e39dfabca45af690e36b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default creates an empty data structure. Must be initialized before use. <br /></td></tr>
<tr class="separator:a2515081ae4e39dfabca45af690e36b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab6e1646da6bd82bf1bd43ee2f37839"><td class="memItemLeft" align="right" valign="top"><a id="a2ab6e1646da6bd82bf1bd43ee2f37839" name="a2ab6e1646da6bd82bf1bd43ee2f37839"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ShaderResourceGroupData</b> (const <a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_layout.html">ShaderResourceGroupLayout</a> *shaderResourceGroupLayout)</td></tr>
<tr class="memdesc:a2ab6e1646da6bd82bf1bd43ee2f37839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates shader resource group data from a layout. <br /></td></tr>
<tr class="separator:a2ab6e1646da6bd82bf1bd43ee2f37839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fc1665b87744140f8aef3f135fb7f7"><td class="memItemLeft" align="right" valign="top"><a id="a97fc1665b87744140f8aef3f135fb7f7" name="a97fc1665b87744140f8aef3f135fb7f7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ShaderResourceGroupData</b> (const <a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_pool.html">ShaderResourceGroupPool</a> &amp;shaderResourceGroupPool)</td></tr>
<tr class="memdesc:a97fc1665b87744140f8aef3f135fb7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates shader resource group data from a pool (usable on any SRG with the same layout). <br /></td></tr>
<tr class="separator:a97fc1665b87744140f8aef3f135fb7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f688e1fcd00c9c88e64958304192096"><td class="memItemLeft" align="right" valign="top"><a id="a2f688e1fcd00c9c88e64958304192096" name="a2f688e1fcd00c9c88e64958304192096"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ShaderResourceGroupData</b> (const <a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group.html">ShaderResourceGroup</a> &amp;shaderResourceGroup)</td></tr>
<tr class="memdesc:a2f688e1fcd00c9c88e64958304192096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates shader resource group data from an SRG instance (usable on any SRG with the same layout). <br /></td></tr>
<tr class="separator:a2f688e1fcd00c9c88e64958304192096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd717f97b5ef3c42039070b6c55fc29b"><td class="memItemLeft" align="right" valign="top"><a id="afd717f97b5ef3c42039070b6c55fc29b" name="afd717f97b5ef3c42039070b6c55fc29b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_DEFAULT_COPY_MOVE</b> (<a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_data.html">ShaderResourceGroupData</a>)</td></tr>
<tr class="separator:afd717f97b5ef3c42039070b6c55fc29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a98212e26c8937b49ea170acb6df70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputBufferIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_data.html#af9a98212e26c8937b49ea170acb6df70">FindShaderInputBufferIndex</a> (const Name &amp;name) const</td></tr>
<tr class="separator:af9a98212e26c8937b49ea170acb6df70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d9f6a376b5c42eccee671ad25e0b27"><td class="memItemLeft" align="right" valign="top"><a id="ad7d9f6a376b5c42eccee671ad25e0b27" name="ad7d9f6a376b5c42eccee671ad25e0b27"></a>
<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputImageIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FindShaderInputImageIndex</b> (const Name &amp;name) const</td></tr>
<tr class="separator:ad7d9f6a376b5c42eccee671ad25e0b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d19fd33602af30e1d64cdf4feda2f89"><td class="memItemLeft" align="right" valign="top"><a id="a5d19fd33602af30e1d64cdf4feda2f89" name="a5d19fd33602af30e1d64cdf4feda2f89"></a>
<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputSamplerIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FindShaderInputSamplerIndex</b> (const Name &amp;name) const</td></tr>
<tr class="separator:a5d19fd33602af30e1d64cdf4feda2f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9af6671813bad74c605c7165d080e3"><td class="memItemLeft" align="right" valign="top"><a id="acd9af6671813bad74c605c7165d080e3" name="acd9af6671813bad74c605c7165d080e3"></a>
<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputConstantIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FindShaderInputConstantIndex</b> (const Name &amp;name) const</td></tr>
<tr class="separator:acd9af6671813bad74c605c7165d080e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403b0b9e264f603da806570f2de3c3f2"><td class="memItemLeft" align="right" valign="top"><a id="a403b0b9e264f603da806570f2de3c3f2" name="a403b0b9e264f603da806570f2de3c3f2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetImageView</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputImageIndex</a> inputIndex, const <a class="el" href="class_a_z_1_1_r_h_i_1_1_image_view.html">ImageView</a> *imageView, uint32_t arrayIndex)</td></tr>
<tr class="memdesc:a403b0b9e264f603da806570f2de3c3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets one image view for the given shader input index. <br /></td></tr>
<tr class="separator:a403b0b9e264f603da806570f2de3c3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae835aee03bcec579e817bb48fe3ee839"><td class="memItemLeft" align="right" valign="top"><a id="ae835aee03bcec579e817bb48fe3ee839" name="ae835aee03bcec579e817bb48fe3ee839"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetImageViewArray</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputImageIndex</a> inputIndex, AZStd::span&lt; const <a class="el" href="class_a_z_1_1_r_h_i_1_1_image_view.html">ImageView</a> *const &gt; imageViews, uint32_t arrayIndex=0)</td></tr>
<tr class="memdesc:ae835aee03bcec579e817bb48fe3ee839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an array of image view for the given shader input index. <br /></td></tr>
<tr class="separator:ae835aee03bcec579e817bb48fe3ee839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86489fd8f103f5f4052136b5c5ba019f"><td class="memItemLeft" align="right" valign="top"><a id="a86489fd8f103f5f4052136b5c5ba019f" name="a86489fd8f103f5f4052136b5c5ba019f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetImageViewUnboundedArray</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputImageUnboundedArrayIndex</a> inputIndex, AZStd::span&lt; const <a class="el" href="class_a_z_1_1_r_h_i_1_1_image_view.html">ImageView</a> *const &gt; imageViews)</td></tr>
<tr class="memdesc:a86489fd8f103f5f4052136b5c5ba019f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an unbounded array of image view for the given shader input index. <br /></td></tr>
<tr class="separator:a86489fd8f103f5f4052136b5c5ba019f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f26c5a6e11430509e2df4405f421cf"><td class="memItemLeft" align="right" valign="top"><a id="ad1f26c5a6e11430509e2df4405f421cf" name="ad1f26c5a6e11430509e2df4405f421cf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetBufferView</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputBufferIndex</a> inputIndex, const <a class="el" href="class_a_z_1_1_r_h_i_1_1_buffer_view.html">BufferView</a> *bufferView, uint32_t arrayIndex=0)</td></tr>
<tr class="memdesc:ad1f26c5a6e11430509e2df4405f421cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets one buffer view for the given shader input index. <br /></td></tr>
<tr class="separator:ad1f26c5a6e11430509e2df4405f421cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed733021f0b2da83f2d57c0e3a7bddb9"><td class="memItemLeft" align="right" valign="top"><a id="aed733021f0b2da83f2d57c0e3a7bddb9" name="aed733021f0b2da83f2d57c0e3a7bddb9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetBufferViewArray</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputBufferIndex</a> inputIndex, AZStd::span&lt; const <a class="el" href="class_a_z_1_1_r_h_i_1_1_buffer_view.html">BufferView</a> *const &gt; bufferViews, uint32_t arrayIndex=0)</td></tr>
<tr class="memdesc:aed733021f0b2da83f2d57c0e3a7bddb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an array of image view for the given shader input index. <br /></td></tr>
<tr class="separator:aed733021f0b2da83f2d57c0e3a7bddb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd80cde66ef247580ed8dd7ceffabd93"><td class="memItemLeft" align="right" valign="top"><a id="abd80cde66ef247580ed8dd7ceffabd93" name="abd80cde66ef247580ed8dd7ceffabd93"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetBufferViewUnboundedArray</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputBufferUnboundedArrayIndex</a> inputIndex, AZStd::span&lt; const <a class="el" href="class_a_z_1_1_r_h_i_1_1_buffer_view.html">BufferView</a> *const &gt; bufferViews)</td></tr>
<tr class="memdesc:abd80cde66ef247580ed8dd7ceffabd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an unbounded array of buffer view for the given shader input index. <br /></td></tr>
<tr class="separator:abd80cde66ef247580ed8dd7ceffabd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937017265ea8e49c50a01820a5452c08"><td class="memItemLeft" align="right" valign="top"><a id="a937017265ea8e49c50a01820a5452c08" name="a937017265ea8e49c50a01820a5452c08"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetSampler</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputSamplerIndex</a> inputIndex, const <a class="el" href="class_a_z_1_1_r_h_i_1_1_sampler_state.html">SamplerState</a> &amp;sampler, uint32_t arrayIndex=0)</td></tr>
<tr class="memdesc:a937017265ea8e49c50a01820a5452c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets one sampler for the given shader input index, using the bindingIndex as the key. <br /></td></tr>
<tr class="separator:a937017265ea8e49c50a01820a5452c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad685ac4d8427ad3d0ef98903967b4980"><td class="memItemLeft" align="right" valign="top"><a id="ad685ac4d8427ad3d0ef98903967b4980" name="ad685ac4d8427ad3d0ef98903967b4980"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetSamplerArray</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputSamplerIndex</a> inputIndex, AZStd::span&lt; const <a class="el" href="class_a_z_1_1_r_h_i_1_1_sampler_state.html">SamplerState</a> &gt; samplers, uint32_t arrayIndex=0)</td></tr>
<tr class="memdesc:ad685ac4d8427ad3d0ef98903967b4980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an array of samplers for the given shader input index. <br /></td></tr>
<tr class="separator:ad685ac4d8427ad3d0ef98903967b4980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d191f1971d69df6c3f2f9ac913be27"><td class="memItemLeft" align="right" valign="top"><a id="aa5d191f1971d69df6c3f2f9ac913be27" name="aa5d191f1971d69df6c3f2f9ac913be27"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetConstantRaw</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputConstantIndex</a> inputIndex, const void *bytes, uint32_t byteCount)</td></tr>
<tr class="memdesc:aa5d191f1971d69df6c3f2f9ac913be27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns constant data for the given constant shader input index. <br /></td></tr>
<tr class="separator:aa5d191f1971d69df6c3f2f9ac913be27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62fc6fe2587b21329f07b06ad4bae93"><td class="memItemLeft" align="right" valign="top"><a id="ac62fc6fe2587b21329f07b06ad4bae93" name="ac62fc6fe2587b21329f07b06ad4bae93"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetConstantRaw</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputConstantIndex</a> inputIndex, const void *bytes, uint32_t byteOffset, uint32_t byteCount)</td></tr>
<tr class="separator:ac62fc6fe2587b21329f07b06ad4bae93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc0c22e3529d307079153b26ac43594"><td class="memTemplParams" colspan="2"><a id="acdc0c22e3529d307079153b26ac43594" name="acdc0c22e3529d307079153b26ac43594"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdc0c22e3529d307079153b26ac43594"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetConstant</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputConstantIndex</a> inputIndex, const T &amp;value)</td></tr>
<tr class="memdesc:acdc0c22e3529d307079153b26ac43594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a value of type T to the constant shader input. <br /></td></tr>
<tr class="separator:acdc0c22e3529d307079153b26ac43594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d01c3883cfae9e6af0c372858399b0"><td class="memTemplParams" colspan="2"><a id="aa5d01c3883cfae9e6af0c372858399b0" name="aa5d01c3883cfae9e6af0c372858399b0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5d01c3883cfae9e6af0c372858399b0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetConstantMatrixRows</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputConstantIndex</a> inputIndex, const T &amp;value, uint32_t rowCount)</td></tr>
<tr class="memdesc:aa5d01c3883cfae9e6af0c372858399b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a specified number of rows from a Matrix. <br /></td></tr>
<tr class="separator:aa5d01c3883cfae9e6af0c372858399b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadd899930146bf9749cdfa8370b84bd"><td class="memTemplParams" colspan="2"><a id="acadd899930146bf9749cdfa8370b84bd" name="acadd899930146bf9749cdfa8370b84bd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acadd899930146bf9749cdfa8370b84bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetConstant</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputConstantIndex</a> inputIndex, const T &amp;value, uint32_t arrayIndex)</td></tr>
<tr class="memdesc:acadd899930146bf9749cdfa8370b84bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a value of type T to the constant shader input, at an array offset. <br /></td></tr>
<tr class="separator:acadd899930146bf9749cdfa8370b84bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59feec4e685e5312a9ab585572b8502"><td class="memTemplParams" colspan="2"><a id="ac59feec4e685e5312a9ab585572b8502" name="ac59feec4e685e5312a9ab585572b8502"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac59feec4e685e5312a9ab585572b8502"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetConstantArray</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputConstantIndex</a> inputIndex, AZStd::span&lt; const T &gt; values)</td></tr>
<tr class="memdesc:ac59feec4e685e5312a9ab585572b8502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an array of type T to the constant shader input. <br /></td></tr>
<tr class="separator:ac59feec4e685e5312a9ab585572b8502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c8a1270cfe6b622fdb824046817bd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_data.html#a58c8a1270cfe6b622fdb824046817bd8">SetConstantData</a> (const void *bytes, uint32_t byteCount)</td></tr>
<tr class="separator:a58c8a1270cfe6b622fdb824046817bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e7a71e2f085806056eac8b3f1a3ecb"><td class="memItemLeft" align="right" valign="top"><a id="a78e7a71e2f085806056eac8b3f1a3ecb" name="a78e7a71e2f085806056eac8b3f1a3ecb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetConstantData</b> (const void *bytes, uint32_t byteOffset, uint32_t byteCount)</td></tr>
<tr class="separator:a78e7a71e2f085806056eac8b3f1a3ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bf6592637cd76aac7dc11d61ab496c"><td class="memItemLeft" align="right" valign="top"><a id="a65bf6592637cd76aac7dc11d61ab496c" name="a65bf6592637cd76aac7dc11d61ab496c"></a>
const ConstPtr&lt; <a class="el" href="class_a_z_1_1_r_h_i_1_1_image_view.html">ImageView</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetImageView</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputImageIndex</a> inputIndex, uint32_t arrayIndex) const</td></tr>
<tr class="memdesc:a65bf6592637cd76aac7dc11d61ab496c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single image view associated with the image shader input index and array offset. <br /></td></tr>
<tr class="separator:a65bf6592637cd76aac7dc11d61ab496c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46af00210ad93c2a67ba1d354da18079"><td class="memItemLeft" align="right" valign="top"><a id="a46af00210ad93c2a67ba1d354da18079" name="a46af00210ad93c2a67ba1d354da18079"></a>
AZStd::span&lt; const ConstPtr&lt; <a class="el" href="class_a_z_1_1_r_h_i_1_1_image_view.html">ImageView</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetImageViewArray</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputImageIndex</a> inputIndex) const</td></tr>
<tr class="memdesc:a46af00210ad93c2a67ba1d354da18079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a span of image views associated with the given image shader input index. <br /></td></tr>
<tr class="separator:a46af00210ad93c2a67ba1d354da18079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e2f40cd94da9924b642ab96d3708c2"><td class="memItemLeft" align="right" valign="top"><a id="a85e2f40cd94da9924b642ab96d3708c2" name="a85e2f40cd94da9924b642ab96d3708c2"></a>
AZStd::span&lt; const ConstPtr&lt; <a class="el" href="class_a_z_1_1_r_h_i_1_1_image_view.html">ImageView</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetImageViewUnboundedArray</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputImageUnboundedArrayIndex</a> inputIndex) const</td></tr>
<tr class="memdesc:a85e2f40cd94da9924b642ab96d3708c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an unbounded span of image views associated with the given buffer shader input index. <br /></td></tr>
<tr class="separator:a85e2f40cd94da9924b642ab96d3708c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a4066ed0e5136e00d979eec1226bc8"><td class="memItemLeft" align="right" valign="top"><a id="a98a4066ed0e5136e00d979eec1226bc8" name="a98a4066ed0e5136e00d979eec1226bc8"></a>
const ConstPtr&lt; <a class="el" href="class_a_z_1_1_r_h_i_1_1_buffer_view.html">BufferView</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetBufferView</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputBufferIndex</a> inputIndex, uint32_t arrayIndex) const</td></tr>
<tr class="memdesc:a98a4066ed0e5136e00d979eec1226bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single buffer view associated with the buffer shader input index and array offset. <br /></td></tr>
<tr class="separator:a98a4066ed0e5136e00d979eec1226bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d177d72e84cc6a87aa6b64c3bc9ef17"><td class="memItemLeft" align="right" valign="top"><a id="a1d177d72e84cc6a87aa6b64c3bc9ef17" name="a1d177d72e84cc6a87aa6b64c3bc9ef17"></a>
AZStd::span&lt; const ConstPtr&lt; <a class="el" href="class_a_z_1_1_r_h_i_1_1_buffer_view.html">BufferView</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetBufferViewArray</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputBufferIndex</a> inputIndex) const</td></tr>
<tr class="memdesc:a1d177d72e84cc6a87aa6b64c3bc9ef17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a span of buffer views associated with the given buffer shader input index. <br /></td></tr>
<tr class="separator:a1d177d72e84cc6a87aa6b64c3bc9ef17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c739f40a33fcc8d2657bbf3ef97b053"><td class="memItemLeft" align="right" valign="top"><a id="a1c739f40a33fcc8d2657bbf3ef97b053" name="a1c739f40a33fcc8d2657bbf3ef97b053"></a>
AZStd::span&lt; const ConstPtr&lt; <a class="el" href="class_a_z_1_1_r_h_i_1_1_buffer_view.html">BufferView</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetBufferViewUnboundedArray</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputBufferUnboundedArrayIndex</a> inputIndex) const</td></tr>
<tr class="memdesc:a1c739f40a33fcc8d2657bbf3ef97b053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an unbounded span of buffer views associated with the given buffer shader input index. <br /></td></tr>
<tr class="separator:a1c739f40a33fcc8d2657bbf3ef97b053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7d478e2b55da104d782d1e0855b5f5"><td class="memItemLeft" align="right" valign="top"><a id="a3b7d478e2b55da104d782d1e0855b5f5" name="a3b7d478e2b55da104d782d1e0855b5f5"></a>
const <a class="el" href="class_a_z_1_1_r_h_i_1_1_sampler_state.html">SamplerState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetSampler</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputSamplerIndex</a> inputIndex, uint32_t arrayIndex) const</td></tr>
<tr class="memdesc:a3b7d478e2b55da104d782d1e0855b5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single sampler associated with the sampler shader input index and array offset. <br /></td></tr>
<tr class="separator:a3b7d478e2b55da104d782d1e0855b5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786c46f6330308a7a1297c94836ea969"><td class="memItemLeft" align="right" valign="top"><a id="a786c46f6330308a7a1297c94836ea969" name="a786c46f6330308a7a1297c94836ea969"></a>
AZStd::span&lt; const <a class="el" href="class_a_z_1_1_r_h_i_1_1_sampler_state.html">SamplerState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetSamplerArray</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputSamplerIndex</a> inputIndex) const</td></tr>
<tr class="memdesc:a786c46f6330308a7a1297c94836ea969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a span of samplers associated with the sampler shader input index. <br /></td></tr>
<tr class="separator:a786c46f6330308a7a1297c94836ea969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7628ee8a181c477b0a53f2df6145207a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7628ee8a181c477b0a53f2df6145207a"><td class="memTemplItemLeft" align="right" valign="top">AZStd::span&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_data.html#a7628ee8a181c477b0a53f2df6145207a">GetConstantArray</a> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputConstantIndex</a> inputIndex) const</td></tr>
<tr class="separator:a7628ee8a181c477b0a53f2df6145207a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5b6447471dca45d416fca86546f8ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a5b6447471dca45d416fca86546f8ec"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_data.html#a6a5b6447471dca45d416fca86546f8ec">GetConstant</a> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputConstantIndex</a> inputIndex) const</td></tr>
<tr class="separator:a6a5b6447471dca45d416fca86546f8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb113b6729eb50ab29ea3181f7ff6894"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abb113b6729eb50ab29ea3181f7ff6894"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_data.html#abb113b6729eb50ab29ea3181f7ff6894">GetConstant</a> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputConstantIndex</a> inputIndex, uint32_t arrayIndex) const</td></tr>
<tr class="separator:abb113b6729eb50ab29ea3181f7ff6894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b0218e6c058a024ea59aa2f39d7b04"><td class="memItemLeft" align="right" valign="top"><a id="af7b0218e6c058a024ea59aa2f39d7b04" name="af7b0218e6c058a024ea59aa2f39d7b04"></a>
AZStd::span&lt; const uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetConstantRaw</b> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputConstantIndex</a> inputIndex) const</td></tr>
<tr class="memdesc:af7b0218e6c058a024ea59aa2f39d7b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns constant data for the given shader input index as a span of bytes. <br /></td></tr>
<tr class="separator:af7b0218e6c058a024ea59aa2f39d7b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab69039a07b6501eac1fd07f0ccb4c4"><td class="memItemLeft" align="right" valign="top">AZStd::span&lt; const ConstPtr&lt; <a class="el" href="class_a_z_1_1_r_h_i_1_1_image_view.html">ImageView</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_data.html#a2ab69039a07b6501eac1fd07f0ccb4c4">GetImageGroup</a> () const</td></tr>
<tr class="separator:a2ab69039a07b6501eac1fd07f0ccb4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac197ebc0dd6933eaeed7455392f1a334"><td class="memItemLeft" align="right" valign="top"><a id="ac197ebc0dd6933eaeed7455392f1a334" name="ac197ebc0dd6933eaeed7455392f1a334"></a>
AZStd::span&lt; const ConstPtr&lt; <a class="el" href="class_a_z_1_1_r_h_i_1_1_buffer_view.html">BufferView</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetBufferGroup</b> () const</td></tr>
<tr class="separator:ac197ebc0dd6933eaeed7455392f1a334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3ce853339e2c97ca39b8e7388f5285"><td class="memItemLeft" align="right" valign="top"><a id="afc3ce853339e2c97ca39b8e7388f5285" name="afc3ce853339e2c97ca39b8e7388f5285"></a>
AZStd::span&lt; const <a class="el" href="class_a_z_1_1_r_h_i_1_1_sampler_state.html">SamplerState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetSamplerGroup</b> () const</td></tr>
<tr class="separator:afc3ce853339e2c97ca39b8e7388f5285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef8019144a236fae2b4838576a4db45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_data.html#adef8019144a236fae2b4838576a4db45">ResetViews</a> ()</td></tr>
<tr class="separator:adef8019144a236fae2b4838576a4db45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab762af6770b3abd3d5325a26e6fa21b9"><td class="memItemLeft" align="right" valign="top">AZStd::span&lt; const uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_data.html#ab762af6770b3abd3d5325a26e6fa21b9">GetConstantData</a> () const</td></tr>
<tr class="separator:ab762af6770b3abd3d5325a26e6fa21b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40eb9e82bda75f31dfca31fbd09e53c7"><td class="memItemLeft" align="right" valign="top"><a id="a40eb9e82bda75f31dfca31fbd09e53c7" name="a40eb9e82bda75f31dfca31fbd09e53c7"></a>
const <a class="el" href="class_a_z_1_1_r_h_i_1_1_constants_data.html">ConstantsData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetConstantsData</b> () const</td></tr>
<tr class="memdesc:a40eb9e82bda75f31dfca31fbd09e53c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying <a class="el" href="class_a_z_1_1_r_h_i_1_1_constants_data.html">ConstantsData</a> struct. <br /></td></tr>
<tr class="separator:a40eb9e82bda75f31dfca31fbd09e53c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baa582ec70faa593e55e7023b956e2c"><td class="memItemLeft" align="right" valign="top"><a id="a3baa582ec70faa593e55e7023b956e2c" name="a3baa582ec70faa593e55e7023b956e2c"></a>
const <a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_layout.html">ShaderResourceGroupLayout</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetLayout</b> () const</td></tr>
<tr class="memdesc:a3baa582ec70faa593e55e7023b956e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the shader resource layout for this group. <br /></td></tr>
<tr class="separator:a3baa582ec70faa593e55e7023b956e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6966fbc034b85a60b16d1e15f162ff9"><td class="memItemLeft" align="right" valign="top"><a id="ae6966fbc034b85a60b16d1e15f162ff9" name="ae6966fbc034b85a60b16d1e15f162ff9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ResetUpdateMask</b> ()</td></tr>
<tr class="memdesc:ae6966fbc034b85a60b16d1e15f162ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the update mask. <br /></td></tr>
<tr class="separator:ae6966fbc034b85a60b16d1e15f162ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af548138593f6417ca8c203caf31e0e"><td class="memItemLeft" align="right" valign="top"><a id="a5af548138593f6417ca8c203caf31e0e" name="a5af548138593f6417ca8c203caf31e0e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EnableResourceTypeCompilation</b> (ResourceTypeMask resourceTypeMask)</td></tr>
<tr class="memdesc:a5af548138593f6417ca8c203caf31e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable compilation for a resourceType specified by resourceTypeMask. <br /></td></tr>
<tr class="separator:a5af548138593f6417ca8c203caf31e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b66d9887bb659a21dfd029b686dca34"><td class="memItemLeft" align="right" valign="top"><a id="a6b66d9887bb659a21dfd029b686dca34" name="a6b66d9887bb659a21dfd029b686dca34"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetUpdateMask</b> () const</td></tr>
<tr class="memdesc:a6b66d9887bb659a21dfd029b686dca34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mask that is suppose to indicate which resource type was updated. <br /></td></tr>
<tr class="separator:a6b66d9887bb659a21dfd029b686dca34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba5937701ae084cc1988c3800d3775b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_data.html#a3ba5937701ae084cc1988c3800d3775b">SetBindlessViews</a> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputBufferIndex</a> indirectResourceBufferIndex, const <a class="el" href="class_a_z_1_1_r_h_i_1_1_buffer_view.html">RHI::BufferView</a> *indirectResourceBuffer, AZStd::span&lt; const <a class="el" href="class_a_z_1_1_r_h_i_1_1_image_view.html">ImageView</a> *const &gt; imageViews, uint32_t *outIndices, AZStd::span&lt; bool &gt; isViewReadOnly, uint32_t arrayIndex=0)</td></tr>
<tr class="separator:a3ba5937701ae084cc1988c3800d3775b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb854e1cbceaf7704114bd6baa063678"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_data.html#acb854e1cbceaf7704114bd6baa063678">SetBindlessViews</a> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputBufferIndex</a> indirectResourceBufferIndex, const <a class="el" href="class_a_z_1_1_r_h_i_1_1_buffer_view.html">RHI::BufferView</a> *indirectResourceBuffer, AZStd::span&lt; const <a class="el" href="class_a_z_1_1_r_h_i_1_1_buffer_view.html">BufferView</a> *const &gt; bufferViews, uint32_t *outIndices, AZStd::span&lt; bool &gt; isViewReadOnly, uint32_t arrayIndex=0)</td></tr>
<tr class="separator:acb854e1cbceaf7704114bd6baa063678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf7c96a502b2963969a3902559bc981"><td class="memItemLeft" align="right" valign="top"><a id="afbf7c96a502b2963969a3902559bc981" name="afbf7c96a502b2963969a3902559bc981"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetBindlessViewsSize</b> () const</td></tr>
<tr class="memdesc:afbf7c96a502b2963969a3902559bc981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the bindless view map. <br /></td></tr>
<tr class="separator:afbf7c96a502b2963969a3902559bc981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2000674cd76c5ccf8156eece5aedc36d"><td class="memItemLeft" align="right" valign="top"><a id="a2000674cd76c5ccf8156eece5aedc36d" name="a2000674cd76c5ccf8156eece5aedc36d"></a>
const AZStd::unordered_map&lt; AZStd::pair&lt; <a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputBufferIndex</a>, uint32_t &gt;, <a class="el" href="struct_a_z_1_1_r_h_i_1_1_shader_resource_group_data_1_1_bindless_resource_views.html">BindlessResourceViews</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetBindlessResourceViews</b> () const</td></tr>
<tr class="memdesc:a2000674cd76c5ccf8156eece5aedc36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all the bindless views referenced indirectly via SetBindlessViews api. <br /></td></tr>
<tr class="separator:a2000674cd76c5ccf8156eece5aedc36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shader resource group data is a light abstraction over a flat table of shader resources and shader constants. It utilizes basic reflection information from the shader resource group layout to construct the table in the correct format for the platform-specific compile phase. The user is expected to create instances of this class, fill data, and then push it to an SRG instance.</p>
<p>The shader resource group (SRG) includes a set of built-in SRG constants in a single internally-managed constant buffer. This is separate from any custom constant buffers that some SRG layouts may include as shader resources. SRG constants can be conveniently accessed through a variety of SetConstant.</p>
<p>This data structure holds strong references to the resource views bound onto it.</p>
<p>NOTE [Performance Warning]: This data structure allocates memory. If compiling several SRG's in a batch, prefer to share the data between them (i.e. within a single job).</p>
<p>NOTE [SRG Constants]: The <a class="el" href="class_a_z_1_1_r_h_i_1_1_constants_data.html">ConstantsData</a> class is used for efficiently setting/getting the constants values of the SRG. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af9a98212e26c8937b49ea170acb6df70" name="af9a98212e26c8937b49ea170acb6df70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a98212e26c8937b49ea170acb6df70">&#9670;&#160;</a></span>FindShaderInputBufferIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputBufferIndex</a> AZ::RHI::ShaderResourceGroupData::FindShaderInputBufferIndex </td>
          <td>(</td>
          <td class="paramtype">const Name &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resolves a shader input name to an index using reflection. For performance reasons, this resolve operation should be performed once at initialization time (or as infrequently as possible). Assignment of shader inputs is faster when done using the shader input index directly. </p>

</div>
</div>
<a id="a6a5b6447471dca45d416fca86546f8ec" name="a6a5b6447471dca45d416fca86546f8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5b6447471dca45d416fca86546f8ec">&#9670;&#160;</a></span>GetConstant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T AZ::RHI::ShaderResourceGroupData::GetConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputConstantIndex</a>&#160;</td>
          <td class="paramname"><em>inputIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the constant data as type 'T' returned by value. The size of the constant region must match the size of T exactly. Otherwise, an empty instance is returned. </p>

</div>
</div>
<a id="abb113b6729eb50ab29ea3181f7ff6894" name="abb113b6729eb50ab29ea3181f7ff6894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb113b6729eb50ab29ea3181f7ff6894">&#9670;&#160;</a></span>GetConstant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T AZ::RHI::ShaderResourceGroupData::GetConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputConstantIndex</a>&#160;</td>
          <td class="paramname"><em>inputIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Treats the constant input as an array of type T, returning the element by value at the specified array index. The size of the constant region must equally partition into an array of type T. Otherwise, an empty instance is returned. </p>

</div>
</div>
<a id="a7628ee8a181c477b0a53f2df6145207a" name="a7628ee8a181c477b0a53f2df6145207a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7628ee8a181c477b0a53f2df6145207a">&#9670;&#160;</a></span>GetConstantArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">AZStd::span&lt; const T &gt; AZ::RHI::ShaderResourceGroupData::GetConstantArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputConstantIndex</a>&#160;</td>
          <td class="paramname"><em>inputIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns constant data for the given shader input index as a template type. The stride of T must match the size of the constant input region. The number of elements in the returned span is the number of evenly divisible elements. If the strides do not match, an empty span is returned. </p>

</div>
</div>
<a id="ab762af6770b3abd3d5325a26e6fa21b9" name="ab762af6770b3abd3d5325a26e6fa21b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab762af6770b3abd3d5325a26e6fa21b9">&#9670;&#160;</a></span>GetConstantData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AZStd::span&lt; const uint8_t &gt; AZ::RHI::ShaderResourceGroupData::GetConstantData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the opaque constant data populated by calls to SetConstant and SetConstantData.</p>
<p>CAUTION! Different platforms might follow different packing rules for the internally-managed SRG constant buffer. </p>

</div>
</div>
<a id="a2ab69039a07b6501eac1fd07f0ccb4c4" name="a2ab69039a07b6501eac1fd07f0ccb4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab69039a07b6501eac1fd07f0ccb4c4">&#9670;&#160;</a></span>GetImageGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AZStd::span&lt; const ConstPtr&lt; <a class="el" href="class_a_z_1_1_r_h_i_1_1_image_view.html">ImageView</a> &gt; &gt; AZ::RHI::ShaderResourceGroupData::GetImageGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a {<a class="el" href="class_a_z_1_1_r_h_i_1_1_buffer.html">Buffer</a>, <a class="el" href="class_a_z_1_1_r_h_i_1_1_image.html">Image</a>, Sampler} shader resource group. Each resource type has its own separate group.</p><ul>
<li>The size of this group matches the size provided by ShaderResourceGroupLayout::GetGroupSizeFor{<a class="el" href="class_a_z_1_1_r_h_i_1_1_buffer.html">Buffer</a>, <a class="el" href="class_a_z_1_1_r_h_i_1_1_image.html">Image</a>, Sampler}.</li>
<li>Use <a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_layout.html#a5fb34df2ada2d79205e2484785241a6d">ShaderResourceGroupLayout::GetGroupInterval</a> to retrieve a [min, max) interval into the span. </li>
</ul>

</div>
</div>
<a id="adef8019144a236fae2b4838576a4db45" name="adef8019144a236fae2b4838576a4db45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef8019144a236fae2b4838576a4db45">&#9670;&#160;</a></span>ResetViews()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::RHI::ShaderResourceGroupData::ResetViews </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset image and buffer views setup for this <a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_data.html">ShaderResourceGroupData</a> So it won't hold references for any RHI resources </p>

</div>
</div>
<a id="acb854e1cbceaf7704114bd6baa063678" name="acb854e1cbceaf7704114bd6baa063678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb854e1cbceaf7704114bd6baa063678">&#9670;&#160;</a></span>SetBindlessViews() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::RHI::ShaderResourceGroupData::SetBindlessViews </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputBufferIndex</a>&#160;</td>
          <td class="paramname"><em>indirectResourceBufferIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_r_h_i_1_1_buffer_view.html">RHI::BufferView</a> *&#160;</td>
          <td class="paramname"><em>indirectResourceBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZStd::span&lt; const <a class="el" href="class_a_z_1_1_r_h_i_1_1_buffer_view.html">BufferView</a> *const &gt;&#160;</td>
          <td class="paramname"><em>bufferViews</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>outIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZStd::span&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>isViewReadOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the indirect buffer view with the indices of all the buffer views which reside in the global gpu heap. Ideally higher level code can access bindless heap indices directly from the view and populate any indirect buffer directly. This API is present in case we want RHI to track bindless resources which may be needed for backends like the metal. </p>

</div>
</div>
<a id="a3ba5937701ae084cc1988c3800d3775b" name="a3ba5937701ae084cc1988c3800d3775b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba5937701ae084cc1988c3800d3775b">&#9670;&#160;</a></span>SetBindlessViews() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::RHI::ShaderResourceGroupData::SetBindlessViews </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">ShaderInputBufferIndex</a>&#160;</td>
          <td class="paramname"><em>indirectResourceBufferIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_r_h_i_1_1_buffer_view.html">RHI::BufferView</a> *&#160;</td>
          <td class="paramname"><em>indirectResourceBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZStd::span&lt; const <a class="el" href="class_a_z_1_1_r_h_i_1_1_image_view.html">ImageView</a> *const &gt;&#160;</td>
          <td class="paramname"><em>imageViews</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>outIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZStd::span&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>isViewReadOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the indirect buffer view with the indices of all the image views which reside in the global gpu heap. Ideally higher level code can access bindless heap indices directly from the view and populate any indirect buffer directly. This API is present in case we want RHI to track bindless resources which may be needed for backends like the metal. </p>

</div>
</div>
<a id="a58c8a1270cfe6b622fdb824046817bd8" name="a58c8a1270cfe6b622fdb824046817bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c8a1270cfe6b622fdb824046817bd8">&#9670;&#160;</a></span>SetConstantData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::RHI::ShaderResourceGroupData::SetConstantData </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns constant data as a whole.</p>
<p>CAUTION! Different platforms might follow different packing rules for the internally-managed SRG constant buffer. To set manually a constant buffer as a whole please use Constant Buffers in AZSL, instead of SRG Constants, then use RHI Buffers with constant binding flag and set the buffer memory following pragma 4 packing rule. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Gems/Atom/RHI/Code/Include/Atom/RHI/ShaderResourceGroupData.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><b>RHI</b></li><li class="navelem"><a class="el" href="class_a_z_1_1_r_h_i_1_1_shader_resource_group_data.html">ShaderResourceGroupData</a></li>
    <li class="footer">Generated on Mon Oct 9 2023 13:49:07 for Open 3D Engine Atom Gem API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
