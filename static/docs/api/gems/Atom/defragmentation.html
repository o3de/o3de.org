<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine Atom Gem API Reference: Defragmentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-placeholder-text"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine Atom Gem API Reference
   &#160;<span id="projectnumber">24.09</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('defragmentation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Defragmentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Interleaved allocations and deallocations of many objects of varying size can cause fragmentation over time, which can lead to a situation where the library is unable to find a continuous range of free memory for a new allocation despite there is enough free space, just scattered across many small free ranges between existing allocations.</p>
<p>To mitigate this problem, you can use defragmentation feature. It doesn't happen automatically though and needs your cooperation, because D3D12MA is a low level library that only allocates memory. It cannot recreate buffers and textures in a new place as it doesn't remember the contents of <code>D3D12_RESOURCE_DESC</code> structure. It cannot copy their contents as it doesn't record any commands to a command list.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___d_e_s_c.html">D3D12MA::DEFRAGMENTATION_DESC</a> defragDesc = {};</div>
<div class="line">defragDesc.<a class="code" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___d_e_s_c.html#aac9a357e679a0afa9ab84cd06057630b">Flags</a> = D3D12MA::DEFRAGMENTATION_FLAG_ALGORITHM_FAST;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="class_d3_d12_m_a_1_1_defragmentation_context.html">D3D12MA::DefragmentationContext</a>* defragCtx;</div>
<div class="line">allocator-&gt;BeginDefragmentation(&amp;defragDesc, &amp;defragCtx);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(;;)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___p_a_s_s___m_o_v_e___i_n_f_o.html">D3D12MA::DEFRAGMENTATION_PASS_MOVE_INFO</a> pass;</div>
<div class="line">    HRESULT hr = defragCtx-&gt;<a class="code" href="class_d3_d12_m_a_1_1_defragmentation_context.html#a1606c015d02edc094bb246986159d592">BeginPass</a>(&amp;pass);</div>
<div class="line">    <span class="keywordflow">if</span>(hr == S_OK)</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(hr != S_FALSE)</div>
<div class="line">        <span class="comment">// Handle error...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(UINT i = 0; i &lt; pass.<a class="code" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___p_a_s_s___m_o_v_e___i_n_f_o.html#a8df22d990c318d82fe9fcc5f04132c04">MoveCount</a>; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Inspect pass.pMoves[i].pSrcAllocation, identify what buffer/texture it represents.</span></div>
<div class="line">        MyEngineResourceData* resData = (MyEngineResourceData*)pMoves[i].pSrcAllocation-&gt;GetPrivateData();</div>
<div class="line">            </div>
<div class="line">        <span class="comment">// Recreate this buffer/texture as placed at pass.pMoves[i].pDstTmpAllocation.</span></div>
<div class="line">        D3D12_RESOURCE_DESC resDesc = ...</div>
<div class="line">        ID3D12Resource* newRes;</div>
<div class="line">        hr = device-&gt;CreatePlacedResource(</div>
<div class="line">            pass.<a class="code" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___p_a_s_s___m_o_v_e___i_n_f_o.html#a719fbdaae54251759605c41baeb24dc4">pMoves</a>[i].<a class="code" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___m_o_v_e.html#aec0c7f51ccc870c6a88af7c7390d8eda">pDstTmpAllocation</a>-&gt;<a class="code" href="class_d3_d12_m_a_1_1_allocation.html#ac15798741797425b4e9e67bfc991e06b">GetHeap</a>(),</div>
<div class="line">            pass.<a class="code" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___p_a_s_s___m_o_v_e___i_n_f_o.html#a719fbdaae54251759605c41baeb24dc4">pMoves</a>[i].<a class="code" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___m_o_v_e.html#aec0c7f51ccc870c6a88af7c7390d8eda">pDstTmpAllocation</a>-&gt;<a class="code" href="class_d3_d12_m_a_1_1_allocation.html#a47be9557d441797b65de177a3d5cdf60">GetOffset</a>(), &amp;resDesc,</div>
<div class="line">            D3D12_RESOURCE_STATE_COPY_DEST, NULL, IID_PPV_ARGS(&amp;newRes));</div>
<div class="line">        <span class="comment">// Check hr...</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Store new resource in the pDstTmpAllocation.</span></div>
<div class="line">        pass.<a class="code" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___p_a_s_s___m_o_v_e___i_n_f_o.html#a719fbdaae54251759605c41baeb24dc4">pMoves</a>[i].<a class="code" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___m_o_v_e.html#aec0c7f51ccc870c6a88af7c7390d8eda">pDstTmpAllocation</a>-&gt;<a class="code" href="class_d3_d12_m_a_1_1_allocation.html#a414a088c22bae0f29b1038f5f9346d14">SetResource</a>(newRes);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Copy its content to the new place.</span></div>
<div class="line">        cmdList-&gt;CopyResource(</div>
<div class="line">            pass.<a class="code" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___p_a_s_s___m_o_v_e___i_n_f_o.html#a719fbdaae54251759605c41baeb24dc4">pMoves</a>[i].<a class="code" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___m_o_v_e.html#aec0c7f51ccc870c6a88af7c7390d8eda">pDstTmpAllocation</a>-&gt;<a class="code" href="class_d3_d12_m_a_1_1_allocation.html#a649a3bb1be1a981cbf3f61f3819addca">GetResource</a>(),</div>
<div class="line">            pass.<a class="code" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___p_a_s_s___m_o_v_e___i_n_f_o.html#a719fbdaae54251759605c41baeb24dc4">pMoves</a>[i].<a class="code" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___m_o_v_e.html#a4946b874c958a71c21fac25b515cf5f7">pSrcAllocation</a>-&gt;<a class="code" href="class_d3_d12_m_a_1_1_allocation.html#a649a3bb1be1a981cbf3f61f3819addca">GetResource</a>());</div>
<div class="line">    }</div>
<div class="line">        </div>
<div class="line">    <span class="comment">// Make sure the copy commands finished executing.</span></div>
<div class="line">    cmdQueue-&gt;ExecuteCommandLists(...);</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    WaitForSingleObject(fenceEvent, INFINITE);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Update appropriate descriptors to point to the new places...</span></div>
<div class="line">        </div>
<div class="line">    hr = defragCtx-&gt;<a class="code" href="class_d3_d12_m_a_1_1_defragmentation_context.html#aad502ba70d6dadaeee37703fd8bf90ae">EndPass</a>(&amp;pass);</div>
<div class="line">    <span class="keywordflow">if</span>(hr == S_OK)</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(hr != S_FALSE)</div>
<div class="line">        <span class="comment">// Handle error...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">defragCtx-&gt;Release();</div>
<div class="ttc" id="aclass_d3_d12_m_a_1_1_allocation_html_a414a088c22bae0f29b1038f5f9346d14"><div class="ttname"><a href="class_d3_d12_m_a_1_1_allocation.html#a414a088c22bae0f29b1038f5f9346d14">D3D12MA::Allocation::SetResource</a></div><div class="ttdeci">void SetResource(ID3D12Resource *pResource)</div><div class="ttdoc">Releases the resource currently pointed by the allocation (if any), sets it to new one,...</div></div>
<div class="ttc" id="aclass_d3_d12_m_a_1_1_allocation_html_a47be9557d441797b65de177a3d5cdf60"><div class="ttname"><a href="class_d3_d12_m_a_1_1_allocation.html#a47be9557d441797b65de177a3d5cdf60">D3D12MA::Allocation::GetOffset</a></div><div class="ttdeci">UINT64 GetOffset() const</div><div class="ttdoc">Returns offset in bytes from the start of memory heap.</div></div>
<div class="ttc" id="aclass_d3_d12_m_a_1_1_allocation_html_a649a3bb1be1a981cbf3f61f3819addca"><div class="ttname"><a href="class_d3_d12_m_a_1_1_allocation.html#a649a3bb1be1a981cbf3f61f3819addca">D3D12MA::Allocation::GetResource</a></div><div class="ttdeci">ID3D12Resource * GetResource() const</div><div class="ttdoc">Returns D3D12 resource associated with this object.</div><div class="ttdef"><b>Definition:</b> D3D12MemAlloc.h:491</div></div>
<div class="ttc" id="aclass_d3_d12_m_a_1_1_allocation_html_ac15798741797425b4e9e67bfc991e06b"><div class="ttname"><a href="class_d3_d12_m_a_1_1_allocation.html#ac15798741797425b4e9e67bfc991e06b">D3D12MA::Allocation::GetHeap</a></div><div class="ttdeci">ID3D12Heap * GetHeap() const</div><div class="ttdoc">Returns memory heap that the resource is created in.</div></div>
<div class="ttc" id="aclass_d3_d12_m_a_1_1_defragmentation_context_html"><div class="ttname"><a href="class_d3_d12_m_a_1_1_defragmentation_context.html">D3D12MA::DefragmentationContext</a></div><div class="ttdoc">Represents defragmentation process in progress.</div><div class="ttdef"><b>Definition:</b> D3D12MemAlloc.h:770</div></div>
<div class="ttc" id="aclass_d3_d12_m_a_1_1_defragmentation_context_html_a1606c015d02edc094bb246986159d592"><div class="ttname"><a href="class_d3_d12_m_a_1_1_defragmentation_context.html#a1606c015d02edc094bb246986159d592">D3D12MA::DefragmentationContext::BeginPass</a></div><div class="ttdeci">HRESULT BeginPass(DEFRAGMENTATION_PASS_MOVE_INFO *pPassInfo)</div><div class="ttdoc">Starts single defragmentation pass.</div></div>
<div class="ttc" id="aclass_d3_d12_m_a_1_1_defragmentation_context_html_aad502ba70d6dadaeee37703fd8bf90ae"><div class="ttname"><a href="class_d3_d12_m_a_1_1_defragmentation_context.html#aad502ba70d6dadaeee37703fd8bf90ae">D3D12MA::DefragmentationContext::EndPass</a></div><div class="ttdeci">HRESULT EndPass(DEFRAGMENTATION_PASS_MOVE_INFO *pPassInfo)</div><div class="ttdoc">Ends single defragmentation pass.</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___d_e_s_c_html"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___d_e_s_c.html">D3D12MA::DEFRAGMENTATION_DESC</a></div><div class="ttdoc">Parameters for defragmentation.</div><div class="ttdef"><b>Definition:</b> D3D12MemAlloc.h:672</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___d_e_s_c_html_aac9a357e679a0afa9ab84cd06057630b"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___d_e_s_c.html#aac9a357e679a0afa9ab84cd06057630b">D3D12MA::DEFRAGMENTATION_DESC::Flags</a></div><div class="ttdeci">DEFRAGMENTATION_FLAGS Flags</div><div class="ttdoc">Flags.</div><div class="ttdef"><b>Definition:</b> D3D12MemAlloc.h:674</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___m_o_v_e_html_a4946b874c958a71c21fac25b515cf5f7"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___m_o_v_e.html#a4946b874c958a71c21fac25b515cf5f7">D3D12MA::DEFRAGMENTATION_MOVE::pSrcAllocation</a></div><div class="ttdeci">Allocation * pSrcAllocation</div><div class="ttdoc">Allocation that should be moved.</div><div class="ttdef"><b>Definition:</b> D3D12MemAlloc.h:708</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___m_o_v_e_html_aec0c7f51ccc870c6a88af7c7390d8eda"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___m_o_v_e.html#aec0c7f51ccc870c6a88af7c7390d8eda">D3D12MA::DEFRAGMENTATION_MOVE::pDstTmpAllocation</a></div><div class="ttdeci">Allocation * pDstTmpAllocation</div><div class="ttdoc">Temporary allocation pointing to destination memory that will replace pSrcAllocation.</div><div class="ttdef"><b>Definition:</b> D3D12MemAlloc.h:716</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___p_a_s_s___m_o_v_e___i_n_f_o_html"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___p_a_s_s___m_o_v_e___i_n_f_o.html">D3D12MA::DEFRAGMENTATION_PASS_MOVE_INFO</a></div><div class="ttdoc">Parameters for incremental defragmentation steps.</div><div class="ttdef"><b>Definition:</b> D3D12MemAlloc.h:724</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___p_a_s_s___m_o_v_e___i_n_f_o_html_a719fbdaae54251759605c41baeb24dc4"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___p_a_s_s___m_o_v_e___i_n_f_o.html#a719fbdaae54251759605c41baeb24dc4">D3D12MA::DEFRAGMENTATION_PASS_MOVE_INFO::pMoves</a></div><div class="ttdeci">DEFRAGMENTATION_MOVE * pMoves</div><div class="ttdoc">Array of moves to be performed by the user in the current defragmentation pass.</div><div class="ttdef"><b>Definition:</b> D3D12MemAlloc.h:748</div></div>
<div class="ttc" id="astruct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___p_a_s_s___m_o_v_e___i_n_f_o_html_a8df22d990c318d82fe9fcc5f04132c04"><div class="ttname"><a href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___p_a_s_s___m_o_v_e___i_n_f_o.html#a8df22d990c318d82fe9fcc5f04132c04">D3D12MA::DEFRAGMENTATION_PASS_MOVE_INFO::MoveCount</a></div><div class="ttdeci">UINT32 MoveCount</div><div class="ttdoc">Number of elements in the pMoves array.</div><div class="ttdef"><b>Definition:</b> D3D12MemAlloc.h:726</div></div>
</div><!-- fragment --><p>Although functions like <a class="el" href="class_d3_d12_m_a_1_1_allocator.html#aa37d6b9fe8ea0864f7a35b9d68e8345a" title="Allocates memory and creates a D3D12 resource (buffer or texture). This is the main allocation functi...">D3D12MA::Allocator::CreateResource()</a> create an allocation and a buffer/texture at once, these are just a shortcut for allocating memory and creating a placed resource. Defragmentation works on memory allocations only. You must handle the rest manually. Defragmentation is an iterative process that should repreat "passes" as long as related functions return <code>S_FALSE</code> not <code>S_OK</code>. In each pass:</p>
<ol type="1">
<li><a class="el" href="class_d3_d12_m_a_1_1_defragmentation_context.html#a1606c015d02edc094bb246986159d592" title="Starts single defragmentation pass.">D3D12MA::DefragmentationContext::BeginPass()</a> function call:<ul>
<li>Calculates and returns the list of allocations to be moved in this pass. Note this can be a time-consuming process.</li>
<li>Reserves destination memory for them by creating temporary destination allocations that you can query for their <code>ID3D12Heap</code> + offset using methods like <a class="el" href="class_d3_d12_m_a_1_1_allocation.html#ac15798741797425b4e9e67bfc991e06b" title="Returns memory heap that the resource is created in.">D3D12MA::Allocation::GetHeap()</a>.</li>
</ul>
</li>
<li>Inside the pass, <b>you should</b>:<ul>
<li>Inspect the returned list of allocations to be moved.</li>
<li>Create new buffers/textures as placed at the returned destination temporary allocations.</li>
<li>Copy data from source to destination resources if necessary.</li>
<li>Store the pointer to the new resource in the temporary destination allocation.</li>
</ul>
</li>
<li><a class="el" href="class_d3_d12_m_a_1_1_defragmentation_context.html#aad502ba70d6dadaeee37703fd8bf90ae" title="Ends single defragmentation pass.">D3D12MA::DefragmentationContext::EndPass()</a> function call:<ul>
<li>Frees the source memory reserved for the allocations that are moved.</li>
<li>Modifies source <a class="el" href="class_d3_d12_m_a_1_1_allocation.html" title="Represents single memory allocation.">D3D12MA::Allocation</a> objects that are moved to point to the destination reserved memory and destination resource, while source resource is released.</li>
<li>Frees <code>ID3D12Heap</code> blocks that became empty.</li>
</ul>
</li>
</ol>
<p>Defragmentation algorithm tries to move all suitable allocations. You can, however, refuse to move some of them inside a defragmentation pass, by setting <code>pass.pMoves[i].Operation</code> to D3D12MA::DEFRAGMENTATION_MOVE_OPERATION_IGNORE. This is not recommended and may result in suboptimal packing of the allocations after defragmentation. If you cannot ensure any allocation can be moved, it is better to keep movable allocations separate in a custom pool.</p>
<p>Inside a pass, for each allocation that should be moved:</p>
<ul>
<li>You should copy its data from the source to the destination place by calling e.g. <code>CopyResource()</code>.<ul>
<li>You need to make sure these commands finished executing before the source buffers/textures are released by <a class="el" href="class_d3_d12_m_a_1_1_defragmentation_context.html#aad502ba70d6dadaeee37703fd8bf90ae" title="Ends single defragmentation pass.">D3D12MA::DefragmentationContext::EndPass()</a>.</li>
</ul>
</li>
<li>If a resource doesn't contain any meaningful data, e.g. it is a transient render-target texture to be cleared, filled, and used temporarily in each rendering frame, you can just recreate this texture without copying its data.</li>
<li>If the resource is in <code>D3D12_HEAP_TYPE_READBACK</code> memory, you can copy its data on the CPU using <code>memcpy()</code>.</li>
<li>If you cannot move the allocation, you can set <code>pass.pMoves[i].Operation</code> to D3D12MA::DEFRAGMENTATION_MOVE_OPERATION_IGNORE. This will cancel the move.<ul>
<li><a class="el" href="class_d3_d12_m_a_1_1_defragmentation_context.html#aad502ba70d6dadaeee37703fd8bf90ae" title="Ends single defragmentation pass.">D3D12MA::DefragmentationContext::EndPass()</a> will then free the destination memory not the source memory of the allocation, leaving it unchanged.</li>
</ul>
</li>
<li>If you decide the allocation is unimportant and can be destroyed instead of moved (e.g. it wasn't used for long time), you can set <code>pass.pMoves[i].Operation</code> to D3D12MA::DEFRAGMENTATION_MOVE_OPERATION_DESTROY.<ul>
<li><a class="el" href="class_d3_d12_m_a_1_1_defragmentation_context.html#aad502ba70d6dadaeee37703fd8bf90ae" title="Ends single defragmentation pass.">D3D12MA::DefragmentationContext::EndPass()</a> will then free both source and destination memory, and will destroy the source <a class="el" href="class_d3_d12_m_a_1_1_allocation.html" title="Represents single memory allocation.">D3D12MA::Allocation</a> object.</li>
</ul>
</li>
</ul>
<p>You can defragment a specific custom pool by calling <a class="el" href="class_d3_d12_m_a_1_1_pool.html#adc87bb49c192de8f5a9ca0484c499575" title="Begins defragmentation process of the current pool.">D3D12MA::Pool::BeginDefragmentation</a> or all the default pools by calling <a class="el" href="class_d3_d12_m_a_1_1_allocator.html#a08e1468f1dbb63ce3bf6680e592b2143" title="Begins defragmentation process of the default pools.">D3D12MA::Allocator::BeginDefragmentation</a> (like in the example above).</p>
<p>Defragmentation is always performed in each pool separately. Allocations are never moved between different heap types. The size of the destination memory reserved for a moved allocation is the same as the original one. Alignment of an allocation as it was determined using <code>GetResourceAllocationInfo()</code> is also respected after defragmentation. Buffers/textures should be recreated with the same <code>D3D12_RESOURCE_DESC</code> parameters as the original ones.</p>
<p>You can perform the defragmentation incrementally to limit the number of allocations and bytes to be moved in each pass, e.g. to call it in sync with render frames and not to experience too big hitches. See members: <a class="el" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___d_e_s_c.html#ad8d224e0687a35898970d0a5688c6343" title="Maximum numbers of bytes that can be copied during single pass, while moving allocations to different...">D3D12MA::DEFRAGMENTATION_DESC::MaxBytesPerPass</a>, <a class="el" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___d_e_s_c.html#a83bfb404f387863eafdd6703483aed89" title="Maximum number of allocations that can be moved during single pass to a different place.">D3D12MA::DEFRAGMENTATION_DESC::MaxAllocationsPerPass</a>.</p>
<p>It is also safe to perform the defragmentation asynchronously to render frames and other Direct3D 12 and D3D12MA usage, possibly from multiple threads, with the exception that allocations returned in <a class="el" href="struct_d3_d12_m_a_1_1_d_e_f_r_a_g_m_e_n_t_a_t_i_o_n___p_a_s_s___m_o_v_e___i_n_f_o.html#a719fbdaae54251759605c41baeb24dc4" title="Array of moves to be performed by the user in the current defragmentation pass.">D3D12MA::DEFRAGMENTATION_PASS_MOVE_INFO::pMoves</a> shouldn't be released until the defragmentation pass is ended.</p>
<p><b>Mapping</b> is out of scope of this library and so it is not preserved after an allocation is moved during defragmentation. You need to map the new resource yourself if needed.</p>
<dl class="section note"><dt>Note</dt><dd>Defragmentation is not supported in custom pools created with D3D12MA::POOL_FLAG_ALGORITHM_LINEAR.</dd></dl>
<p>Interleaved allocations and deallocations of many objects of varying size can cause fragmentation over time, which can lead to a situation where the library is unable to find a continuous range of free memory for a new allocation despite there is enough free space, just scattered across many small free ranges between existing allocations.</p>
<p>To mitigate this problem, you can use defragmentation feature. It doesn't happen automatically though and needs your cooperation, because VMA is a low level library that only allocates memory. It cannot recreate buffers and images in a new place as it doesn't remember the contents of <code><a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a></code> / <code><a class="el" href="struct_vk_image_create_info.html">VkImageCreateInfo</a></code> structures. It cannot copy their contents as it doesn't record any commands to a command buffer.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code" href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a> defragInfo = {};</div>
<div class="line">defragInfo.<a class="code" href="struct_vma_defragmentation_info.html#a3302955190e6b5f0d8103698753de949">pool</a> = myPool;</div>
<div class="line">defragInfo.<a class="code" href="struct_vma_defragmentation_info.html#a3e23080c978ecf3abb3180f5b2069da7">flags</a> = VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> defragCtx;</div>
<div class="line">VkResult res = <a class="code" href="group__group__alloc.html#ga0cdd7b0b8653745fa95af9e78d919e70">vmaBeginDefragmentation</a>(allocator, &amp;defragInfo, &amp;defragCtx);</div>
<div class="line"><span class="comment">// Check res...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(;;)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a> pass;</div>
<div class="line">    res = <a class="code" href="group__group__alloc.html#gacbe4a77fdfa7ea29328d2f940d423ab7">vmaBeginDefragmentationPass</a>(allocator, defragCtx, &amp;pass);</div>
<div class="line">    <span class="keywordflow">if</span>(res == VK_SUCCESS)</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(res != VK_INCOMPLETE)</div>
<div class="line">        <span class="comment">// Handle error...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; pass.<a class="code" href="struct_vma_defragmentation_pass_move_info.html#a1b3e18c23f9691f35baf183e615c4408">moveCount</a>; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Inspect pass.pMoves[i].srcAllocation, identify what buffer/image it represents.</span></div>
<div class="line">        <a class="code" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> allocInfo;</div>
<div class="line">        <a class="code" href="group__group__alloc.html#gab9c96ca6bb55ad9069829fe8355bbb79">vmaGetAllocationInfo</a>(allocator, pass.pMoves[i].srcAllocation, &amp;allocInfo);</div>
<div class="line">        MyEngineResourceData* resData = (MyEngineResourceData*)allocInfo.<a class="code" href="struct_vma_allocation_info.html#ad0ea9d64dd733ffd7beff7af6d289ad0">pUserData</a>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Recreate and bind this buffer/image at: pass.pMoves[i].dstMemory, pass.pMoves[i].dstOffset.</span></div>
<div class="line">        <a class="code" href="struct_vk_image_create_info.html">VkImageCreateInfo</a> imgCreateInfo = ...</div>
<div class="line">        VkImage newImg;</div>
<div class="line">        res = vkCreateImage(device, &amp;imgCreateInfo, <span class="keyword">nullptr</span>, &amp;newImg);</div>
<div class="line">        <span class="comment">// Check res...</span></div>
<div class="line">        res = <a class="code" href="group__group__alloc.html#ga3a5d8d9f2a29b42cf87f0f8dfef591f4">vmaBindImageMemory</a>(allocator, pass.pMoves[i].dstTmpAllocation, newImg);</div>
<div class="line">        <span class="comment">// Check res...</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Issue a vkCmdCopyBuffer/vkCmdCopyImage to copy its content to the new place.</span></div>
<div class="line">        vkCmdCopyImage(cmdBuf, resData-&gt;img, ..., newImg, ...);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Make sure the copy commands finished executing.</span></div>
<div class="line">    vkWaitForFences(...);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Destroy old buffers/images bound with pass.pMoves[i].srcAllocation.</span></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; pass.<a class="code" href="struct_vma_defragmentation_pass_move_info.html#a1b3e18c23f9691f35baf183e615c4408">moveCount</a>; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">        vkDestroyImage(device, resData-&gt;img, <span class="keyword">nullptr</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Update appropriate descriptors to point to the new places...</span></div>
<div class="line"> </div>
<div class="line">    res = <a class="code" href="group__group__alloc.html#gabbc69db60f82972ddffaceb6653e344a">vmaEndDefragmentationPass</a>(allocator, defragCtx, &amp;pass);</div>
<div class="line">    <span class="keywordflow">if</span>(res == VK_SUCCESS)</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(res != VK_INCOMPLETE)</div>
<div class="line">        <span class="comment">// Handle error...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__group__alloc.html#gae419e366d1c015716165bdfd5aafef6f">vmaEndDefragmentation</a>(allocator, defragCtx, <span class="keyword">nullptr</span>);</div>
<div class="ttc" id="agroup__group__alloc_html_ga0cdd7b0b8653745fa95af9e78d919e70"><div class="ttname"><a href="group__group__alloc.html#ga0cdd7b0b8653745fa95af9e78d919e70">vmaBeginDefragmentation</a></div><div class="ttdeci">VMA_CALL_PRE VkResult VMA_CALL_POST vmaBeginDefragmentation(VmaAllocator VMA_NOT_NULL allocator, const VmaDefragmentationInfo *VMA_NOT_NULL pInfo, VmaDefragmentationContext VMA_NULLABLE *VMA_NOT_NULL pContext)</div><div class="ttdoc">Begins defragmentation process.</div></div>
<div class="ttc" id="agroup__group__alloc_html_ga3a5d8d9f2a29b42cf87f0f8dfef591f4"><div class="ttname"><a href="group__group__alloc.html#ga3a5d8d9f2a29b42cf87f0f8dfef591f4">vmaBindImageMemory</a></div><div class="ttdeci">VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindImageMemory(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkImage VMA_NOT_NULL_NON_DISPATCHABLE image)</div><div class="ttdoc">Binds image to allocation.</div></div>
<div class="ttc" id="agroup__group__alloc_html_gab9c96ca6bb55ad9069829fe8355bbb79"><div class="ttname"><a href="group__group__alloc.html#gab9c96ca6bb55ad9069829fe8355bbb79">vmaGetAllocationInfo</a></div><div class="ttdeci">VMA_CALL_PRE void VMA_CALL_POST vmaGetAllocationInfo(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VmaAllocationInfo *VMA_NOT_NULL pAllocationInfo)</div><div class="ttdoc">Returns current information about specified allocation.</div></div>
<div class="ttc" id="agroup__group__alloc_html_gabbc69db60f82972ddffaceb6653e344a"><div class="ttname"><a href="group__group__alloc.html#gabbc69db60f82972ddffaceb6653e344a">vmaEndDefragmentationPass</a></div><div class="ttdeci">VMA_CALL_PRE VkResult VMA_CALL_POST vmaEndDefragmentationPass(VmaAllocator VMA_NOT_NULL allocator, VmaDefragmentationContext VMA_NOT_NULL context, VmaDefragmentationPassMoveInfo *VMA_NOT_NULL pPassInfo)</div><div class="ttdoc">Ends single defragmentation pass.</div></div>
<div class="ttc" id="agroup__group__alloc_html_gacbe4a77fdfa7ea29328d2f940d423ab7"><div class="ttname"><a href="group__group__alloc.html#gacbe4a77fdfa7ea29328d2f940d423ab7">vmaBeginDefragmentationPass</a></div><div class="ttdeci">VMA_CALL_PRE VkResult VMA_CALL_POST vmaBeginDefragmentationPass(VmaAllocator VMA_NOT_NULL allocator, VmaDefragmentationContext VMA_NOT_NULL context, VmaDefragmentationPassMoveInfo *VMA_NOT_NULL pPassInfo)</div><div class="ttdoc">Starts single defragmentation pass.</div></div>
<div class="ttc" id="agroup__group__alloc_html_gae419e366d1c015716165bdfd5aafef6f"><div class="ttname"><a href="group__group__alloc.html#gae419e366d1c015716165bdfd5aafef6f">vmaEndDefragmentation</a></div><div class="ttdeci">VMA_CALL_PRE void VMA_CALL_POST vmaEndDefragmentation(VmaAllocator VMA_NOT_NULL allocator, VmaDefragmentationContext VMA_NOT_NULL context, VmaDefragmentationStats *VMA_NULLABLE pStats)</div><div class="ttdoc">Ends defragmentation process.</div></div>
<div class="ttc" id="astruct_vk_image_create_info_html"><div class="ttname"><a href="struct_vk_image_create_info.html">VkImageCreateInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan.h:10069</div></div>
<div class="ttc" id="astruct_vma_allocation_info_html"><div class="ttname"><a href="struct_vma_allocation_info.html">VmaAllocationInfo</a></div><div class="ttdoc">Parameters of VmaAllocation objects, that can be retrieved using function vmaGetAllocationInfo().</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:1334</div></div>
<div class="ttc" id="astruct_vma_allocation_info_html_ad0ea9d64dd733ffd7beff7af6d289ad0"><div class="ttname"><a href="struct_vma_allocation_info.html#ad0ea9d64dd733ffd7beff7af6d289ad0">VmaAllocationInfo::pUserData</a></div><div class="ttdeci">void *VMA_NULLABLE pUserData</div><div class="ttdoc">Custom general-purpose pointer that was passed as VmaAllocationCreateInfo::pUserData or set using vma...</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:1381</div></div>
<div class="ttc" id="astruct_vma_defragmentation_context_html"><div class="ttname"><a href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a></div><div class="ttdoc">An opaque object that represents started defragmentation process.</div></div>
<div class="ttc" id="astruct_vma_defragmentation_info_html"><div class="ttname"><a href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a></div><div class="ttdoc">Parameters for defragmentation.</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:1397</div></div>
<div class="ttc" id="astruct_vma_defragmentation_info_html_a3302955190e6b5f0d8103698753de949"><div class="ttname"><a href="struct_vma_defragmentation_info.html#a3302955190e6b5f0d8103698753de949">VmaDefragmentationInfo::pool</a></div><div class="ttdeci">VmaPool VMA_NULLABLE pool</div><div class="ttdoc">Custom pool to be defragmented.</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:1404</div></div>
<div class="ttc" id="astruct_vma_defragmentation_info_html_a3e23080c978ecf3abb3180f5b2069da7"><div class="ttname"><a href="struct_vma_defragmentation_info.html#a3e23080c978ecf3abb3180f5b2069da7">VmaDefragmentationInfo::flags</a></div><div class="ttdeci">VmaDefragmentationFlags flags</div><div class="ttdoc">Use combination of VmaDefragmentationFlagBits.</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:1399</div></div>
<div class="ttc" id="astruct_vma_defragmentation_pass_move_info_html"><div class="ttname"><a href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a></div><div class="ttdoc">Parameters for incremental defragmentation steps.</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:1438</div></div>
<div class="ttc" id="astruct_vma_defragmentation_pass_move_info_html_a1b3e18c23f9691f35baf183e615c4408"><div class="ttname"><a href="struct_vma_defragmentation_pass_move_info.html#a1b3e18c23f9691f35baf183e615c4408">VmaDefragmentationPassMoveInfo::moveCount</a></div><div class="ttdeci">uint32_t moveCount</div><div class="ttdoc">Number of elements in the pMoves array.</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:1440</div></div>
</div><!-- fragment --><p>Although functions like <a class="el" href="group__group__alloc.html#gae9773fe0ef8582e23136d2d83c336ab9" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="group__group__alloc.html#gaa76142ae43535c862ad9e194a6e38aaa" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>, <a class="el" href="group__group__alloc.html#gafcc45e5a6388ab35daa9a46688baee20" title="Destroys Vulkan buffer and frees allocated memory.">vmaDestroyBuffer()</a>, <a class="el" href="group__group__alloc.html#ga2f6367e612daace5c5ecd7ef9e47c3fd" title="Destroys Vulkan image and frees allocated memory.">vmaDestroyImage()</a> create/destroy an allocation and a buffer/image at once, these are just a shortcut for creating the resource, allocating memory, and binding them together. Defragmentation works on memory allocations only. You must handle the rest manually. Defragmentation is an iterative process that should repreat "passes" as long as related functions return <code>VK_INCOMPLETE</code> not <code>VK_SUCCESS</code>. In each pass:</p>
<ol type="1">
<li><a class="el" href="group__group__alloc.html#gacbe4a77fdfa7ea29328d2f940d423ab7" title="Starts single defragmentation pass.">vmaBeginDefragmentationPass()</a> function call:<ul>
<li>Calculates and returns the list of allocations to be moved in this pass. Note this can be a time-consuming process.</li>
<li>Reserves destination memory for them by creating temporary destination allocations that you can query for their <code>VkDeviceMemory</code> + offset using <a class="el" href="group__group__alloc.html#gab9c96ca6bb55ad9069829fe8355bbb79" title="Returns current information about specified allocation.">vmaGetAllocationInfo()</a>.</li>
</ul>
</li>
<li>Inside the pass, <b>you should</b>:<ul>
<li>Inspect the returned list of allocations to be moved.</li>
<li>Create new buffers/images and bind them at the returned destination temporary allocations.</li>
<li>Copy data from source to destination resources if necessary.</li>
<li>Destroy the source buffers/images, but NOT their allocations.</li>
</ul>
</li>
<li><a class="el" href="group__group__alloc.html#gabbc69db60f82972ddffaceb6653e344a" title="Ends single defragmentation pass.">vmaEndDefragmentationPass()</a> function call:<ul>
<li>Frees the source memory reserved for the allocations that are moved.</li>
<li>Modifies source <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a> objects that are moved to point to the destination reserved memory.</li>
<li>Frees <code>VkDeviceMemory</code> blocks that became empty.</li>
</ul>
</li>
</ol>
<p>Unlike in previous iterations of the defragmentation API, there is no list of "movable" allocations passed as a parameter. Defragmentation algorithm tries to move all suitable allocations. You can, however, refuse to move some of them inside a defragmentation pass, by setting <code>pass.pMoves[i].operation</code> to <a class="el" href="group__group__alloc.html#ggada9e3861caf96f08894b0bcc160ec257ad25bc6f816b226b4fd5170e845f218d2" title="Set this value if you cannot move the allocation. New place reserved at dstTmpAllocation will be free...">VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE</a>. This is not recommended and may result in suboptimal packing of the allocations after defragmentation. If you cannot ensure any allocation can be moved, it is better to keep movable allocations separate in a custom pool.</p>
<p>Inside a pass, for each allocation that should be moved:</p>
<ul>
<li>You should copy its data from the source to the destination place by calling e.g. <code>vkCmdCopyBuffer()</code>, <code>vkCmdCopyImage()</code>.<ul>
<li>You need to make sure these commands finished executing before destroying the source buffers/images and before calling <a class="el" href="group__group__alloc.html#gabbc69db60f82972ddffaceb6653e344a" title="Ends single defragmentation pass.">vmaEndDefragmentationPass()</a>.</li>
</ul>
</li>
<li>If a resource doesn't contain any meaningful data, e.g. it is a transient color attachment image to be cleared, filled, and used temporarily in each rendering frame, you can just recreate this image without copying its data.</li>
<li>If the resource is in <code>HOST_VISIBLE</code> and <code>HOST_CACHED</code> memory, you can copy its data on the CPU using <code>memcpy()</code>.</li>
<li>If you cannot move the allocation, you can set <code>pass.pMoves[i].operation</code> to <a class="el" href="group__group__alloc.html#ggada9e3861caf96f08894b0bcc160ec257ad25bc6f816b226b4fd5170e845f218d2" title="Set this value if you cannot move the allocation. New place reserved at dstTmpAllocation will be free...">VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE</a>. This will cancel the move.<ul>
<li><a class="el" href="group__group__alloc.html#gabbc69db60f82972ddffaceb6653e344a" title="Ends single defragmentation pass.">vmaEndDefragmentationPass()</a> will then free the destination memory not the source memory of the allocation, leaving it unchanged.</li>
</ul>
</li>
<li>If you decide the allocation is unimportant and can be destroyed instead of moved (e.g. it wasn't used for long time), you can set <code>pass.pMoves[i].operation</code> to <a class="el" href="group__group__alloc.html#ggada9e3861caf96f08894b0bcc160ec257a9786f8492a9be2c03bd26395e352ab85" title="Set this value if you decide to abandon the allocation and you destroyed the buffer/image....">VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY</a>.<ul>
<li><a class="el" href="group__group__alloc.html#gabbc69db60f82972ddffaceb6653e344a" title="Ends single defragmentation pass.">vmaEndDefragmentationPass()</a> will then free both source and destination memory, and will destroy the source <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a> object.</li>
</ul>
</li>
</ul>
<p>You can defragment a specific custom pool by setting <a class="el" href="struct_vma_defragmentation_info.html#a3302955190e6b5f0d8103698753de949" title="Custom pool to be defragmented.">VmaDefragmentationInfo::pool</a> (like in the example above) or all the default pools by setting this member to null.</p>
<p>Defragmentation is always performed in each pool separately. Allocations are never moved between different Vulkan memory types. The size of the destination memory reserved for a moved allocation is the same as the original one. Alignment of an allocation as it was determined using <code>vkGetBufferMemoryRequirements()</code> etc. is also respected after defragmentation. Buffers/images should be recreated with the same <code><a class="el" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a></code> / <code><a class="el" href="struct_vk_image_create_info.html">VkImageCreateInfo</a></code> parameters as the original ones.</p>
<p>You can perform the defragmentation incrementally to limit the number of allocations and bytes to be moved in each pass, e.g. to call it in sync with render frames and not to experience too big hitches. See members: <a class="el" href="struct_vma_defragmentation_info.html#a637ada77b02179a27fa92290000afac4" title="Maximum numbers of bytes that can be copied during single pass, while moving allocations to different...">VmaDefragmentationInfo::maxBytesPerPass</a>, <a class="el" href="struct_vma_defragmentation_info.html#ac2db29d309bebc4f7d55041416e9694b" title="Maximum number of allocations that can be moved during single pass to a different place.">VmaDefragmentationInfo::maxAllocationsPerPass</a>.</p>
<p>It is also safe to perform the defragmentation asynchronously to render frames and other Vulkan and VMA usage, possibly from multiple threads, with the exception that allocations returned in VmaDefragmentationPassMoveInfo::pMoves shouldn't be destroyed until the defragmentation pass is ended.</p>
<p><b>Mapping</b> is preserved on allocations that are moved during defragmentation. Whether through <a class="el" href="group__group__alloc.html#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a> or <a class="el" href="group__group__alloc.html#ga13b93ec0ed38ad7232300cb94931c8d2" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>, the allocations are mapped at their new place. Of course, pointer to the mapped data changes, so it needs to be queried using <a class="el" href="struct_vma_allocation_info.html#a17a39eb34201a610347acb91b38eca79" title="Pointer to the beginning of this allocation as mapped data.">VmaAllocationInfo::pMappedData</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Defragmentation is not supported in custom pools created with <a class="el" href="group__group__alloc.html#gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" title="Enables alternative, linear allocation algorithm in this pool.">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</a>. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 8 2024 21:27:29 for Open 3D Engine Atom Gem API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
