<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine Atom Gem API Reference: AZ::RHI::PipelineStateCache Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-placeholder-text"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine Atom Gem API Reference
   &#160;<span id="projectnumber">24.09</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_a_z_1_1_r_h_i_1_1_pipeline_state_cache.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_a_z_1_1_r_h_i_1_1_pipeline_state_cache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AZ::RHI::PipelineStateCache Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;PipelineStateCache.h&gt;</code></p>

<p>Inherits AZStd::intrusive_base.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa4cc40e2d0523da822151575bdc66414"><td class="memItemLeft" align="right" valign="top"><a id="aa4cc40e2d0523da822151575bdc66414"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_CLASS_ALLOCATOR</b> (<a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state_cache.html">PipelineStateCache</a>, SystemAllocator)</td></tr>
<tr class="separator:aa4cc40e2d0523da822151575bdc66414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af620506570de69470b52fe56c499db75"><td class="memItemLeft" align="right" valign="top"><a id="af620506570de69470b52fe56c499db75"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state_cache.html#af620506570de69470b52fe56c499db75">Reset</a> ()</td></tr>
<tr class="memdesc:af620506570de69470b52fe56c499db75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the caches of all pipeline libraries back to empty. All internal references to pipeline states are released. <br /></td></tr>
<tr class="separator:af620506570de69470b52fe56c499db75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea290c65855487e742ed6d14b607654"><td class="memItemLeft" align="right" valign="top"><a id="a6ea290c65855487e742ed6d14b607654"></a>
<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">PipelineLibraryHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state_cache.html#a6ea290c65855487e742ed6d14b607654">CreateLibrary</a> (const <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_library_data.html">PipelineLibraryData</a> *serializedData, const AZStd::string &amp;filePath=&quot;&quot;)</td></tr>
<tr class="memdesc:a6ea290c65855487e742ed6d14b607654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an internal pipeline library instance and returns its handle. <br /></td></tr>
<tr class="separator:a6ea290c65855487e742ed6d14b607654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83879909e07ccc6f513f58ddc641823"><td class="memItemLeft" align="right" valign="top"><a id="ab83879909e07ccc6f513f58ddc641823"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state_cache.html#ab83879909e07ccc6f513f58ddc641823">ReleaseLibrary</a> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">PipelineLibraryHandle</a> handle)</td></tr>
<tr class="memdesc:ab83879909e07ccc6f513f58ddc641823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the pipeline library and purges it from the cache. Releases all held references to pipeline states for the library. <br /></td></tr>
<tr class="separator:ab83879909e07ccc6f513f58ddc641823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6307b23fa04d617a78949568af486f7"><td class="memItemLeft" align="right" valign="top"><a id="aa6307b23fa04d617a78949568af486f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state_cache.html#aa6307b23fa04d617a78949568af486f7">ResetLibrary</a> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">PipelineLibraryHandle</a> handle)</td></tr>
<tr class="memdesc:aa6307b23fa04d617a78949568af486f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets cache contents in the library. Releases all held references to pipeline states for the library. <br /></td></tr>
<tr class="separator:aa6307b23fa04d617a78949568af486f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06a44ba5f1e26971d022add87d94df6"><td class="memItemLeft" align="right" valign="top">Ptr&lt; <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_library.html">PipelineLibrary</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state_cache.html#ab06a44ba5f1e26971d022add87d94df6">GetMergedLibrary</a> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">PipelineLibraryHandle</a> handle) const</td></tr>
<tr class="separator:ab06a44ba5f1e26971d022add87d94df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389b300388befc92df29938b7c1c17b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state.html">PipelineState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state_cache.html#a389b300388befc92df29938b7c1c17b0">AcquirePipelineState</a> (<a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">PipelineLibraryHandle</a> library, const <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state_descriptor.html">PipelineStateDescriptor</a> &amp;descriptor, const AZ::Name &amp;name=AZ::Name())</td></tr>
<tr class="separator:a389b300388befc92df29938b7c1c17b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e927b1d8797d83557bee7642379886b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state_cache.html#a1e927b1d8797d83557bee7642379886b">Compact</a> ()</td></tr>
<tr class="separator:a1e927b1d8797d83557bee7642379886b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae25b4bb1befd7de2652d167825d40796"><td class="memItemLeft" align="right" valign="top"><a id="ae25b4bb1befd7de2652d167825d40796"></a>
static Ptr&lt; <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state_cache.html">PipelineStateCache</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Create</b> (<a class="el" href="class_a_z_1_1_r_h_i_1_1_device.html">Device</a> &amp;device)</td></tr>
<tr class="separator:ae25b4bb1befd7de2652d167825d40796"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ada90877801cd1ee732db41585c6ff5fa"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state_cache.html#ada90877801cd1ee732db41585c6ff5fa">LibraryCountMax</a> = 256</td></tr>
<tr class="separator:ada90877801cd1ee732db41585c6ff5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Problem: High-level rendering code works in 'materials', 'shaders', and 'models', but the RHI works in 'pipeline states'. Therefore, a translation process must exist to resolve a shader variation (plus runtime state) into a pipeline state suitable for consumption by the RHI. These resolve operations can number in the thousands per frame, and (ideally) are heavily jobified.</p>
<p>Another problem is that pipeline state creation is not fast, as on some platforms it will involve synchronous byte-code compilation. This could take anywhere from &lt;1ms to &gt;150ms. If compilation is done synchronously and immediately, the cache will effectively stall the entire process if multiple threads request the same pending pipeline state.</p>
<p>Therefore, <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state_cache.html">PipelineStateCache</a> adheres to the following requirements:</p><ol type="1">
<li>A cache miss does not serialize all threads on a pipeline state compilation event.</li>
<li>A cache hit results in zero contention.</li>
</ol>
<p>Justification: Most pipeline state compilation will occur in the first few frames, but can also occur when new 'permutations' are hit while exploring. In the 90% case, the cache is warm and each frame results in a 100% cache hit rate. With zero locks, this scales extremely well across threads and removes a bottleneck from the render code. In the event that compilations are required, multiple threads are now able to participate in the compilation process without serializing each other.</p>
<p>To accomplish this, the pipeline state cache uses three 'phases' of caching.</p><ol type="1">
<li>A global, read-only cache - designed as the 'fast path' for when the cache is warm.</li>
<li>A thread-local cache - reduces contention on the global pending cache for successive requests on the same thread.</li>
<li>A global, locked pending cache - de-duplicates pipeline state allocations.</li>
</ol>
<p>Each library has global and thread-local caches. Initially, the global cache is checked, if that fails, the thread-local cache is checked (no locks taken). Finally, the pending cache is checked under a lock and if the entry still doesn't exist, it is allocated and added to the pending cache. A thread-local <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_library.html">PipelineLibrary</a> is used to compile the pipeline state, which eliminates all locking for compilation.</p>
<p>Pipeline states can be acquired at any time and from any thread. The cache will take a reader lock. During AcquirePipelineState, the global read-only cache is not updated, but the thread-local cache and pending global cache may be. Furthermore, compilations are performed on the calling thread, which means that separate thread may return a pipeline state that is still compiling. It is required that all pending AcquirePipelineState calls complete prior to using the returned pipeline state pointers during command list recording.</p>
<p>Example Scenarios:</p>
<ol type="1">
<li><p class="startli">Threads request the same un-cached pipeline state:</p>
<p class="startli">Both the global read-only cache and thread-local caches miss, one thread wins the race to take a lock on the global pending cache. It allocates but does not compile the pipeline state. All other threads wait on the lock (which should be quick) and then find and return the uninitialized pipeline state. The compiling thread uses the thread-local <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_library.html">PipelineLibrary</a> instance to compile the pipeline state. Non-compiling threads will enter the uninitialized pipeline state into their thread-local cache (as does the compiling thread once it completes). Note that the compiling thread is now busy, but all remaining threads are now unblocked to compile other pipeline states.</p>
</li>
<li><p class="startli">A thread requests a pipeline state being compiled on another thread:</p>
<p class="startli">In this case, the global read-only cache won't have the pipeline state (since it's being compiled during the current cycle, and the pending cache is only merged at the end of the cycle). It also won't have the entry in the thread-local cache. It then hits the global pending cache, which will return the live instance (being compiled). It then caches the result in its thread-local cache, so that successive requests will no longer require a lock on the pending cache.</p>
</li>
<li><p class="startli">The cache is warm and all pipeline states are compiled:</p>
<p class="startli">Each thread hits the same read-only cache (which succeeds) and returns the pipeline state immediately. This is the fast-path case where multiple threads are now able to resolve pipeline states with very little performance overhead.</p>
</li>
</ol>
<p>Example Usage: </p><div class="fragment"><div class="line"><span class="comment">// Create library instance.</span></div>
<div class="line">RHI::PipelineLibraryHandle libraryHandle = pipelineStateCache-&gt;CreateLibrary(serializedData); <span class="comment">// Initial data loaded from disk.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// In jobs. Lots and lots of requests.</span></div>
<div class="line"><span class="keyword">const</span> RHI::PipelineState* pipelineState = pipelineStateCache-&gt;AcquirePipelineState(libraryHandle, descriptor);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reset contents of library. Releases all pipeline state references. Library remains valid.</span></div>
<div class="line">pipelineStateCache-&gt;ResetLibrary(libraryHandle);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Release library and all held references.</span></div>
<div class="line">pipelineStateCache-&gt;ReleaseLibrary(libraryHandle);</div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a389b300388befc92df29938b7c1c17b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389b300388befc92df29938b7c1c17b0">&#9670;&nbsp;</a></span>AcquirePipelineState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state.html">PipelineState</a>* AZ::RHI::PipelineStateCache::AcquirePipelineState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">PipelineLibraryHandle</a>&#160;</td>
          <td class="paramname"><em>library</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state_descriptor.html">PipelineStateDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Name &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>AZ::Name()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires a pipeline state (either draw or dispatch variants) from the cache. Pipeline states are associated to a specific library handle. Successive calls with the same pipeline state descriptor hash will return the same pipeline state, even across threads. If the library handle is invalid or the acquire operation fails, a null pointer is returned. Otherwise, a valid pipeline state pointer is returned (regardless of whether pipeline state compilation succeeds).</p>
<p>It is permitted to take a strong reference to the returned pointer, but is not necessary as long as the reference is discarded on a library reset / release event. The cache will store a reference internally. If a strong reference is held externally, the instance will remain valid even after the cache is reset / destroyed. </p>

</div>
</div>
<a id="a1e927b1d8797d83557bee7642379886b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e927b1d8797d83557bee7642379886b">&#9670;&nbsp;</a></span>Compact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::RHI::PipelineStateCache::Compact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method merges the global pending cache into the global read-only cache and clears all thread-local caches. This reduces the total memory footprint of the caches and optimizes subsequent fetches. This method should be called once per frame. </p>

</div>
</div>
<a id="ab06a44ba5f1e26971d022add87d94df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06a44ba5f1e26971d022add87d94df6">&#9670;&nbsp;</a></span>GetMergedLibrary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ptr&lt;<a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_library.html">PipelineLibrary</a>&gt; AZ::RHI::PipelineStateCache::GetMergedLibrary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_r_h_i_1_1_handle.html">PipelineLibraryHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the resulting merged library from all the threadLibraries related to the passed in handle. The merged library can be used to write out the serialized data. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ada90877801cd1ee732db41585c6ff5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada90877801cd1ee732db41585c6ff5fa">&#9670;&nbsp;</a></span>LibraryCountMax</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t AZ::RHI::PipelineStateCache::LibraryCountMax = 256</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum number of libraries is configurable at compile time. A fixed number is used to avoid having to lazily resize thread-local arrays when traversing them, and also to avoid a pointer indirection on access. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Gems/Atom/RHI/Code/Include/Atom/RHI/PipelineStateCache.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><b>RHI</b></li><li class="navelem"><a class="el" href="class_a_z_1_1_r_h_i_1_1_pipeline_state_cache.html">PipelineStateCache</a></li>
    <li class="footer">Generated on Tue Oct 8 2024 21:27:33 for Open 3D Engine Atom Gem API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
