<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine Archive Gem API Reference: Archive::IArchiveWriter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Open 3D Engine Archive Gem API Reference<span id="projectnumber">&#160;23.10.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_archive_1_1_i_archive_writer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_archive_1_1_i_archive_writer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Archive::IArchiveWriter Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;ArchiveWriterAPI.h&gt;</code></p>

<p>Inherited by <a class="el" href="class_archive_1_1_archive_writer.html">Archive::ArchiveWriter</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_archive_1_1_i_archive_writer_1_1_archive_stream_deleter.html">ArchiveStreamDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab44ee4b7b81cfdd8dda189e43db7e5e4"><td class="memItemLeft" align="right" valign="top"><a id="ab44ee4b7b81cfdd8dda189e43db7e5e4" name="ab44ee4b7b81cfdd8dda189e43db7e5e4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ArchiveStreamPtr</b> = AZStd::unique_ptr&lt; AZ::IO::GenericStream, <a class="el" href="struct_archive_1_1_i_archive_writer_1_1_archive_stream_deleter.html">ArchiveStreamDeleter</a> &gt;</td></tr>
<tr class="separator:ab44ee4b7b81cfdd8dda189e43db7e5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545eb320cc034dfeee10df545218ed71"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_archive_1_1_i_archive_writer.html#a545eb320cc034dfeee10df545218ed71">CommitResult</a> = AZStd::expected&lt; void, ResultString &gt;</td></tr>
<tr class="separator:a545eb320cc034dfeee10df545218ed71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6c37197fa6801feef69a30cbff415f59"><td class="memItemLeft" align="right" valign="top"><a id="a6c37197fa6801feef69a30cbff415f59" name="a6c37197fa6801feef69a30cbff415f59"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_TYPE_INFO_WITH_NAME_DECL</b> (<a class="el" href="class_archive_1_1_i_archive_writer.html">IArchiveWriter</a>)</td></tr>
<tr class="separator:a6c37197fa6801feef69a30cbff415f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc33ad38fab13e217271926e6c345597"><td class="memItemLeft" align="right" valign="top"><a id="acc33ad38fab13e217271926e6c345597" name="acc33ad38fab13e217271926e6c345597"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_RTTI_NO_TYPE_INFO_DECL</b> ()</td></tr>
<tr class="separator:acc33ad38fab13e217271926e6c345597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4183bac9cb061da0261ca030e13f138"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_archive_1_1_i_archive_writer.html#ac4183bac9cb061da0261ca030e13f138">MountArchive</a> (AZ::IO::PathView archivePath)=0</td></tr>
<tr class="separator:ac4183bac9cb061da0261ca030e13f138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8b17df0bdba60612ccfca6ad36f9ec"><td class="memItemLeft" align="right" valign="top"><a id="ada8b17df0bdba60612ccfca6ad36f9ec" name="ada8b17df0bdba60612ccfca6ad36f9ec"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>MountArchive</b> (ArchiveStreamPtr archiveStream)=0</td></tr>
<tr class="separator:ada8b17df0bdba60612ccfca6ad36f9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f58c02ad20883eaa88bcc06a562b67"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_archive_1_1_i_archive_writer.html#a30f58c02ad20883eaa88bcc06a562b67">UnmountArchive</a> ()=0</td></tr>
<tr class="separator:a30f58c02ad20883eaa88bcc06a562b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8a56a30aef8781686a1ea1f8eae243"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_archive_1_1_i_archive_writer.html#ade8a56a30aef8781686a1ea1f8eae243">IsMounted</a> () const =0</td></tr>
<tr class="memdesc:ade8a56a30aef8781686a1ea1f8eae243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if an open archive that is mounted.  <br /></td></tr>
<tr class="separator:ade8a56a30aef8781686a1ea1f8eae243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c149915fd3d922bfc8283187d6e69be"><td class="memItemLeft" align="right" valign="top"><a id="a6c149915fd3d922bfc8283187d6e69be" name="a6c149915fd3d922bfc8283187d6e69be"></a>
virtual <a class="el" href="class_archive_1_1_i_archive_writer.html#a545eb320cc034dfeee10df545218ed71">CommitResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Commit</b> ()=0</td></tr>
<tr class="separator:a6c149915fd3d922bfc8283187d6e69be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74dbf91069f5a05aea786a4ecc30101a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_archive_1_1_archive_add_file_result.html">ArchiveAddFileResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_archive_1_1_i_archive_writer.html#a74dbf91069f5a05aea786a4ecc30101a">AddFileToArchive</a> (AZ::IO::GenericStream &amp;inputStream, const <a class="el" href="struct_archive_1_1_archive_writer_file_settings.html">ArchiveWriterFileSettings</a> &amp;fileSettings)=0</td></tr>
<tr class="separator:a74dbf91069f5a05aea786a4ecc30101a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f1de7195a336912905e6c6dd89774a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_archive_1_1_archive_add_file_result.html">ArchiveAddFileResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_archive_1_1_i_archive_writer.html#af6f1de7195a336912905e6c6dd89774a">AddFileToArchive</a> (AZStd::span&lt; const AZStd::byte &gt; inputSpan, const <a class="el" href="struct_archive_1_1_archive_writer_file_settings.html">ArchiveWriterFileSettings</a> &amp;fileSettings)=0</td></tr>
<tr class="separator:af6f1de7195a336912905e6c6dd89774a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97068ae798f8f697dfa2b35f26979acb"><td class="memItemLeft" align="right" valign="top">virtual ArchiveFileToken&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_archive_1_1_i_archive_writer.html#a97068ae798f8f697dfa2b35f26979acb">FindFile</a> (AZ::IO::PathView relativePath) const =0</td></tr>
<tr class="separator:a97068ae798f8f697dfa2b35f26979acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8829b197b966de03ef08ea5906fdde14"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_archive_1_1_i_archive_writer.html#a8829b197b966de03ef08ea5906fdde14">ContainsFile</a> (AZ::IO::PathView relativePath) const =0</td></tr>
<tr class="separator:a8829b197b966de03ef08ea5906fdde14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affddcc2f58bea7fc3f8e6f352d85cb68"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_archive_1_1_archive_remove_file_result.html">ArchiveRemoveFileResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_archive_1_1_i_archive_writer.html#affddcc2f58bea7fc3f8e6f352d85cb68">RemoveFileFromArchive</a> (ArchiveFileToken filePathToken)=0</td></tr>
<tr class="separator:affddcc2f58bea7fc3f8e6f352d85cb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c04b27aaf52d4251043b47b959a834"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_archive_1_1_archive_remove_file_result.html">ArchiveRemoveFileResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_archive_1_1_i_archive_writer.html#ae4c04b27aaf52d4251043b47b959a834">RemoveFileFromArchive</a> (AZ::IO::PathView relativePath)=0</td></tr>
<tr class="separator:ae4c04b27aaf52d4251043b47b959a834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b79ace32a190f69021800e869b6ab4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_archive_1_1_i_archive_writer.html#a24b79ace32a190f69021800e869b6ab4">DumpArchiveMetadata</a> (AZ::IO::GenericStream &amp;metadataStream, const <a class="el" href="struct_archive_1_1_archive_metadata_settings.html">ArchiveMetadataSettings</a> &amp;metadataSettings={}) const =0</td></tr>
<tr class="separator:a24b79ace32a190f69021800e869b6ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae3304217cbc75865e32d62cda2dfcd77"><td class="memItemLeft" align="right" valign="top"><a id="ae3304217cbc75865e32d62cda2dfcd77" name="ae3304217cbc75865e32d62cda2dfcd77"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_CLASS_ALLOCATOR_DECL</b></td></tr>
<tr class="separator:ae3304217cbc75865e32d62cda2dfcd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for the <a class="el" href="class_archive_1_1_archive_writer.html">ArchiveWriter</a> of O3DE Archive format The caller is required to supply a <a class="el" href="struct_archive_1_1_archive_writer_settings.html">ArchiveWriterSettings</a> structure instance which contains the <a class="el" href="struct_archive_1_1_archive_header.html">ArchiveHeader</a> and <a class="el" href="struct_archive_1_1_archive_table_of_contents.html">ArchiveTableOfContents</a> data to use when writing to the Archive file The class can be initialized with a user supplied AZ::IO::GenericStream class in which case the stream needs to be open with OpenMode::ModeUpdate The reason why is that to locate information about any content files in order to update an existing archive it read access is needed The recommend OpenMode value for opening a new archive or updating an existing archive are as follows constexpr OpenMode mode = OpenMode::Update | OpenMode::Append | OpenMode::Binary The Append option makes sure that the Archive is not truncated on open </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a545eb320cc034dfeee10df545218ed71" name="a545eb320cc034dfeee10df545218ed71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545eb320cc034dfeee10df545218ed71">&#9670;&#160;</a></span>CommitResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_archive_1_1_i_archive_writer.html#a545eb320cc034dfeee10df545218ed71">Archive::IArchiveWriter::CommitResult</a> =  AZStd::expected&lt;void, ResultString&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the updated <a class="el" href="struct_archive_1_1_archive_header.html">ArchiveHeader</a> to the beginning of the stream and Table of Contents to end of the stream</p>
<p>If this call is successful, the archive TOC has been successfully written This function has been marked [[nodiscard]], to ensure the caller checks the return value </p><dl class="section return"><dt>Returns</dt><dd>A successful expectation if the TOC has been written </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a74dbf91069f5a05aea786a4ecc30101a" name="a74dbf91069f5a05aea786a4ecc30101a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74dbf91069f5a05aea786a4ecc30101a">&#9670;&#160;</a></span>AddFileToArchive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_archive_1_1_archive_add_file_result.html">ArchiveAddFileResult</a> Archive::IArchiveWriter::AddFileToArchive </td>
          <td>(</td>
          <td class="paramtype">AZ::IO::GenericStream &amp;&#160;</td>
          <td class="paramname"><em>inputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_archive_1_1_archive_writer_file_settings.html">ArchiveWriterFileSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>fileSettings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the content from the stream to the relative path </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputStream</td><td>stream class where data for the file is source from The entire stream is read into the memory and written into archive </td></tr>
    <tr><td class="paramname">fileSettings</td><td>settings used to configure the relative path to write to the archive for the given file data. It also allows users to configure the compression algorithm to use, and whether the AddFileToArchive logic fails if an existing file is being added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_archive_1_1_archive_add_file_result.html">ArchiveAddFileResult</a> containing the actual compression file path as saved to the Archive TOC, the compression algorithm used and an Archive File Token which can be used to remove the file if need be On failure, the result outcome contains any errors that have occurred </dd></dl>

<p>Implemented in <a class="el" href="class_archive_1_1_archive_writer.html#ad0138a47b15bd4faa24434dafc7f662d">Archive::ArchiveWriter</a>.</p>

</div>
</div>
<a id="af6f1de7195a336912905e6c6dd89774a" name="af6f1de7195a336912905e6c6dd89774a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f1de7195a336912905e6c6dd89774a">&#9670;&#160;</a></span>AddFileToArchive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_archive_1_1_archive_add_file_result.html">ArchiveAddFileResult</a> Archive::IArchiveWriter::AddFileToArchive </td>
          <td>(</td>
          <td class="paramtype">AZStd::span&lt; const AZStd::byte &gt;&#160;</td>
          <td class="paramname"><em>inputSpan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_archive_1_1_archive_writer_file_settings.html">ArchiveWriterFileSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>fileSettings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the span contents to add the file to the archive </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputSpan</td><td>view of data which will be written to the archive at the relative path supplied in the @fileSettings parameter </td></tr>
    <tr><td class="paramname">fileSettings</td><td>settings used to configure the relative path to write to the archive for the given file data. It also allows users to configure the compression algorithm to use, and whether the AddFileToArchive logic fails if an existing file is being added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_archive_1_1_archive_add_file_result.html">ArchiveAddFileResult</a> containing the actual compression file path as saved to the Archive TOC, the compression algorithm used and an Archive File Token which can be used to remove the file if need be On failure, the result outcome contains any errors that have occurred </dd></dl>

<p>Implemented in <a class="el" href="class_archive_1_1_archive_writer.html#ab969236650cc0c2831e599012a1a3316">Archive::ArchiveWriter</a>.</p>

</div>
</div>
<a id="a8829b197b966de03ef08ea5906fdde14" name="a8829b197b966de03ef08ea5906fdde14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8829b197b966de03ef08ea5906fdde14">&#9670;&#160;</a></span>ContainsFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Archive::IArchiveWriter::ContainsFile </td>
          <td>(</td>
          <td class="paramtype">AZ::IO::PathView&#160;</td>
          <td class="paramname"><em>relativePath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns if the archive contains a relative path </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relativePath</td><td>Relative path within archive to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the relative path is contained with the Archive equivalent to <code>return FindFile(relativePath) != InvalidArchiveFileToken;</code> </dd></dl>

<p>Implemented in <a class="el" href="class_archive_1_1_archive_writer.html#ab636fd529043f8416382818debe60b6b">Archive::ArchiveWriter</a>.</p>

</div>
</div>
<a id="a24b79ace32a190f69021800e869b6ab4" name="a24b79ace32a190f69021800e869b6ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b79ace32a190f69021800e869b6ab4">&#9670;&#160;</a></span>DumpArchiveMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Archive::IArchiveWriter::DumpArchiveMetadata </td>
          <td>(</td>
          <td class="paramtype">AZ::IO::GenericStream &amp;&#160;</td>
          <td class="paramname"><em>metadataStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_archive_1_1_archive_metadata_settings.html">ArchiveMetadataSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>metadataSettings</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dump metadata for the archive to the supplied generic stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metadataStream</td><td>archive file metadata will be written to the stream </td></tr>
    <tr><td class="paramname">metadataSettings</td><td>settings using which control the file metadata to write to the stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if metadata was successfully written </dd></dl>

<p>Implemented in <a class="el" href="class_archive_1_1_archive_writer.html#a332098059828b13fa824e52208bd3591">Archive::ArchiveWriter</a>.</p>

</div>
</div>
<a id="a97068ae798f8f697dfa2b35f26979acb" name="a97068ae798f8f697dfa2b35f26979acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97068ae798f8f697dfa2b35f26979acb">&#9670;&#160;</a></span>FindFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ArchiveFileToken Archive::IArchiveWriter::FindFile </td>
          <td>(</td>
          <td class="paramtype">AZ::IO::PathView&#160;</td>
          <td class="paramname"><em>relativePath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for a relative path within the archive </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relativePath</td><td>Relative path within archive to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A token that identifies the Archive file if it exist if the with the specified path doesn't exist InvalidArchiveFileToken is returned </dd></dl>

<p>Implemented in <a class="el" href="class_archive_1_1_archive_writer.html#a382b4cfc32ba8ad680020020e560e10c">Archive::ArchiveWriter</a>.</p>

</div>
</div>
<a id="ade8a56a30aef8781686a1ea1f8eae243" name="ade8a56a30aef8781686a1ea1f8eae243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8a56a30aef8781686a1ea1f8eae243">&#9670;&#160;</a></span>IsMounted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Archive::IArchiveWriter::IsMounted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if an open archive that is mounted. </p>

<p>Implemented in <a class="el" href="class_archive_1_1_archive_writer.html#adfa1d4be3a673e74f700050a1ce51b7c">Archive::ArchiveWriter</a>.</p>

</div>
</div>
<a id="ac4183bac9cb061da0261ca030e13f138" name="ac4183bac9cb061da0261ca030e13f138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4183bac9cb061da0261ca030e13f138">&#9670;&#160;</a></span>MountArchive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Archive::IArchiveWriter::MountArchive </td>
          <td>(</td>
          <td class="paramtype">AZ::IO::PathView&#160;</td>
          <td class="paramname"><em>archivePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opens the archive path and returns true if successful Will unmount any previously mounted archive </p>

<p>Implemented in <a class="el" href="class_archive_1_1_archive_writer.html#ab07dca2bbaad94db00a75411fe66f6ab">Archive::ArchiveWriter</a>.</p>

</div>
</div>
<a id="affddcc2f58bea7fc3f8e6f352d85cb68" name="affddcc2f58bea7fc3f8e6f352d85cb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affddcc2f58bea7fc3f8e6f352d85cb68">&#9670;&#160;</a></span>RemoveFileFromArchive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_archive_1_1_archive_remove_file_result.html">ArchiveRemoveFileResult</a> Archive::IArchiveWriter::RemoveFileFromArchive </td>
          <td>(</td>
          <td class="paramtype">ArchiveFileToken&#160;</td>
          <td class="paramname"><em>filePathToken</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the file from the archive using the ArchiveFileToken </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePathToken</td><td>Relative path within archive to search for NOTE: The entry in the table of contents is not actually removed The index where the file is located using the filePathToken is just added to the removed file indices set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ArchiveRemoveResult with metadata about how the deleted file was stored in the Archive </dd></dl>

<p>Implemented in <a class="el" href="class_archive_1_1_archive_writer.html#a51f8940a78014671629713cb417d7ba1">Archive::ArchiveWriter</a>.</p>

</div>
</div>
<a id="ae4c04b27aaf52d4251043b47b959a834" name="ae4c04b27aaf52d4251043b47b959a834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c04b27aaf52d4251043b47b959a834">&#9670;&#160;</a></span>RemoveFileFromArchive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_archive_1_1_archive_remove_file_result.html">ArchiveRemoveFileResult</a> Archive::IArchiveWriter::RemoveFileFromArchive </td>
          <td>(</td>
          <td class="paramtype">AZ::IO::PathView&#160;</td>
          <td class="paramname"><em>relativePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the file from the archive using a relative path name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relativePath</td><td>Relative path within archive to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ArchiveRemoveResult with metadata about how the deleted file was stored in the Archive </dd></dl>

<p>Implemented in <a class="el" href="class_archive_1_1_archive_writer.html#ae1fa8b640ac355eb3f23d62a9bca5638">Archive::ArchiveWriter</a>.</p>

</div>
</div>
<a id="a30f58c02ad20883eaa88bcc06a562b67" name="a30f58c02ad20883eaa88bcc06a562b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f58c02ad20883eaa88bcc06a562b67">&#9670;&#160;</a></span>UnmountArchive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Archive::IArchiveWriter::UnmountArchive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Closes the handle to the mounted archive stream This will invoke the Commit() function to write the archive TOC to the stream before closing the stream </p>

<p>Implemented in <a class="el" href="class_archive_1_1_archive_writer.html#af93204e2757e7382681f7183c5a4cb19">Archive::ArchiveWriter</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Gems/Archive/Code/Include/Archive/Tools/ArchiveWriterAPI.h</li>
<li>Gems/Archive/Code/Include/Archive/Tools/ArchiveWriterAPI.inl</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>Archive</b></li><li class="navelem"><a class="el" href="class_archive_1_1_i_archive_writer.html">IArchiveWriter</a></li>
    <li class="footer">Generated on Mon Oct 9 2023 13:48:58 for Open 3D Engine Archive Gem API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
