<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine AzCore API Reference: AZ::SliceComponent Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-placeholder-text"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine AzCore API Reference
   &#160;<span id="projectnumber">24.09</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_a_z_1_1_slice_component.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_a_z_1_1_slice_component-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AZ::SliceComponent Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;SliceComponent.h&gt;</code></p>

<p>Inherits <a class="el" href="class_a_z_1_1_component.html">AZ::Component</a>, and Data::AssetBus::MultiHandler.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_slice_component_1_1_ancestor.html">Ancestor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component_1_1_data_flags_per_entity.html">DataFlagsPerEntity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_slice_component_1_1_entity_info.html">EntityInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_slice_component_1_1_entity_restore_info.html">EntityRestoreInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_slice_component_1_1_instantiated_container.html">InstantiatedContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceInstance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a32f31afd765484f7b4a7b05ffb0666c0"><td class="memItemLeft" align="right" valign="top"><a id="a32f31afd765484f7b4a7b05ffb0666c0"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>InstantiateResult</b> { <b>Success</b>
, <b>MissingDependency</b>
, <b>CyclicalDependency</b>
 }</td></tr>
<tr class="separator:a32f31afd765484f7b4a7b05ffb0666c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2ec5cbdb5646bda4f2e80587ae6af0"><td class="memItemLeft" align="right" valign="top"><a id="a1b2ec5cbdb5646bda4f2e80587ae6af0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SliceInstancePtrSet</b> = <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set</a>&lt; <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceInstance</a> * &gt;</td></tr>
<tr class="separator:a1b2ec5cbdb5646bda4f2e80587ae6af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9048ac1830cc288d66d30adecc989f"><td class="memItemLeft" align="right" valign="top"><a id="a5c9048ac1830cc288d66d30adecc989f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SliceReferenceToInstancePtrs</b> = <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map</a>&lt; <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a> *, <a class="el" href="class_a_z_std_1_1unordered__set.html">SliceInstancePtrSet</a> &gt;</td></tr>
<tr class="separator:a5c9048ac1830cc288d66d30adecc989f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae124607e95798e21f0e0acd983892c25"><td class="memItemLeft" align="right" valign="top"><a id="ae124607e95798e21f0e0acd983892c25"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SliceAssetToSliceInstancePtrs</b> = <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map</a>&lt; <a class="el" href="class_a_z_1_1_data_1_1_asset.html">Data::Asset</a>&lt; <a class="el" href="class_a_z_1_1_slice_asset.html">SliceAsset</a> &gt;, <a class="el" href="class_a_z_std_1_1unordered__set.html">SliceInstancePtrSet</a> &gt;</td></tr>
<tr class="separator:ae124607e95798e21f0e0acd983892c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b6d833e17524bf84716b59bec0e294"><td class="memItemLeft" align="right" valign="top"><a id="a25b6d833e17524bf84716b59bec0e294"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SliceInstanceAddressSet</b> = <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set</a>&lt; <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a> &gt;</td></tr>
<tr class="separator:a25b6d833e17524bf84716b59bec0e294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57719bdf80cd9860610cf78a487bcdb"><td class="memItemLeft" align="right" valign="top"><a id="ab57719bdf80cd9860610cf78a487bcdb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EntityList</b> = <a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_1_1_entity.html">Entity</a> * &gt;</td></tr>
<tr class="separator:ab57719bdf80cd9860610cf78a487bcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39379e9fa3e5039cd03a6f8c53393734"><td class="memItemLeft" align="right" valign="top"><a id="a39379e9fa3e5039cd03a6f8c53393734"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EntityIdToEntityIdMap</b> = <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map</a>&lt; <a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a>, <a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> &gt;</td></tr>
<tr class="separator:a39379e9fa3e5039cd03a6f8c53393734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d8b0f524d377b3c2de25654016d626"><td class="memItemLeft" align="right" valign="top"><a id="a97d8b0f524d377b3c2de25654016d626"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SliceInstanceEntityIdRemapList</b> = <a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">EntityIdToEntityIdMap</a> &gt; &gt;</td></tr>
<tr class="separator:a97d8b0f524d377b3c2de25654016d626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0f11cb97be11f4d764a18efe656366"><td class="memItemLeft" align="right" valign="top"><a id="aca0f11cb97be11f4d764a18efe656366"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SliceInstanceToSliceInstanceMap</b> = <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map</a>&lt; <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a>, <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a> &gt;</td></tr>
<tr class="separator:aca0f11cb97be11f4d764a18efe656366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48191ce09c5231bc18f5a4e986635510"><td class="memItemLeft" align="right" valign="top"><a id="a48191ce09c5231bc18f5a4e986635510"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EntityIdSet</b> = <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set</a>&lt; <a class="el" href="class_a_z_1_1_entity_id.html">AZ::EntityId</a> &gt;</td></tr>
<tr class="separator:a48191ce09c5231bc18f5a4e986635510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577f868895376d019bce944c4e375d9d"><td class="memItemLeft" align="right" valign="top"><a id="a577f868895376d019bce944c4e375d9d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SliceInstanceId</b> = <a class="el" href="struct_a_z_1_1_uuid.html">AZ::Uuid</a></td></tr>
<tr class="separator:a577f868895376d019bce944c4e375d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ecba5b2f3fdacf65968aee859d4529"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ac4ecba5b2f3fdacf65968aee859d4529">PrefabReference</a> = <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a></td></tr>
<tr class="separator:ac4ecba5b2f3fdacf65968aee859d4529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cc1fd7058b7ca7abf6ee60ed55eee0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#af3cc1fd7058b7ca7abf6ee60ed55eee0">PrefabInstance</a> = <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceInstance</a></td></tr>
<tr class="separator:af3cc1fd7058b7ca7abf6ee60ed55eee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ad4025606aaff58495b977dc1b9820"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ac7ad4025606aaff58495b977dc1b9820">PrefabInstanceAddress</a> = <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a></td></tr>
<tr class="separator:ac7ad4025606aaff58495b977dc1b9820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db04767ba0b88957f92de791ce3e372"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a6db04767ba0b88957f92de791ce3e372">PrefabInstanceId</a> = <a class="el" href="struct_a_z_1_1_uuid.html">SliceInstanceId</a></td></tr>
<tr class="separator:a6db04767ba0b88957f92de791ce3e372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efc6a607a52887af47897377dbbc4ca"><td class="memItemLeft" align="right" valign="top"><a id="a6efc6a607a52887af47897377dbbc4ca"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EntityDataFlagsMap</b> = <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map</a>&lt; <a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a>, <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">DataPatch::FlagsMap</a> &gt;</td></tr>
<tr class="separator:a6efc6a607a52887af47897377dbbc4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912d1d28c414f269aaf9ffdfed8d31d7"><td class="memItemLeft" align="right" valign="top"><a id="a912d1d28c414f269aaf9ffdfed8d31d7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EntityAncestorList</b> = <a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="struct_a_z_1_1_slice_component_1_1_ancestor.html">Ancestor</a> &gt;</td></tr>
<tr class="separator:a912d1d28c414f269aaf9ffdfed8d31d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212b47ccabbec2d56a5887fadebcae90"><td class="memItemLeft" align="right" valign="top"><a id="a212b47ccabbec2d56a5887fadebcae90"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EntityRestoreInfoList</b> = <a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_1_1_entity_id.html">AZ::EntityId</a>, <a class="el" href="struct_a_z_1_1_slice_component_1_1_entity_restore_info.html">AZ::SliceComponent::EntityRestoreInfo</a> &gt; &gt;</td></tr>
<tr class="separator:a212b47ccabbec2d56a5887fadebcae90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74b7c69cdad517c59ff5f9b77dc307e"><td class="memItemLeft" align="right" valign="top"><a id="ac74b7c69cdad517c59ff5f9b77dc307e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SliceAssetToSliceInstances</b> = <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map</a>&lt; <a class="el" href="class_a_z_1_1_data_1_1_asset.html">Data::Asset</a>&lt; <a class="el" href="class_a_z_1_1_slice_asset.html">SliceAsset</a> &gt;, <a class="el" href="class_a_z_std_1_1unordered__set.html">SliceReference::SliceInstances</a> &gt;</td></tr>
<tr class="separator:ac74b7c69cdad517c59ff5f9b77dc307e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713ae4473f9fc52a03f248d4de32b443"><td class="memItemLeft" align="right" valign="top"><a id="a713ae4473f9fc52a03f248d4de32b443"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SliceList</b> = <a class="el" href="class_a_z_std_1_1list.html">AZStd::list</a>&lt; <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a> &gt;</td></tr>
<tr class="separator:a713ae4473f9fc52a03f248d4de32b443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26ee0e3bf4217518f0f92171f28a7ee"><td class="memItemLeft" align="right" valign="top"><a id="ac26ee0e3bf4217518f0f92171f28a7ee"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EntityInfoMap</b> = <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map</a>&lt; <a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a>, <a class="el" href="struct_a_z_1_1_slice_component_1_1_entity_info.html">EntityInfo</a> &gt;</td></tr>
<tr class="separator:ac26ee0e3bf4217518f0f92171f28a7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ffdf30f0ddc770d64d40bd75b5b229"><td class="memItemLeft" align="right" valign="top"><a id="a52ffdf30f0ddc770d64d40bd75b5b229"></a>
typedef <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set</a>&lt; <a class="el" href="struct_a_z_1_1_data_1_1_asset_id.html">Data::AssetId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AssetIdSet</b></td></tr>
<tr class="separator:a52ffdf30f0ddc770d64d40bd75b5b229"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3cd1bcd375c715c74e7d3d7a696c0281"><td class="memItemLeft" align="right" valign="top"><a id="a3cd1bcd375c715c74e7d3d7a696c0281"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_COMPONENT</b> (<a class="el" href="class_a_z_1_1_slice_component.html">SliceComponent</a>, &quot;{AFD304E4-1773-47C8-855A-8B622398934F}&quot;, Data::AssetEvents)</td></tr>
<tr class="separator:a3cd1bcd375c715c74e7d3d7a696c0281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9109634e7c56e388a581ff7461de574"><td class="memItemLeft" align="right" valign="top"><a id="ad9109634e7c56e388a581ff7461de574"></a>
<a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetSerializeContext</b> () const</td></tr>
<tr class="separator:ad9109634e7c56e388a581ff7461de574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93cf0604a9a5a09a194e6d350a635bd"><td class="memItemLeft" align="right" valign="top"><a id="ac93cf0604a9a5a09a194e6d350a635bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetSerializeContext</b> (<a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> *context)</td></tr>
<tr class="separator:ac93cf0604a9a5a09a194e6d350a635bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804e862b85ebdf5da4fd77f477a61fd8"><td class="memItemLeft" align="right" valign="top"><a id="a804e862b85ebdf5da4fd77f477a61fd8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a804e862b85ebdf5da4fd77f477a61fd8">ListenForAssetChanges</a> ()</td></tr>
<tr class="memdesc:a804e862b85ebdf5da4fd77f477a61fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to asset bus for dependencies. <br /></td></tr>
<tr class="separator:a804e862b85ebdf5da4fd77f477a61fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a16da3f1c28c020f03e2d359ab6ea8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a93a16da3f1c28c020f03e2d359ab6ea8">ListenForDependentAssetChanges</a> ()</td></tr>
<tr class="separator:a93a16da3f1c28c020f03e2d359ab6ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e979a7c45fab44d6539d847e487447e"><td class="memItemLeft" align="right" valign="top"><a id="a5e979a7c45fab44d6539d847e487447e"></a>
const <a class="el" href="class_a_z_std_1_1vector.html">EntityList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a5e979a7c45fab44d6539d847e487447e">GetNewEntities</a> () const</td></tr>
<tr class="memdesc:a5e979a7c45fab44d6539d847e487447e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns list of the entities that are "new" for the current slice (not based on an existing slice) <br /></td></tr>
<tr class="separator:a5e979a7c45fab44d6539d847e487447e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcda77f547238eb7970ea5060e805344"><td class="memItemLeft" align="right" valign="top"><a id="abcda77f547238eb7970ea5060e805344"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#abcda77f547238eb7970ea5060e805344">IsNewEntity</a> (<a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> entityId) const</td></tr>
<tr class="memdesc:abcda77f547238eb7970ea5060e805344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true for entities that are "new" entities in this slice (entities not based on another slice) <br /></td></tr>
<tr class="separator:abcda77f547238eb7970ea5060e805344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e7fb4cd7a81a2beb1b8154cf751049"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#aa7e7fb4cd7a81a2beb1b8154cf751049">GetEntities</a> (<a class="el" href="class_a_z_std_1_1vector.html">EntityList</a> &amp;entities)</td></tr>
<tr class="separator:aa7e7fb4cd7a81a2beb1b8154cf751049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc68850172fab88538b1fc3f5ec23a1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#acc68850172fab88538b1fc3f5ec23a1c">EraseEntities</a> (const <a class="el" href="class_a_z_std_1_1vector.html">EntityList</a> &amp;entities)</td></tr>
<tr class="separator:acc68850172fab88538b1fc3f5ec23a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be5946c7cadab7be358218d0d589ed1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a2be5946c7cadab7be358218d0d589ed1">AddEntities</a> (const <a class="el" href="class_a_z_std_1_1vector.html">EntityList</a> &amp;entities)</td></tr>
<tr class="separator:a2be5946c7cadab7be358218d0d589ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fc08a3f53004893af440428634c2c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ad5fc08a3f53004893af440428634c2c3">ReplaceEntities</a> (const <a class="el" href="class_a_z_std_1_1vector.html">EntityList</a> &amp;entities)</td></tr>
<tr class="separator:ad5fc08a3f53004893af440428634c2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9ed78bc27fcacf717316d8257112ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#aae9ed78bc27fcacf717316d8257112ff">AddSliceInstances</a> (<a class="el" href="class_a_z_std_1_1unordered__map.html">SliceAssetToSliceInstancePtrs</a> &amp;sliceInstances, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set</a>&lt; const <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceInstance</a> * &gt; &amp;instancesOut)</td></tr>
<tr class="separator:aae9ed78bc27fcacf717316d8257112ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c7354ba01155a88f1d7379c305e987"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a16c7354ba01155a88f1d7379c305e987">GetEntityIds</a> (<a class="el" href="class_a_z_std_1_1unordered__set.html">EntityIdSet</a> &amp;entities)</td></tr>
<tr class="separator:a16c7354ba01155a88f1d7379c305e987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c9d0d41e893520fffeee88b2c5f020"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a86c9d0d41e893520fffeee88b2c5f020">GetInstantiatedEntityCount</a> () const</td></tr>
<tr class="separator:a86c9d0d41e893520fffeee88b2c5f020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc203accc30b73685be7838389f5a7bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#afc203accc30b73685be7838389f5a7bb">GetMetadataEntityIds</a> (<a class="el" href="class_a_z_std_1_1unordered__set.html">EntityIdSet</a> &amp;entities)</td></tr>
<tr class="separator:afc203accc30b73685be7838389f5a7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf34a310e5e8a770ff9beb7f2f3572c1"><td class="memItemLeft" align="right" valign="top"><a id="acf34a310e5e8a770ff9beb7f2f3572c1"></a>
const <a class="el" href="class_a_z_std_1_1list.html">SliceList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#acf34a310e5e8a770ff9beb7f2f3572c1">GetSlices</a> () const</td></tr>
<tr class="memdesc:acf34a310e5e8a770ff9beb7f2f3572c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns list of all slices and their instantiated entities (for this slice component) <br /></td></tr>
<tr class="separator:acf34a310e5e8a770ff9beb7f2f3572c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40357e3b9a3d126fde1d5a5774dfdcd"><td class="memItemLeft" align="right" valign="top"><a id="ac40357e3b9a3d126fde1d5a5774dfdcd"></a>
<a class="el" href="class_a_z_std_1_1list.html">SliceList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ac40357e3b9a3d126fde1d5a5774dfdcd">GetSlices</a> ()</td></tr>
<tr class="memdesc:ac40357e3b9a3d126fde1d5a5774dfdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns list of all slices and their instantiated entities (for this slice component) <br /></td></tr>
<tr class="separator:ac40357e3b9a3d126fde1d5a5774dfdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2639e499341293408048b4309a7447e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_z_std_1_1list.html">SliceList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ae2639e499341293408048b4309a7447e">GetInvalidSlices</a> () const</td></tr>
<tr class="separator:ae2639e499341293408048b4309a7447e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1798445a7ac7b1202d6ca278d260517b"><td class="memItemLeft" align="right" valign="top"><a id="a1798445a7ac7b1202d6ca278d260517b"></a>
<a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetSlice</b> (const <a class="el" href="class_a_z_1_1_data_1_1_asset.html">Data::Asset</a>&lt; <a class="el" href="class_a_z_1_1_slice_asset.html">SliceAsset</a> &gt; &amp;sliceAsset)</td></tr>
<tr class="separator:a1798445a7ac7b1202d6ca278d260517b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc9235d63092bef7e4358f45708dd29"><td class="memItemLeft" align="right" valign="top"><a id="aebc9235d63092bef7e4358f45708dd29"></a>
<a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetSlice</b> (const <a class="el" href="struct_a_z_1_1_data_1_1_asset_id.html">Data::AssetId</a> &amp;sliceAssetId)</td></tr>
<tr class="separator:aebc9235d63092bef7e4358f45708dd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcfb0678830e941c6f879a1ea1a0e17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a5bcfb0678830e941c6f879a1ea1a0e17">AddSlice</a> (const <a class="el" href="class_a_z_1_1_data_1_1_asset.html">Data::Asset</a>&lt; <a class="el" href="class_a_z_1_1_slice_asset.html">SliceAsset</a> &gt; &amp;sliceAsset, const <a class="el" href="struct_a_z_1_1_id_utils_1_1_remapper.html">AZ::IdUtils::Remapper</a>&lt; <a class="el" href="class_a_z_1_1_entity_id.html">AZ::EntityId</a> &gt;::IdMapper &amp;customMapper=nullptr, <a class="el" href="struct_a_z_1_1_uuid.html">SliceInstanceId</a> sliceInstanceId=SliceInstanceId::CreateRandom())</td></tr>
<tr class="separator:a5bcfb0678830e941c6f879a1ea1a0e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af889b7bb1b12fdd18e09739f2da05e62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#af889b7bb1b12fdd18e09739f2da05e62">AddSliceUsingExistingEntities</a> (const <a class="el" href="class_a_z_1_1_data_1_1_asset.html">Data::Asset</a>&lt; <a class="el" href="class_a_z_1_1_slice_asset.html">SliceAsset</a> &gt; &amp;sliceAsset, const <a class="el" href="class_a_z_std_1_1unordered__map.html">AZ::SliceComponent::EntityIdToEntityIdMap</a> &amp;assetToLiveMap, <a class="el" href="struct_a_z_1_1_uuid.html">SliceInstanceId</a> sliceInstanceId=SliceInstanceId::CreateRandom())</td></tr>
<tr class="separator:af889b7bb1b12fdd18e09739f2da05e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92c434038ef9430fb1e6d4eac63c09c"><td class="memItemLeft" align="right" valign="top"><a id="ab92c434038ef9430fb1e6d4eac63c09c"></a>
<a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ab92c434038ef9430fb1e6d4eac63c09c">AddSlice</a> (<a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a> &amp;sliceReference)</td></tr>
<tr class="memdesc:ab92c434038ef9430fb1e6d4eac63c09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a slice reference (moves it) along with its instance information. <br /></td></tr>
<tr class="separator:ab92c434038ef9430fb1e6d4eac63c09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c19a374a916709bed2b910ab6af0b0"><td class="memItemLeft" align="right" valign="top"><a id="ab4c19a374a916709bed2b910ab6af0b0"></a>
<a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ab4c19a374a916709bed2b910ab6af0b0">AddSliceInstance</a> (<a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a> *sliceReference, <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceInstance</a> *sliceInstance)</td></tr>
<tr class="memdesc:ab4c19a374a916709bed2b910ab6af0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a slice (moves it) from another already generated reference/instance pair. <br /></td></tr>
<tr class="separator:ab4c19a374a916709bed2b910ab6af0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6969074fc96a43cb289454f6f4e6874d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a6969074fc96a43cb289454f6f4e6874d">CloneAndAddSubSliceInstance</a> (const <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceInstance</a> *sourceSliceInstance, const <a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">AZ::SliceComponent::SliceInstanceAddress</a> &gt; &amp;sourceSubSliceInstanceAncestry, const <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">AZ::SliceComponent::SliceInstanceAddress</a> &amp;sourceSubSliceInstanceAddress, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZ::SliceComponent::EntityIdToEntityIdMap</a> *out_sourceToCloneEntityIdMap=nullptr, bool preserveIds=false)</td></tr>
<tr class="separator:a6969074fc96a43cb289454f6f4e6874d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf21d32c8ff66a120f59688d17b6ce9"><td class="memItemLeft" align="right" valign="top"><a id="aabf21d32c8ff66a120f59688d17b6ce9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#aabf21d32c8ff66a120f59688d17b6ce9">RemoveSlice</a> (const <a class="el" href="class_a_z_1_1_data_1_1_asset.html">Data::Asset</a>&lt; <a class="el" href="class_a_z_1_1_slice_asset.html">SliceAsset</a> &gt; &amp;sliceAsset)</td></tr>
<tr class="memdesc:aabf21d32c8ff66a120f59688d17b6ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an entire slice asset reference and all its instances. <br /></td></tr>
<tr class="separator:aabf21d32c8ff66a120f59688d17b6ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ee683f3204ca6eeb14fde17bdb0b67"><td class="memItemLeft" align="right" valign="top"><a id="a48ee683f3204ca6eeb14fde17bdb0b67"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveSlice</b> (const <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a> *slice)</td></tr>
<tr class="separator:a48ee683f3204ca6eeb14fde17bdb0b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190282472b59209e60c971702f6673cb"><td class="memItemLeft" align="right" valign="top"><a id="a190282472b59209e60c971702f6673cb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a190282472b59209e60c971702f6673cb">RemoveSliceInstance</a> (<a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceInstance</a> *instance)</td></tr>
<tr class="memdesc:a190282472b59209e60c971702f6673cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the slice instance, if this is last instance the <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a> will be removed too. <br /></td></tr>
<tr class="separator:a190282472b59209e60c971702f6673cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d0ca87cfaf00740c76bad6ac75f2d1"><td class="memItemLeft" align="right" valign="top"><a id="a01d0ca87cfaf00740c76bad6ac75f2d1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveSliceInstance</b> (<a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a> sliceAddress)</td></tr>
<tr class="separator:a01d0ca87cfaf00740c76bad6ac75f2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d47f99b2301c039bcfb77ee8c65943"><td class="memItemLeft" align="right" valign="top"><a id="a11d47f99b2301c039bcfb77ee8c65943"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a11d47f99b2301c039bcfb77ee8c65943">AddEntity</a> (<a class="el" href="class_a_z_1_1_entity.html">Entity</a> *entity)</td></tr>
<tr class="memdesc:a11d47f99b2301c039bcfb77ee8c65943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds entity to the current slice and takes ownership over it (you should not manage/delete it) <br /></td></tr>
<tr class="separator:a11d47f99b2301c039bcfb77ee8c65943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32744b0c3b83e211d95282a77eea95a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_entity.html">AZ::Entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ac32744b0c3b83e211d95282a77eea95a">FindEntity</a> (<a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> entityId)</td></tr>
<tr class="separator:ac32744b0c3b83e211d95282a77eea95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a223a7b689729dc6b1dae64eb026e48"><td class="memItemLeft" align="right" valign="top"><a id="a4a223a7b689729dc6b1dae64eb026e48"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveEntity</b> (<a class="el" href="class_a_z_1_1_entity.html">Entity</a> *entity, bool isDeleteEntity=true, bool isRemoveEmptyInstance=true)</td></tr>
<tr class="separator:a4a223a7b689729dc6b1dae64eb026e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf151af5ca665741ab65f495d56dde0f"><td class="memItemLeft" align="right" valign="top"><a id="aaf151af5ca665741ab65f495d56dde0f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#aaf151af5ca665741ab65f495d56dde0f">RemoveEntity</a> (<a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> entityId, bool isDeleteEntity=true, bool isRemoveEmptyInstance=true)</td></tr>
<tr class="memdesc:aaf151af5ca665741ab65f495d56dde0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as RemoveEntity but by using entityId. <br /></td></tr>
<tr class="separator:aaf151af5ca665741ab65f495d56dde0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c5785d02de87725b652924df2c0d61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a18c5785d02de87725b652924df2c0d61">RemoveMetaDataEntity</a> (<a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> metaDataEntityId)</td></tr>
<tr class="separator:a18c5785d02de87725b652924df2c0d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad107ec8caa86921079e48662d5850e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ad107ec8caa86921079e48662d5850e95">RemoveAllEntities</a> (bool deleteEntities=true, bool removeEmptyInstances=true)</td></tr>
<tr class="separator:ad107ec8caa86921079e48662d5850e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27963cf21f55f3899e471b44fafde4fa"><td class="memItemLeft" align="right" valign="top"><a id="a27963cf21f55f3899e471b44fafde4fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveLooseEntity</b> (<a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> entityId)</td></tr>
<tr class="separator:a27963cf21f55f3899e471b44fafde4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a0541646db6b75c86259364c91d953"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a29a0541646db6b75c86259364c91d953">FindSlice</a> (<a class="el" href="class_a_z_1_1_entity.html">Entity</a> *entity)</td></tr>
<tr class="separator:a29a0541646db6b75c86259364c91d953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac387cd54dbc219232d04aa524daaad80"><td class="memItemLeft" align="right" valign="top"><a id="ac387cd54dbc219232d04aa524daaad80"></a>
<a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FindSlice</b> (<a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> entityId)</td></tr>
<tr class="separator:ac387cd54dbc219232d04aa524daaad80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633dcbd3d8436948f9929887c11ad214"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a633dcbd3d8436948f9929887c11ad214">FlattenSlice</a> (<a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a> *toFlatten, const <a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> &amp;toFlattenRoot)</td></tr>
<tr class="separator:a633dcbd3d8436948f9929887c11ad214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ed7dc8e451e53e28001785e4fb0774"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a79ed7dc8e451e53e28001785e4fb0774">GetEntityRestoreInfo</a> (const <a class="el" href="class_a_z_1_1_entity_id.html">AZ::EntityId</a> entityId, <a class="el" href="struct_a_z_1_1_slice_component_1_1_entity_restore_info.html">EntityRestoreInfo</a> &amp;info)</td></tr>
<tr class="separator:a79ed7dc8e451e53e28001785e4fb0774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83cbe8a9d97cf1e7328c3e23b308805"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ac83cbe8a9d97cf1e7328c3e23b308805">RestoreEntity</a> (<a class="el" href="class_a_z_1_1_entity.html">AZ::Entity</a> *entity, const <a class="el" href="struct_a_z_1_1_slice_component_1_1_entity_restore_info.html">EntityRestoreInfo</a> &amp;restoreInfo, bool isEntityAdd=false)</td></tr>
<tr class="separator:ac83cbe8a9d97cf1e7328c3e23b308805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc79dcd09acbbd88e819b5ce3ca05527"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#adc79dcd09acbbd88e819b5ce3ca05527">SetMyAsset</a> (<a class="el" href="class_a_z_1_1_slice_asset.html">SliceAsset</a> *asset)</td></tr>
<tr class="separator:adc79dcd09acbbd88e819b5ce3ca05527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64725dca76f3592b9ccc48e0330eccbc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_z_1_1_slice_asset.html">SliceAsset</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a64725dca76f3592b9ccc48e0330eccbc">GetMyAsset</a> () const</td></tr>
<tr class="separator:a64725dca76f3592b9ccc48e0330eccbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ddcf6cdebadb48988df751313f3a83"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">DataPatch::FlagsMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a25ddcf6cdebadb48988df751313f3a83">GetEntityDataFlags</a> (<a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> entityId) const</td></tr>
<tr class="separator:a25ddcf6cdebadb48988df751313f3a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc21f7771499bd33ffbc96c07be36c60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#afc21f7771499bd33ffbc96c07be36c60">SetEntityDataFlags</a> (<a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> entityId, const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">DataPatch::FlagsMap</a> &amp;dataFlags)</td></tr>
<tr class="separator:afc21f7771499bd33ffbc96c07be36c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4f4a0e96b0e183570aeca5ee0121c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">DataPatch::Flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a1d4f4a0e96b0e183570aeca5ee0121c8">GetEffectOfEntityDataFlagsAtAddress</a> (<a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a>, const DataPatch::AddressType &amp;dataAddress) const</td></tr>
<tr class="separator:a1d4f4a0e96b0e183570aeca5ee0121c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9875418980e2f9260dfa003ad387502e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">DataPatch::Flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a9875418980e2f9260dfa003ad387502e">GetEntityDataFlagsAtAddress</a> (<a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> entityId, const DataPatch::AddressType &amp;dataAddress) const</td></tr>
<tr class="separator:a9875418980e2f9260dfa003ad387502e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9b6d22b4887a5ed93fd8f80dcaea27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a0e9b6d22b4887a5ed93fd8f80dcaea27">SetEntityDataFlagsAtAddress</a> (<a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> entityId, const DataPatch::AddressType &amp;dataAddress, <a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">DataPatch::Flags</a> flags)</td></tr>
<tr class="separator:a0e9b6d22b4887a5ed93fd8f80dcaea27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb9830079b81bdabbadc68b07cc8f68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#adcb9830079b81bdabbadc68b07cc8f68">GetInstanceMetadataEntities</a> (<a class="el" href="class_a_z_std_1_1vector.html">EntityList</a> &amp;outMetadataEntities)</td></tr>
<tr class="separator:adcb9830079b81bdabbadc68b07cc8f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05327ff657b0e163c4a1dc070e138bd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a05327ff657b0e163c4a1dc070e138bd6">GetAllInstanceMetadataEntities</a> (<a class="el" href="class_a_z_std_1_1vector.html">EntityList</a> &amp;outMetadataEntities)</td></tr>
<tr class="separator:a05327ff657b0e163c4a1dc070e138bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593cf8d1a85ad503eaa73ae2c93d2f3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a593cf8d1a85ad503eaa73ae2c93d2f3b">GetAllMetadataEntities</a> (<a class="el" href="class_a_z_std_1_1vector.html">EntityList</a> &amp;outMetadataEntities)</td></tr>
<tr class="separator:a593cf8d1a85ad503eaa73ae2c93d2f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37aeb2cd7cffb594715953d4d35af10b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_entity.html">AZ::Entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a37aeb2cd7cffb594715953d4d35af10b">GetMetadataEntity</a> ()</td></tr>
<tr class="separator:a37aeb2cd7cffb594715953d4d35af10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fd59c4a4880807ab7f8dafdf3d22f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a13fd59c4a4880807ab7f8dafdf3d22f6">GetReferencedSliceAssets</a> (<a class="el" href="class_a_z_std_1_1unordered__set.html">AssetIdSet</a> &amp;idSet, bool recurse=true)</td></tr>
<tr class="separator:a13fd59c4a4880807ab7f8dafdf3d22f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0a1849ea23de1bd033335dc2de5680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_slice_component.html">SliceComponent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a2c0a1849ea23de1bd033335dc2de5680">Clone</a> (<a class="el" href="class_a_z_1_1_serialize_context.html">AZ::SerializeContext</a> &amp;serializeContext, <a class="el" href="class_a_z_std_1_1unordered__map.html">SliceInstanceToSliceInstanceMap</a> *sourceToCloneSliceInstanceMap=nullptr) const</td></tr>
<tr class="separator:a2c0a1849ea23de1bd033335dc2de5680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47889150460317615611ac3a3755daaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a47889150460317615611ac3a3755daaf">AllowPartialInstantiation</a> (bool allow)</td></tr>
<tr class="separator:a47889150460317615611ac3a3755daaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99620a7e88f364ced47a8aad7f994f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ac99620a7e88f364ced47a8aad7f994f6">IsAllowPartialInstantiation</a> () const</td></tr>
<tr class="separator:ac99620a7e88f364ced47a8aad7f994f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9c219059195af65e9fde74cc4caa3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a5d9c219059195af65e9fde74cc4caa3d">IsDynamic</a> () const</td></tr>
<tr class="separator:a5d9c219059195af65e9fde74cc4caa3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2299e54a002df6a073af6d3563578b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ac2299e54a002df6a073af6d3563578b1">SetIsDynamic</a> (bool isDynamic)</td></tr>
<tr class="separator:ac2299e54a002df6a073af6d3563578b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51967daaa453bd0cacce1955ba45ae36"><td class="memItemLeft" align="right" valign="top">InstantiateResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a51967daaa453bd0cacce1955ba45ae36">Instantiate</a> (<a class="el" href="class_a_z_1_1_serialize_context.html">AZ::SerializeContext</a> *serializeContext=nullptr, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map</a>&lt; <a class="el" href="class_a_z_std_1_1basic__string.html">AZStd::string</a>, <a class="el" href="class_a_z_std_1_1basic__string.html">AZStd::string</a> &gt; *relativeToAbsoluteSlicePaths=nullptr)</td></tr>
<tr class="separator:a51967daaa453bd0cacce1955ba45ae36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b77ba8bb9a1daa69ae5aaae984ffb00"><td class="memItemLeft" align="right" valign="top"><a id="a1b77ba8bb9a1daa69ae5aaae984ffb00"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsInstantiated</b> () const</td></tr>
<tr class="separator:a1b77ba8bb9a1daa69ae5aaae984ffb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade845507fcb5456d9b8480eb051e9911"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ade845507fcb5456d9b8480eb051e9911">GenerateNewEntityIds</a> (<a class="el" href="class_a_z_std_1_1unordered__map.html">EntityIdToEntityIdMap</a> *previousToNewIdMap=nullptr)</td></tr>
<tr class="separator:ade845507fcb5456d9b8480eb051e9911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f4215322115fea8f3a4327f368f1ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#af3f4215322115fea8f3a4327f368f1ec">InitMetadata</a> ()</td></tr>
<tr class="separator:af3f4215322115fea8f3a4327f368f1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efce7ae47d09449c8cf08fc50b3e0fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a1efce7ae47d09449c8cf08fc50b3e0fa">RemoveAndCacheInstances</a> (const <a class="el" href="class_a_z_std_1_1unordered__map.html">SliceReferenceToInstancePtrs</a> &amp;instancesToRemove)</td></tr>
<tr class="separator:a1efce7ae47d09449c8cf08fc50b3e0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f5a3747bf87022c9e88958e597d77c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a19f5a3747bf87022c9e88958e597d77c">RestoreCachedInstances</a> ()</td></tr>
<tr class="separator:a19f5a3747bf87022c9e88958e597d77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0e2760ebb81b55e78fb4b18625d58a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_z_1_1_slice_component_1_1_data_flags_per_entity.html">DataFlagsPerEntity</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a4e0e2760ebb81b55e78fb4b18625d58a">GetDataFlagsForInstances</a> () const</td></tr>
<tr class="separator:a4e0e2760ebb81b55e78fb4b18625d58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_a_z_1_1_component"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_a_z_1_1_component')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_a_z_1_1_component.html">AZ::Component</a></td></tr>
<tr class="memitem:a8d87e0f96b89cc385de6e3acc51ce2ac inherit pub_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#a8d87e0f96b89cc385de6e3acc51ce2ac">AZ_TYPE_INFO_WITH_NAME_DECL</a> (<a class="el" href="class_a_z_1_1_component.html">Component</a>)</td></tr>
<tr class="separator:a8d87e0f96b89cc385de6e3acc51ce2ac inherit pub_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53de7857ca64197cc5506cad23e1ba17 inherit pub_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top"><a id="a53de7857ca64197cc5506cad23e1ba17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_RTTI_NO_TYPE_INFO_DECL</b> ()</td></tr>
<tr class="separator:a53de7857ca64197cc5506cad23e1ba17 inherit pub_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb510965b854b25d3f1116bfa31414b inherit pub_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top">AZ_CLASS_ALLOCATOR_DECL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#a5eb510965b854b25d3f1116bfa31414b">Component</a> ()</td></tr>
<tr class="separator:a5eb510965b854b25d3f1116bfa31414b inherit pub_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faccc3bb9e65300b1c4740135dc4775 inherit pub_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#a5faccc3bb9e65300b1c4740135dc4775">~Component</a> ()</td></tr>
<tr class="separator:a5faccc3bb9e65300b1c4740135dc4775 inherit pub_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411ea9020c4c082961fb416365bc83a7 inherit pub_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_entity.html">Entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#a411ea9020c4c082961fb416365bc83a7">GetEntity</a> () const</td></tr>
<tr class="separator:a411ea9020c4c082961fb416365bc83a7 inherit pub_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb18df65172811f74e6279c92760f45 inherit pub_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#a3eb18df65172811f74e6279c92760f45">GetEntityId</a> () const</td></tr>
<tr class="separator:a3eb18df65172811f74e6279c92760f45 inherit pub_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cad9d7927d8f8eed15e281389af7f45 inherit pub_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_named_entity_id.html">NamedEntityId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#a3cad9d7927d8f8eed15e281389af7f45">GetNamedEntityId</a> () const</td></tr>
<tr class="separator:a3cad9d7927d8f8eed15e281389af7f45 inherit pub_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cabfdba04540b717cebd833cb4fa25 inherit pub_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top">ComponentId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#ab1cabfdba04540b717cebd833cb4fa25">GetId</a> () const</td></tr>
<tr class="separator:ab1cabfdba04540b717cebd833cb4fa25 inherit pub_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3e151c02e98d4c66635f577c688d31 inherit pub_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_a_z.html#a5c1a2bfc05f03fd482d2fb55fbe82051">TypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#adf3e151c02e98d4c66635f577c688d31">GetUnderlyingComponentType</a> () const</td></tr>
<tr class="separator:adf3e151c02e98d4c66635f577c688d31 inherit pub_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9117e6204f3e7cb22b58b64e1d7bab04 inherit pub_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#a9117e6204f3e7cb22b58b64e1d7bab04">SetId</a> (const ComponentId &amp;id)</td></tr>
<tr class="separator:a9117e6204f3e7cb22b58b64e1d7bab04 inherit pub_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d2f8c22d47dbfbf1c21dacbbf59512 inherit pub_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#a77d2f8c22d47dbfbf1c21dacbbf59512">SetSerializedIdentifier</a> (<a class="el" href="class_a_z_std_1_1basic__string.html">AZStd::string</a> serializedIdentifer)</td></tr>
<tr class="separator:a77d2f8c22d47dbfbf1c21dacbbf59512 inherit pub_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97009159e2e5ac07a3db3ea522921ebd inherit pub_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1basic__string.html">AZStd::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#a97009159e2e5ac07a3db3ea522921ebd">GetSerializedIdentifier</a> () const</td></tr>
<tr class="separator:a97009159e2e5ac07a3db3ea522921ebd inherit pub_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6ed45650fa60bdd6997051cb4068f7 inherit pub_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_1_1_outcome.html">ComponentValidationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#a3d6ed45650fa60bdd6997051cb4068f7">ValidateComponentRequirements</a> (const <a class="el" href="class_a_z_std_1_1vector.html">ImmutableEntityVector</a> &amp;, const <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set</a>&lt; <a class="el" href="class_a_z_1_1_crc32.html">AZ::Crc32</a> &gt; &amp;) const</td></tr>
<tr class="separator:a3d6ed45650fa60bdd6997051cb4068f7 inherit pub_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bfd4b5e4f27cae64ea0c510e1085f5 inherit pub_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#a80bfd4b5e4f27cae64ea0c510e1085f5">SetConfiguration</a> (const <a class="el" href="class_a_z_1_1_component_config.html">AZ::ComponentConfig</a> &amp;config)</td></tr>
<tr class="separator:a80bfd4b5e4f27cae64ea0c510e1085f5 inherit pub_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae737d3f9415acfa4a6d06a31c71cb7bf inherit pub_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#ae737d3f9415acfa4a6d06a31c71cb7bf">GetConfiguration</a> (<a class="el" href="class_a_z_1_1_component_config.html">AZ::ComponentConfig</a> &amp;outConfig) const</td></tr>
<tr class="separator:ae737d3f9415acfa4a6d06a31c71cb7bf inherit pub_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a90fbb6cedc03979a90d57f1bd7343f4e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a90fbb6cedc03979a90d57f1bd7343f4e">GetMappingBetweenSubsliceAndSourceInstanceEntityIds</a> (const <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceComponent::SliceInstance</a> *sourceSliceInstance, const <a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">AZ::SliceComponent::SliceInstanceAddress</a> &gt; &amp;sourceSubsliceInstanceAncestry, const <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">AZ::SliceComponent::SliceInstanceAddress</a> &amp;sourceSubsliceInstanceAddress, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZ::SliceComponent::EntityIdToEntityIdMap</a> &amp;subsliceToLiveMappingResult, bool flipMapping=false)</td></tr>
<tr class="separator:a90fbb6cedc03979a90d57f1bd7343f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a05a7fb6c06794451fdb1a056d353768b"><td class="memItemLeft" align="right" valign="top"><a id="a05a7fb6c06794451fdb1a056d353768b"></a>
typedef <a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="struct_a_z_1_1_data_1_1_asset_id.html">AZ::Data::AssetId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AssetIdVector</b></td></tr>
<tr class="separator:a05a7fb6c06794451fdb1a056d353768b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af2dcdca9466721dd481d8e498fb2aa99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#af2dcdca9466721dd481d8e498fb2aa99">Activate</a> () override</td></tr>
<tr class="separator:af2dcdca9466721dd481d8e498fb2aa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea49eeeb4d45e54b30d7dd4efee7fa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#aeea49eeeb4d45e54b30d7dd4efee7fa4">Deactivate</a> () override</td></tr>
<tr class="separator:aeea49eeeb4d45e54b30d7dd4efee7fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67617c35f6727059bc14545a46b820c0"><td class="memItemLeft" align="right" valign="top"><a id="a67617c35f6727059bc14545a46b820c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>OnAssetReloaded</b> (<a class="el" href="class_a_z_1_1_data_1_1_asset.html">Data::Asset</a>&lt; <a class="el" href="class_a_z_1_1_data_1_1_asset_data.html">Data::AssetData</a> &gt; asset) override</td></tr>
<tr class="separator:a67617c35f6727059bc14545a46b820c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ce94e7644f8f705342018133c26513"><td class="memItemLeft" align="right" valign="top"><a id="a34ce94e7644f8f705342018133c26513"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a34ce94e7644f8f705342018133c26513">PrepareSave</a> ()</td></tr>
<tr class="memdesc:a34ce94e7644f8f705342018133c26513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare component entity for save, if this is a leaf entity, data patch will be build. <br /></td></tr>
<tr class="separator:a34ce94e7644f8f705342018133c26513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3687776632e4ab3806a45b73aef3152"><td class="memItemLeft" align="right" valign="top"><a id="ac3687776632e4ab3806a45b73aef3152"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ac3687776632e4ab3806a45b73aef3152">BuildEntityInfoMap</a> ()</td></tr>
<tr class="memdesc:ac3687776632e4ab3806a45b73aef3152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the entity info map. This will re-populate it even if already populated. <br /></td></tr>
<tr class="separator:ac3687776632e4ab3806a45b73aef3152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc31d993a59588e35776f5a077cf33e5"><td class="memItemLeft" align="right" valign="top"><a id="adc31d993a59588e35776f5a077cf33e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#adc31d993a59588e35776f5a077cf33e5">RebuildEntityInfoMapIfNecessary</a> ()</td></tr>
<tr class="memdesc:adc31d993a59588e35776f5a077cf33e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repopulate the entity info map if it was already populated. <br /></td></tr>
<tr class="separator:adc31d993a59588e35776f5a077cf33e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253f2cc089ad12cb3757a1592a705f12"><td class="memItemLeft" align="right" valign="top"><a id="a253f2cc089ad12cb3757a1592a705f12"></a>
<a class="el" href="class_a_z_1_1_slice_component_1_1_data_flags_per_entity.html">DataFlagsPerEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a253f2cc089ad12cb3757a1592a705f12">GetCorrectBundleOfDataFlags</a> (<a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> entityId)</td></tr>
<tr class="memdesc:a253f2cc089ad12cb3757a1592a705f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the appropriate <a class="el" href="class_a_z_1_1_slice_component_1_1_data_flags_per_entity.html">DataFlagsPerEntity</a> collection containing this entity's data flags. <br /></td></tr>
<tr class="separator:a253f2cc089ad12cb3757a1592a705f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4573fdbdb69b0ae5a7a73d19f918b3"><td class="memItemLeft" align="right" valign="top"><a id="aaf4573fdbdb69b0ae5a7a73d19f918b3"></a>
const <a class="el" href="class_a_z_1_1_slice_component_1_1_data_flags_per_entity.html">DataFlagsPerEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetCorrectBundleOfDataFlags</b> (<a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> entityId) const</td></tr>
<tr class="separator:aaf4573fdbdb69b0ae5a7a73d19f918b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ad1e60623410c7372de4bee457cc3d"><td class="memItemLeft" align="right" valign="top"><a id="a72ad1e60623410c7372de4bee457cc3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>BuildDataFlagsForInstances</b> ()</td></tr>
<tr class="separator:a72ad1e60623410c7372de4bee457cc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54429dcf04f5a4e2fb7666a41d4914d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a54429dcf04f5a4e2fb7666a41d4914d3">CleanMetadataAssociations</a> ()</td></tr>
<tr class="separator:a54429dcf04f5a4e2fb7666a41d4914d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc18942be5bf9f1b6860660b7d1e8694"><td class="memItemLeft" align="right" valign="top"><a id="afc18942be5bf9f1b6860660b7d1e8694"></a>
const <a class="el" href="class_a_z_std_1_1unordered__map.html">EntityInfoMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#afc18942be5bf9f1b6860660b7d1e8694">GetEntityInfoMap</a> () const</td></tr>
<tr class="memdesc:afc18942be5bf9f1b6860660b7d1e8694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entity info map (and builds it if necessary). <br /></td></tr>
<tr class="separator:afc18942be5bf9f1b6860660b7d1e8694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c9de3e55fa08f51f0f4bb6dc7e9612"><td class="memItemLeft" align="right" valign="top"><a id="a49c9de3e55fa08f51f0f4bb6dc7e9612"></a>
<a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a49c9de3e55fa08f51f0f4bb6dc7e9612">AddOrGetSliceReference</a> (const <a class="el" href="class_a_z_1_1_data_1_1_asset.html">Data::Asset</a>&lt; <a class="el" href="class_a_z_1_1_slice_asset.html">SliceAsset</a> &gt; &amp;sliceAsset)</td></tr>
<tr class="memdesc:a49c9de3e55fa08f51f0f4bb6dc7e9612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reference associated with the specified asset Id. If none is present, one will be created. <br /></td></tr>
<tr class="separator:a49c9de3e55fa08f51f0f4bb6dc7e9612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67ba52cb81e6cf0cfed1a2b4997b454"><td class="memItemLeft" align="right" valign="top"><a id="ae67ba52cb81e6cf0cfed1a2b4997b454"></a>
<a class="el" href="class_a_z_std_1_1list__iterator.html">SliceComponent::SliceList::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ae67ba52cb81e6cf0cfed1a2b4997b454">RemoveSliceReference</a> (<a class="el" href="class_a_z_std_1_1list__iterator.html">SliceComponent::SliceList::iterator</a> sliceReferenceIt)</td></tr>
<tr class="memdesc:ae67ba52cb81e6cf0cfed1a2b4997b454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a slice reference (and all instances) by iterator. <br /></td></tr>
<tr class="separator:ae67ba52cb81e6cf0cfed1a2b4997b454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9ba24ecda29e7e68406ea1fa8a8624"><td class="memItemLeft" align="right" valign="top"><a id="a4b9ba24ecda29e7e68406ea1fa8a8624"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a4b9ba24ecda29e7e68406ea1fa8a8624">PushInstantiateCycle</a> (const <a class="el" href="struct_a_z_1_1_data_1_1_asset_id.html">AZ::Data::AssetId</a> &amp;assetId)</td></tr>
<tr class="memdesc:a4b9ba24ecda29e7e68406ea1fa8a8624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to add an assetId to the cycle checker vector. <br /></td></tr>
<tr class="separator:a4b9ba24ecda29e7e68406ea1fa8a8624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dd731e9d4c535bfe8bf4140112538f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#af6dd731e9d4c535bfe8bf4140112538f">CheckContainsInstantiateCycle</a> (const <a class="el" href="struct_a_z_1_1_data_1_1_asset_id.html">AZ::Data::AssetId</a> &amp;assetId)</td></tr>
<tr class="separator:af6dd731e9d4c535bfe8bf4140112538f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177a7eb9cb1dcfd33eec9f6d901b2b8f"><td class="memItemLeft" align="right" valign="top"><a id="a177a7eb9cb1dcfd33eec9f6d901b2b8f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a177a7eb9cb1dcfd33eec9f6d901b2b8f">PopInstantiateCycle</a> (const <a class="el" href="struct_a_z_1_1_data_1_1_asset_id.html">AZ::Data::AssetId</a> &amp;assetId)</td></tr>
<tr class="memdesc:a177a7eb9cb1dcfd33eec9f6d901b2b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to pop an assetId to the cycle checker vector (also checks to make sure its at the tail of it and clears it) <br /></td></tr>
<tr class="separator:a177a7eb9cb1dcfd33eec9f6d901b2b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_a_z_1_1_component"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_a_z_1_1_component')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_a_z_1_1_component.html">AZ::Component</a></td></tr>
<tr class="memitem:a2263e3e84666abc20ad3ccd142544989 inherit pro_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#a2263e3e84666abc20ad3ccd142544989">Init</a> ()</td></tr>
<tr class="separator:a2263e3e84666abc20ad3ccd142544989 inherit pro_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c8e8ec971ef5e09fc0f325f2636a22 inherit pro_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#a67c8e8ec971ef5e09fc0f325f2636a22">ReadInConfig</a> (const <a class="el" href="class_a_z_1_1_component_config.html">ComponentConfig</a> *baseConfig)</td></tr>
<tr class="separator:a67c8e8ec971ef5e09fc0f325f2636a22 inherit pro_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b0e06c3c155ffe8965227a286ca9b6 inherit pro_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#ab8b0e06c3c155ffe8965227a286ca9b6">WriteOutConfig</a> (<a class="el" href="class_a_z_1_1_component_config.html">ComponentConfig</a> *outBaseConfig) const</td></tr>
<tr class="separator:ab8b0e06c3c155ffe8965227a286ca9b6 inherit pro_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f090a08fd14eef045a3e79350b3d918 inherit pro_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#a3f090a08fd14eef045a3e79350b3d918">SetEntity</a> (<a class="el" href="class_a_z_1_1_entity.html">Entity</a> *entity)</td></tr>
<tr class="separator:a3f090a08fd14eef045a3e79350b3d918 inherit pro_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d67bb9b70d6bc4dfa928c20e95d91b inherit pro_methods_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top"><a id="a05d67bb9b70d6bc4dfa928c20e95d91b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#a05d67bb9b70d6bc4dfa928c20e95d91b">OnAfterEntitySet</a> ()</td></tr>
<tr class="memdesc:a05d67bb9b70d6bc4dfa928c20e95d91b inherit pro_methods_class_a_z_1_1_component"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call after setting the entity in this component. <br /></td></tr>
<tr class="separator:a05d67bb9b70d6bc4dfa928c20e95d91b inherit pro_methods_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ac63232a2169818840827c5f93346fe70"><td class="memItemLeft" align="right" valign="top"><a id="ac63232a2169818840827c5f93346fe70"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ac63232a2169818840827c5f93346fe70">GetProvidedServices</a> (<a class="el" href="class_a_z_1_1_component_descriptor.html#a0612720d9018ebcab09169878196002e">ComponentDescriptor::DependencyArrayType</a> &amp;provided)</td></tr>
<tr class="memdesc:ac63232a2169818840827c5f93346fe70"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_a_z_1_1_component_descriptor.html#a23088633abc3a3edf3098f6e4416deb9">ComponentDescriptor::GetProvidedServices</a> <br /></td></tr>
<tr class="separator:ac63232a2169818840827c5f93346fe70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebefa0aa49d61007c541206f979a95c9"><td class="memItemLeft" align="right" valign="top"><a id="aebefa0aa49d61007c541206f979a95c9"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#aebefa0aa49d61007c541206f979a95c9">GetDependentServices</a> (<a class="el" href="class_a_z_1_1_component_descriptor.html#a0612720d9018ebcab09169878196002e">ComponentDescriptor::DependencyArrayType</a> &amp;dependent)</td></tr>
<tr class="memdesc:aebefa0aa49d61007c541206f979a95c9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_a_z_1_1_component_descriptor.html#af327fa56e9030f606f3e3a52110b627c">ComponentDescriptor::GetDependentServices</a> <br /></td></tr>
<tr class="separator:aebefa0aa49d61007c541206f979a95c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ba4a91fb49e0b14a1b1efdccbac878"><td class="memItemLeft" align="right" valign="top"><a id="a36ba4a91fb49e0b14a1b1efdccbac878"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a36ba4a91fb49e0b14a1b1efdccbac878">Reflect</a> (<a class="el" href="class_a_z_1_1_reflect_context.html">ReflectContext</a> *reflection)</td></tr>
<tr class="memdesc:a36ba4a91fb49e0b14a1b1efdccbac878"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_a_z_1_1_component_descriptor.html#a3722af0fb6275969cc052289bdc50c19">ComponentDescriptor::Reflect</a> <br /></td></tr>
<tr class="separator:a36ba4a91fb49e0b14a1b1efdccbac878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707ecc36c97ed96a5e9e243aec9bf4be"><td class="memItemLeft" align="right" valign="top"><a id="a707ecc36c97ed96a5e9e243aec9bf4be"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a707ecc36c97ed96a5e9e243aec9bf4be">ApplyEntityMapId</a> (<a class="el" href="class_a_z_std_1_1unordered__map.html">EntityIdToEntityIdMap</a> &amp;destination, const <a class="el" href="class_a_z_std_1_1unordered__map.html">EntityIdToEntityIdMap</a> &amp;mapping)</td></tr>
<tr class="memdesc:a707ecc36c97ed96a5e9e243aec9bf4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to apply a EntityIdToEntityIdMap to a EntityIdToEntityIdMap (the mapping will override values in the destination) <br /></td></tr>
<tr class="separator:a707ecc36c97ed96a5e9e243aec9bf4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abd5a149859adeeb1117f3cc482bec98c"><td class="memItemLeft" align="right" valign="top"><a id="abd5a149859adeeb1117f3cc482bec98c"></a>
<a class="el" href="class_a_z_1_1_slice_asset.html">SliceAsset</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#abd5a149859adeeb1117f3cc482bec98c">m_myAsset</a></td></tr>
<tr class="memdesc:abd5a149859adeeb1117f3cc482bec98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the asset we belong to, note this is just a reference stored by the handler, we don't need Asset&lt;SliceAsset&gt; as it's not a reference to another asset. <br /></td></tr>
<tr class="separator:abd5a149859adeeb1117f3cc482bec98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6e1bdef5e03883396df02f2ac6a4f1"><td class="memItemLeft" align="right" valign="top"><a id="a7e6e1bdef5e03883396df02f2ac6a4f1"></a>
<a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_serializeContext</b></td></tr>
<tr class="separator:a7e6e1bdef5e03883396df02f2ac6a4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad69bb4243d05880e9734e8c4eb06985"><td class="memItemLeft" align="right" valign="top"><a id="aad69bb4243d05880e9734e8c4eb06985"></a>
<a class="el" href="class_a_z_std_1_1unordered__map.html">EntityInfoMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#aad69bb4243d05880e9734e8c4eb06985">m_entityInfoMap</a></td></tr>
<tr class="memdesc:aad69bb4243d05880e9734e8c4eb06985"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cached mapping built for quick lookups between an <a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> and its owning <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceInstance</a>. <br /></td></tr>
<tr class="separator:aad69bb4243d05880e9734e8c4eb06985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099c0d40411b09096a64bcfee7b062be"><td class="memItemLeft" align="right" valign="top"><a id="a099c0d40411b09096a64bcfee7b062be"></a>
<a class="el" href="class_a_z_std_1_1unordered__map.html">EntityInfoMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a099c0d40411b09096a64bcfee7b062be">m_metaDataEntityInfoMap</a></td></tr>
<tr class="memdesc:a099c0d40411b09096a64bcfee7b062be"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cached mapping built for quick lookups between a MetaDataEntityId and its owning <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceInstance</a>. <br /></td></tr>
<tr class="separator:a099c0d40411b09096a64bcfee7b062be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97ecf1f22cd25151989e4fbf87da91a"><td class="memItemLeft" align="right" valign="top"><a id="af97ecf1f22cd25151989e4fbf87da91a"></a>
<a class="el" href="class_a_z_std_1_1vector.html">EntityList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#af97ecf1f22cd25151989e4fbf87da91a">m_entities</a></td></tr>
<tr class="memdesc:af97ecf1f22cd25151989e4fbf87da91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entities that are new (not based on a slice). <br /></td></tr>
<tr class="separator:af97ecf1f22cd25151989e4fbf87da91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9bcbb0dded6b8fc2c60f1f6f6c2fff"><td class="memItemLeft" align="right" valign="top"><a id="ade9bcbb0dded6b8fc2c60f1f6f6c2fff"></a>
<a class="el" href="class_a_z_std_1_1list.html">SliceList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ade9bcbb0dded6b8fc2c60f1f6f6c2fff">m_slices</a></td></tr>
<tr class="memdesc:ade9bcbb0dded6b8fc2c60f1f6f6c2fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of base slices and their instances in the world. <br /></td></tr>
<tr class="separator:ade9bcbb0dded6b8fc2c60f1f6f6c2fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bc2d9b5750db8385b64cadb72db44b"><td class="memItemLeft" align="right" valign="top"><a id="a06bc2d9b5750db8385b64cadb72db44b"></a>
<a class="el" href="class_a_z_std_1_1unordered__map.html">SliceAssetToSliceInstances</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a06bc2d9b5750db8385b64cadb72db44b">m_cachedSliceInstances</a></td></tr>
<tr class="memdesc:a06bc2d9b5750db8385b64cadb72db44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice instances saved in layers on the root slice are cached here during the serialization process. <br /></td></tr>
<tr class="separator:a06bc2d9b5750db8385b64cadb72db44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfba8a604534f9b2273fedde7da9c348"><td class="memItemLeft" align="right" valign="top"><a id="acfba8a604534f9b2273fedde7da9c348"></a>
<a class="el" href="class_a_z_std_1_1list.html">SliceList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#acfba8a604534f9b2273fedde7da9c348">m_cachedSliceReferences</a></td></tr>
<tr class="memdesc:acfba8a604534f9b2273fedde7da9c348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice references saved in layers on the root slice are cached here during the serialization process. <br /></td></tr>
<tr class="separator:acfba8a604534f9b2273fedde7da9c348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3556013f665f196f1427143d238087"><td class="memItemLeft" align="right" valign="top"><a id="a6c3556013f665f196f1427143d238087"></a>
<a class="el" href="class_a_z_std_1_1list.html">SliceList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a6c3556013f665f196f1427143d238087">m_invalidSlices</a></td></tr>
<tr class="memdesc:a6c3556013f665f196f1427143d238087"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of slice references that did not load correctly. <br /></td></tr>
<tr class="separator:a6c3556013f665f196f1427143d238087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17a78d66a9177cf207818e7f3b3348c"><td class="memItemLeft" align="right" valign="top"><a id="aa17a78d66a9177cf207818e7f3b3348c"></a>
<a class="el" href="class_a_z_1_1_entity.html">AZ::Entity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#aa17a78d66a9177cf207818e7f3b3348c">m_metadataEntity</a></td></tr>
<tr class="memdesc:aa17a78d66a9177cf207818e7f3b3348c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_a_z_1_1_entity.html">Entity</a> for attaching slice metadata components. <br /></td></tr>
<tr class="separator:aa17a78d66a9177cf207818e7f3b3348c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c50700a2829a93c13299c279d27db1"><td class="memItemLeft" align="right" valign="top"><a id="a09c50700a2829a93c13299c279d27db1"></a>
<a class="el" href="class_a_z_1_1_slice_component_1_1_data_flags_per_entity.html">DataFlagsPerEntity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a09c50700a2829a93c13299c279d27db1">m_dataFlagsForNewEntities</a></td></tr>
<tr class="memdesc:a09c50700a2829a93c13299c279d27db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">DataFlags for new entities (DataFlags for entities based on a slice are stored within the <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceInstance</a>) <br /></td></tr>
<tr class="separator:a09c50700a2829a93c13299c279d27db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e67251d350597982e91db186d4cce3"><td class="memItemLeft" align="right" valign="top"><a id="ae5e67251d350597982e91db186d4cce3"></a>
<a class="el" href="class_a_z_1_1_slice_component_1_1_data_flags_per_entity.html">DataFlagsPerEntity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ae5e67251d350597982e91db186d4cce3">m_cachedDataFlagsForInstances</a></td></tr>
<tr class="memdesc:ae5e67251d350597982e91db186d4cce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cached DataFlags to be used when instantiating instances of this slice. <br /></td></tr>
<tr class="separator:ae5e67251d350597982e91db186d4cce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad9dd1fe46b4d18ad30dd9e52f29cb6"><td class="memItemLeft" align="right" valign="top"><a id="a6ad9dd1fe46b4d18ad30dd9e52f29cb6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a6ad9dd1fe46b4d18ad30dd9e52f29cb6">m_hasGeneratedCachedDataFlags</a></td></tr>
<tr class="memdesc:a6ad9dd1fe46b4d18ad30dd9e52f29cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the cached DataFlags have been generated yet. <br /></td></tr>
<tr class="separator:a6ad9dd1fe46b4d18ad30dd9e52f29cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f84469220fc5c2308b3f33f029d911"><td class="memItemLeft" align="right" valign="top"><a id="a23f84469220fc5c2308b3f33f029d911"></a>
AZStd::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a23f84469220fc5c2308b3f33f029d911">m_slicesAreInstantiated</a></td></tr>
<tr class="memdesc:a23f84469220fc5c2308b3f33f029d911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate state of the base slices (they should be instantiated or not) <br /></td></tr>
<tr class="separator:a23f84469220fc5c2308b3f33f029d911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7418c537addaf9c2d5d295dc3b8ae90"><td class="memItemLeft" align="right" valign="top"><a id="ab7418c537addaf9c2d5d295dc3b8ae90"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ab7418c537addaf9c2d5d295dc3b8ae90">m_allowPartialInstantiation</a></td></tr>
<tr class="memdesc:ab7418c537addaf9c2d5d295dc3b8ae90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiation is still allowed even if dependencies are missing. <br /></td></tr>
<tr class="separator:ab7418c537addaf9c2d5d295dc3b8ae90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1586f39c90345652c78034ca74c00f3"><td class="memItemLeft" align="right" valign="top"><a id="ab1586f39c90345652c78034ca74c00f3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ab1586f39c90345652c78034ca74c00f3">m_isDynamic</a></td></tr>
<tr class="memdesc:ab1586f39c90345652c78034ca74c00f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic slices are available for instantiation at runtime. <br /></td></tr>
<tr class="separator:ab1586f39c90345652c78034ca74c00f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba42c4a72fdc89380be407bba402124c"><td class="memItemLeft" align="right" valign="top"><a id="aba42c4a72fdc89380be407bba402124c"></a>
<a class="el" href="class_a_z_std_1_1function.html">AZ::Data::AssetFilterCB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#aba42c4a72fdc89380be407bba402124c">m_assetLoadFilterCB</a></td></tr>
<tr class="memdesc:aba42c4a72fdc89380be407bba402124c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asset load filter callback to apply for internal loads during data patching. <br /></td></tr>
<tr class="separator:aba42c4a72fdc89380be407bba402124c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324c996b2567bde28642660606bf21cd"><td class="memItemLeft" align="right" valign="top"><a id="a324c996b2567bde28642660606bf21cd"></a>
AZ::u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a324c996b2567bde28642660606bf21cd">m_filterFlags</a></td></tr>
<tr class="memdesc:a324c996b2567bde28642660606bf21cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asset load filter flags to apply for internal loads during data patching. <br /></td></tr>
<tr class="separator:a324c996b2567bde28642660606bf21cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80e9d669133d47fa793c9cbf5516966"><td class="memItemLeft" align="right" valign="top"><a id="ae80e9d669133d47fa793c9cbf5516966"></a>
<a class="el" href="class_a_z_std_1_1recursive__mutex.html">AZStd::recursive_mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#ae80e9d669133d47fa793c9cbf5516966">m_instantiateMutex</a></td></tr>
<tr class="memdesc:ae80e9d669133d47fa793c9cbf5516966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to prevent multiple threads from trying to instantiate the slices at once. <br /></td></tr>
<tr class="separator:ae80e9d669133d47fa793c9cbf5516966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_a_z_1_1_component"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_a_z_1_1_component')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_a_z_1_1_component.html">AZ::Component</a></td></tr>
<tr class="memitem:aa3e2d5415247e5cf67d7572aaa733693 inherit pro_attribs_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top"><a id="aa3e2d5415247e5cf67d7572aaa733693"></a>
<a class="el" href="class_a_z_1_1_entity.html">Entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#aa3e2d5415247e5cf67d7572aaa733693">m_entity</a></td></tr>
<tr class="memdesc:aa3e2d5415247e5cf67d7572aaa733693 inherit pro_attribs_class_a_z_1_1_component"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the entity that owns the component. The value is null if the component is not attached to an entity. <br /></td></tr>
<tr class="separator:aa3e2d5415247e5cf67d7572aaa733693 inherit pro_attribs_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738455cb4649e6d7acd8c5b970530c04 inherit pro_attribs_class_a_z_1_1_component"><td class="memItemLeft" align="right" valign="top"><a id="a738455cb4649e6d7acd8c5b970530c04"></a>
ComponentId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_component.html#a738455cb4649e6d7acd8c5b970530c04">m_id</a></td></tr>
<tr class="memdesc:a738455cb4649e6d7acd8c5b970530c04 inherit pro_attribs_class_a_z_1_1_component"><td class="mdescLeft">&#160;</td><td class="mdescRight">A component ID that is unique for an entity. This component ID is not unique across all entities. <br /></td></tr>
<tr class="separator:a738455cb4649e6d7acd8c5b970530c04 inherit pro_attribs_class_a_z_1_1_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a96afecf9dc8c64f806be9e6839ba356a"><td class="memItemLeft" align="right" valign="top"><a id="a96afecf9dc8c64f806be9e6839ba356a"></a>
static <a class="el" href="class_a_z_std_1_1vector.html">AssetIdVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_slice_component.html#a96afecf9dc8c64f806be9e6839ba356a">m_instantiateCycleChecker</a></td></tr>
<tr class="memdesc:a96afecf9dc8c64f806be9e6839ba356a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to prevent cyclic dependencies. <br /></td></tr>
<tr class="separator:a96afecf9dc8c64f806be9e6839ba356a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a017cf5e61a9dc2ffd75eed1e9ab16f44"><td class="memItemLeft" align="right" valign="top"><a id="a017cf5e61a9dc2ffd75eed1e9ab16f44"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SliceComponentSerializationEvents</b></td></tr>
<tr class="separator:a017cf5e61a9dc2ffd75eed1e9ab16f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3bb63c74d59866627dfcf1e1fce934"><td class="memItemLeft" align="right" valign="top"><a id="aed3bb63c74d59866627dfcf1e1fce934"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SliceAssetHandler</b></td></tr>
<tr class="separator:aed3bb63c74d59866627dfcf1e1fce934"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Slice component manages entities on the project graph (Slice is a node). <a class="el" href="class_a_z_1_1_slice_component.html">SliceComponent</a> with nested dependencies is an edit only concept. We have a runtime version with dependencies so that we can accelerate production by live tweaking of game objects. Otherwise all slices should be exported as list of entities (flat structure). There is an exception with the "dynamic" slices, which should still be a flat list of entities that you "clone" for dynamic reuse. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af3cc1fd7058b7ca7abf6ee60ed55eee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cc1fd7058b7ca7abf6ee60ed55eee0">&#9670;&nbsp;</a></span>PrefabInstance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_slice_component.html#af3cc1fd7058b7ca7abf6ee60ed55eee0">AZ::SliceComponent::PrefabInstance</a> =  <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceInstance</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>Use <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceInstance</a>. </dd></dl>

</div>
</div>
<a id="ac7ad4025606aaff58495b977dc1b9820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ad4025606aaff58495b977dc1b9820">&#9670;&nbsp;</a></span>PrefabInstanceAddress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_slice_component.html#ac7ad4025606aaff58495b977dc1b9820">AZ::SliceComponent::PrefabInstanceAddress</a> =  <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Use <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a>. </dd></dl>

</div>
</div>
<a id="a6db04767ba0b88957f92de791ce3e372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db04767ba0b88957f92de791ce3e372">&#9670;&nbsp;</a></span>PrefabInstanceId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_slice_component.html#a6db04767ba0b88957f92de791ce3e372">AZ::SliceComponent::PrefabInstanceId</a> =  <a class="el" href="struct_a_z_1_1_uuid.html">SliceInstanceId</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>Use SliceInstanceId. </dd></dl>

</div>
</div>
<a id="ac4ecba5b2f3fdacf65968aee859d4529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ecba5b2f3fdacf65968aee859d4529">&#9670;&nbsp;</a></span>PrefabReference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_slice_component.html#ac4ecba5b2f3fdacf65968aee859d4529">AZ::SliceComponent::PrefabReference</a> =  <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>Use <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af2dcdca9466721dd481d8e498fb2aa99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2dcdca9466721dd481d8e498fb2aa99">&#9670;&nbsp;</a></span>Activate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::Activate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts the component into an active state. The system calls this function once during activation of each entity that owns the component. You must override this function. The system calls a component's <a class="el" href="class_a_z_1_1_slice_component.html#af2dcdca9466721dd481d8e498fb2aa99">Activate()</a> function only if all services and components that the component depends on are present and active. Use GetProvidedServices and GetDependentServices to specify these dependencies. </p>

<p>Implements <a class="el" href="class_a_z_1_1_component.html#a3e3e21c0cb8c2a8cb6dc42c83c94a8fe">AZ::Component</a>.</p>

</div>
</div>
<a id="a2be5946c7cadab7be358218d0d589ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be5946c7cadab7be358218d0d589ed1">&#9670;&nbsp;</a></span>AddEntities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::AddEntities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_std_1_1vector.html">EntityList</a> &amp;&#160;</td>
          <td class="paramname"><em>entities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the passed in entities to become owned and tracked by this slice. Used by the layer system to return entities that were briefly borrowed from the root slice. entities The list of entitites to add to this slice. </p>

</div>
</div>
<a id="a5bcfb0678830e941c6f879a1ea1a0e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcfb0678830e941c6f879a1ea1a0e17">&#9670;&nbsp;</a></span>AddSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a> AZ::SliceComponent::AddSlice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_data_1_1_asset.html">Data::Asset</a>&lt; <a class="el" href="class_a_z_1_1_slice_asset.html">SliceAsset</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sliceAsset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_id_utils_1_1_remapper.html">AZ::IdUtils::Remapper</a>&lt; <a class="el" href="class_a_z_1_1_entity_id.html">AZ::EntityId</a> &gt;::IdMapper &amp;&#160;</td>
          <td class="paramname"><em>customMapper</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_uuid.html">SliceInstanceId</a>&#160;</td>
          <td class="paramname"><em>sliceInstanceId</em> = <code>SliceInstanceId::CreateRandom()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a dependent slice, and instantiate the slices if needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sliceAsset</td><td>slice asset. </td></tr>
    <tr><td class="paramname">customMapper</td><td>optional entity runtime id mapper. </td></tr>
    <tr><td class="paramname">assetLoadFilter</td><td>Optional asset load filter. Any filtered-out asset references that are not already memory-resident will not trigger loads. </td></tr>
    <tr><td class="paramname">sliceInstanceId</td><td>The id assigned to the slice instance to be created. If no argument is passed in a random id will be generated as default. If the same sliceInstanceId is already registered to the underlying SlicReference an invalid <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a> is returned as error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a> pointing to the added instance. An invalid <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a> if adding slice failed. </dd></dl>

</div>
</div>
<a id="aae9ed78bc27fcacf717316d8257112ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9ed78bc27fcacf717316d8257112ff">&#9670;&nbsp;</a></span>AddSliceInstances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::AddSliceInstances </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1unordered__map.html">SliceAssetToSliceInstancePtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>sliceInstances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set</a>&lt; const <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceInstance</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>instancesOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the passed in slice instances to this slice. Used by the layer system on load, when a layer is loaded, it may contain one or more slice instances. This allows layers to populate the root slice with those instances. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sliceInstances</td><td>instances that will be given to this slice. It will be empty after this operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af889b7bb1b12fdd18e09739f2da05e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af889b7bb1b12fdd18e09739f2da05e62">&#9670;&nbsp;</a></span>AddSliceUsingExistingEntities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a> AZ::SliceComponent::AddSliceUsingExistingEntities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_data_1_1_asset.html">Data::Asset</a>&lt; <a class="el" href="class_a_z_1_1_slice_asset.html">SliceAsset</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sliceAsset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_std_1_1unordered__map.html">AZ::SliceComponent::EntityIdToEntityIdMap</a> &amp;&#160;</td>
          <td class="paramname"><em>assetToLiveMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_uuid.html">SliceInstanceId</a>&#160;</td>
          <td class="paramname"><em>sliceInstanceId</em> = <code>SliceInstanceId::CreateRandom()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sliceAsset</td><td>Asset of the slice being added </td></tr>
    <tr><td class="paramname">assetToLiveMap</td><td>Mapping from the provided slice asset's EntityID's to existing EntityIDs. Existing EntityIDs should be owned by the <a class="el" href="class_a_z_1_1_slice_component.html">SliceComponent</a> making this call. </td></tr>
    <tr><td class="paramname">sliceInstanceId</td><td>The id assigned to the slice instance to be created. If no argument is passed in a random id will be generated as default. If the same sliceInstanceId is already registered to an invalid <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a> is returned as error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a> pointing to the added instance. A null <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a> if adding slice failed. </dd></dl>

</div>
</div>
<a id="a47889150460317615611ac3a3755daaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47889150460317615611ac3a3755daaf">&#9670;&nbsp;</a></span>AllowPartialInstantiation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::AllowPartialInstantiation </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set whether the slice can be instantiated despite missing dependent slices (allowed by default). </p>

</div>
</div>
<a id="af6dd731e9d4c535bfe8bf4140112538f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6dd731e9d4c535bfe8bf4140112538f">&#9670;&nbsp;</a></span>CheckContainsInstantiateCycle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SliceComponent::CheckContainsInstantiateCycle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_data_1_1_asset_id.html">AZ::Data::AssetId</a> &amp;&#160;</td>
          <td class="paramname"><em>assetId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Utility function to check if the given assetId would cause an instantiation cycle, and if so output the chain of slices that causes the cycle. </p>

</div>
</div>
<a id="a54429dcf04f5a4e2fb7666a41d4914d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54429dcf04f5a4e2fb7666a41d4914d3">&#9670;&nbsp;</a></span>CleanMetadataAssociations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::CleanMetadataAssociations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>During instance instantiation, entities from root slices may be removed by data patches. We need to remove these from the metadata associations in our newly cloned instance metadata entities. </p>

</div>
</div>
<a id="a2c0a1849ea23de1bd033335dc2de5680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0a1849ea23de1bd033335dc2de5680">&#9670;&nbsp;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_1_1_slice_component.html">SliceComponent</a>* AZ::SliceComponent::Clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_serialize_context.html">AZ::SerializeContext</a> &amp;&#160;</td>
          <td class="paramname"><em>serializeContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1unordered__map.html">SliceInstanceToSliceInstanceMap</a> *&#160;</td>
          <td class="paramname"><em>sourceToCloneSliceInstanceMap</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clones the slice, its references, and its instances. <a class="el" href="class_a_z_1_1_entity.html">Entity</a> Ids are not regenerated during this process. This utility is currently used to clone slice asset data for data-push without modifying the existing asset in-memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serializeContext</td><td><a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> to use for cloning </td></tr>
    <tr><td class="paramname">sourceToCloneSliceInstanceMap</td><td>[out] (optional) The map between source SliceInstances and cloned SliceInstances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A clone of this <a class="el" href="class_a_z_1_1_slice_component.html">SliceComponent</a> </dd></dl>

</div>
</div>
<a id="a6969074fc96a43cb289454f6f4e6874d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6969074fc96a43cb289454f6f4e6874d">&#9670;&nbsp;</a></span>CloneAndAddSubSliceInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a> AZ::SliceComponent::CloneAndAddSubSliceInstance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceInstance</a> *&#160;</td>
          <td class="paramname"><em>sourceSliceInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">AZ::SliceComponent::SliceInstanceAddress</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceSubSliceInstanceAncestry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">AZ::SliceComponent::SliceInstanceAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceSubSliceInstanceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1unordered__map.html">AZ::SliceComponent::EntityIdToEntityIdMap</a> *&#160;</td>
          <td class="paramname"><em>out_sourceToCloneEntityIdMap</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserveIds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a sub-slice instance, create a slice reference based on the sub-slice instance's <a class="el" href="class_a_z_1_1_slice_asset.html">SliceAsset</a> (if the slice reference doesn't already exist), then clone the sub-slice instance and add the clone to the slice reference just created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceSliceInstance</td><td>The slice instance that contains the sub-slice instance. </td></tr>
    <tr><td class="paramname">sourceSubSliceInstanceAncestry</td><td>The ancestry in order from sourceSubSlice to sourceSlice </td></tr>
    <tr><td class="paramname">sourceSubSliceInstanceAddress</td><td>The address of the sub-slice instance to be cloned. </td></tr>
    <tr><td class="paramname">out_sourceToCloneEntityIdMap</td><td>[Optional] If provided, the internal source to clone entity ID map will be returned </td></tr>
    <tr><td class="paramname">preserveIds</td><td>[Optional] If true will not generate new IDs for the clone and will direct entity ID maps from base ID to existing live IDs of the original </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the newly created clone-instance. </dd></dl>

</div>
</div>
<a id="aeea49eeeb4d45e54b30d7dd4efee7fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea49eeeb4d45e54b30d7dd4efee7fa4">&#9670;&nbsp;</a></span>Deactivate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::Deactivate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deactivates the component. The system calls this function when the owning entity is being deactivated. You must override this function. As a best practice, ensure that this function returns the component to a minimal footprint. The order of deactivation is the reverse of activation, so your component is deactivated before the components it depends on.</p>
<p>The system always calls the component's <a class="el" href="class_a_z_1_1_slice_component.html#aeea49eeeb4d45e54b30d7dd4efee7fa4">Deactivate()</a> function before destroying the component. However, deactivation is not always followed by the destruction of the component. An entity and its components can be deactivated and reactivated without being destroyed. Ensure that your <a class="el" href="class_a_z_1_1_slice_component.html#aeea49eeeb4d45e54b30d7dd4efee7fa4">Deactivate()</a> implementation can handle this scenario. </p>

<p>Implements <a class="el" href="class_a_z_1_1_component.html#a7b78b890df9b149722d8703da05c79ac">AZ::Component</a>.</p>

</div>
</div>
<a id="acc68850172fab88538b1fc3f5ec23a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc68850172fab88538b1fc3f5ec23a1c">&#9670;&nbsp;</a></span>EraseEntities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::EraseEntities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_std_1_1vector.html">EntityList</a> &amp;&#160;</td>
          <td class="paramname"><em>entities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erases all entities passed in from this slice's m_entities list of loose, owned entities. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entities</td><td>The list of entities to erase. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac32744b0c3b83e211d95282a77eea95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32744b0c3b83e211d95282a77eea95a">&#9670;&nbsp;</a></span>FindEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_1_1_entity.html">AZ::Entity</a>* AZ::SliceComponent::FindEntity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a>&#160;</td>
          <td class="paramname"><em>entityId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an entity in the slice by entity Id. </p>

</div>
</div>
<a id="a29a0541646db6b75c86259364c91d953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a0541646db6b75c86259364c91d953">&#9670;&nbsp;</a></span>FindSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a> AZ::SliceComponent::FindSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_entity.html">Entity</a> *&#160;</td>
          <td class="paramname"><em>entity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the slice information about an entity, if it belongs to the component and is in a slice. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>pointer to instantiated entity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a> and <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceInstance</a> if the entity is in a "child" slice, otherwise null,null. This is true even if entity belongs to the slice (but it's not in a "child" slice) </dd></dl>

</div>
</div>
<a id="a633dcbd3d8436948f9929887c11ad214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633dcbd3d8436948f9929887c11ad214">&#9670;&nbsp;</a></span>FlattenSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SliceComponent::FlattenSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a> *&#160;</td>
          <td class="paramname"><em>toFlatten</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> &amp;&#160;</td>
          <td class="paramname"><em>toFlattenRoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flattens a slice reference directly into the slice component and then removes the reference, all dependencies inherited from the reference will become directly owned by the slice component </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toFlatten</td><td>The reference we are flattening into the component </td></tr>
    <tr><td class="paramname">toFlattenRoot</td><td>The root entity used to determine common ancestry among the entities within the reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if flattening failed </dd></dl>

</div>
</div>
<a id="ade845507fcb5456d9b8480eb051e9911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade845507fcb5456d9b8480eb051e9911">&#9670;&nbsp;</a></span>GenerateNewEntityIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::GenerateNewEntityIds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1unordered__map.html">EntityIdToEntityIdMap</a> *&#160;</td>
          <td class="paramname"><em>previousToNewIdMap</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate new entity Ids and remap references </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previousToNewIdMap</td><td>Output map of previous entityIds to newly generated entityIds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05327ff657b0e163c4a1dc070e138bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05327ff657b0e163c4a1dc070e138bd6">&#9670;&nbsp;</a></span>GetAllInstanceMetadataEntities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SliceComponent::GetAllInstanceMetadataEntities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1vector.html">EntityList</a> &amp;&#160;</td>
          <td class="paramname"><em>outMetadataEntities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends all metadata entities belonging to instances owned by this slice, including those in nested instances to the end of the given list. </p>

</div>
</div>
<a id="a593cf8d1a85ad503eaa73ae2c93d2f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593cf8d1a85ad503eaa73ae2c93d2f3b">&#9670;&nbsp;</a></span>GetAllMetadataEntities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SliceComponent::GetAllMetadataEntities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1vector.html">EntityList</a> &amp;&#160;</td>
          <td class="paramname"><em>outMetadataEntities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets all metadata entities belonging to this slice. This includes instance metadata components and the slice's own metadata component. Because the contents of the result could come from multiple objects, the calling function must provide its own container. Returns true if the operation succeeded (Even if the resulting container is empty) </p>

</div>
</div>
<a id="a4e0e2760ebb81b55e78fb4b18625d58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0e2760ebb81b55e78fb4b18625d58a">&#9670;&nbsp;</a></span>GetDataFlagsForInstances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_z_1_1_slice_component_1_1_data_flags_per_entity.html">DataFlagsPerEntity</a>&amp; AZ::SliceComponent::GetDataFlagsForInstances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns data flags for use when instantiating an instance of this slice. These data flags include those harvested from the entire slice ancestry. </p>

</div>
</div>
<a id="a1d4f4a0e96b0e183570aeca5ee0121c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4f4a0e96b0e183570aeca5ee0121c8">&#9670;&nbsp;</a></span>GetEffectOfEntityDataFlagsAtAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">DataPatch::Flags</a> AZ::SliceComponent::GetEffectOfEntityDataFlagsAtAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataPatch::AddressType &amp;&#160;</td>
          <td class="paramname"><em>dataAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get effect of data flags at a particular address within this entity. Note that the "effect" of data flags could be impacted by data flags set at other addresses, and data flags set in the slice that this entity is based on. </p>

</div>
</div>
<a id="aa7e7fb4cd7a81a2beb1b8154cf751049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e7fb4cd7a81a2beb1b8154cf751049">&#9670;&nbsp;</a></span>GetEntities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SliceComponent::GetEntities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1vector.html">EntityList</a> &amp;&#160;</td>
          <td class="paramname"><em>entities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all entities including the ones based on instances, you need to provide container as we don't keep all entities in one list (we can change that if we need it easily). If entities are not instantiated (the ones based on slices) <a class="el" href="class_a_z_1_1_slice_component.html#a51967daaa453bd0cacce1955ba45ae36">Instantiate</a> will be called </p><dl class="section return"><dt>Returns</dt><dd>true if entities list has been populated (even if empty), and false if instantiation failed. </dd></dl>

</div>
</div>
<a id="a25ddcf6cdebadb48988df751313f3a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ddcf6cdebadb48988df751313f3a83">&#9670;&nbsp;</a></span>GetEntityDataFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">DataPatch::FlagsMap</a>&amp; AZ::SliceComponent::GetEntityDataFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a>&#160;</td>
          <td class="paramname"><em>entityId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return all data flags set for this entity. Addresses are relative the entity. </p>

</div>
</div>
<a id="a9875418980e2f9260dfa003ad387502e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9875418980e2f9260dfa003ad387502e">&#9670;&nbsp;</a></span>GetEntityDataFlagsAtAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">DataPatch::Flags</a> AZ::SliceComponent::GetEntityDataFlagsAtAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a>&#160;</td>
          <td class="paramname"><em>entityId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataPatch::AddressType &amp;&#160;</td>
          <td class="paramname"><em>dataAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the data flags set at a particular address within this entity. </p>

</div>
</div>
<a id="a16c7354ba01155a88f1d7379c305e987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c7354ba01155a88f1d7379c305e987">&#9670;&nbsp;</a></span>GetEntityIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SliceComponent::GetEntityIds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1unordered__set.html">EntityIdSet</a> &amp;&#160;</td>
          <td class="paramname"><em>entities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the IDs of all non-metadata entities, including the ones based on instances, to the provided set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entities</td><td>An entity ID set to add the IDs to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79ed7dc8e451e53e28001785e4fb0774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ed7dc8e451e53e28001785e4fb0774">&#9670;&nbsp;</a></span>GetEntityRestoreInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SliceComponent::GetEntityRestoreInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_entity_id.html">AZ::EntityId</a>&#160;</td>
          <td class="paramname"><em>entityId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_slice_component_1_1_entity_restore_info.html">EntityRestoreInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts data required to restore the specified entity. </p><dl class="section return"><dt>Returns</dt><dd>false if the entity is not part of an internal instance, and doesn't require any special restore operations. </dd></dl>

</div>
</div>
<a id="adcb9830079b81bdabbadc68b07cc8f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb9830079b81bdabbadc68b07cc8f68">&#9670;&nbsp;</a></span>GetInstanceMetadataEntities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SliceComponent::GetInstanceMetadataEntities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1vector.html">EntityList</a> &amp;&#160;</td>
          <td class="paramname"><em>outMetadataEntities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends the metadata entities belonging only directly to each instance in the slice to the given list. Metadata entities belonging to any instances within each instance are omitted. </p>

</div>
</div>
<a id="a86c9d0d41e893520fffeee88b2c5f020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c9d0d41e893520fffeee88b2c5f020">&#9670;&nbsp;</a></span>GetInstantiatedEntityCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t AZ::SliceComponent::GetInstantiatedEntityCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the count of all instantiated entities, including the ones based on instances. If the slice has not been instantiated then 0 is returned. </p>

</div>
</div>
<a id="ae2639e499341293408048b4309a7447e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2639e499341293408048b4309a7447e">&#9670;&nbsp;</a></span>GetInvalidSlices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_z_std_1_1list.html">SliceList</a>&amp; AZ::SliceComponent::GetInvalidSlices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the list of slice references associated with this slice that could not be loaded. </p><dl class="section return"><dt>Returns</dt><dd>The list of invalid slice references. This is empty if there are none. </dd></dl>

</div>
</div>
<a id="a90fbb6cedc03979a90d57f1bd7343f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fbb6cedc03979a90d57f1bd7343f4e">&#9670;&nbsp;</a></span>GetMappingBetweenSubsliceAndSourceInstanceEntityIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void AZ::SliceComponent::GetMappingBetweenSubsliceAndSourceInstanceEntityIds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceComponent::SliceInstance</a> *&#160;</td>
          <td class="paramname"><em>sourceSliceInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">AZ::SliceComponent::SliceInstanceAddress</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sourceSubsliceInstanceAncestry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">AZ::SliceComponent::SliceInstanceAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceSubsliceInstanceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1unordered__map.html">AZ::SliceComponent::EntityIdToEntityIdMap</a> &amp;&#160;</td>
          <td class="paramname"><em>subsliceToLiveMappingResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipMapping</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceSliceInstance</td><td>The slice instance that contains the sub-slice instance </td></tr>
    <tr><td class="paramname">sourceSubsliceInstanceAncestry</td><td>The ancestry in order from sourceSubslice to sourceSlice </td></tr>
    <tr><td class="paramname">sourceSubsliceInstanceAddress</td><td>The address of the sub-slice instance to be cloned </td></tr>
    <tr><td class="paramname">subsliceToLiveMappingResult</td><td>Stores the resulting mapping from the sub slice's base <a class="el" href="class_a_z_1_1_entity.html">Entity</a> Ids to the source slice's live <a class="el" href="class_a_z_1_1_entity.html">Entity</a> Ids </td></tr>
    <tr><td class="paramname">flipMapping</td><td>subsliceToLiveMappingResult will be flipped to instead contain the mapping from source slice to sub slice. Defaults to false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37aeb2cd7cffb594715953d4d35af10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37aeb2cd7cffb594715953d4d35af10b">&#9670;&nbsp;</a></span>GetMetadataEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_1_1_entity.html">AZ::Entity</a>* AZ::SliceComponent::GetMetadataEntity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the metadata entity belonging to this slice </p>

</div>
</div>
<a id="afc203accc30b73685be7838389f5a7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc203accc30b73685be7838389f5a7bb">&#9670;&nbsp;</a></span>GetMetadataEntityIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SliceComponent::GetMetadataEntityIds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1unordered__set.html">EntityIdSet</a> &amp;&#160;</td>
          <td class="paramname"><em>entities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds ID of every metadata entity that's part of this slice, including those based on instances, to the given set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entities</td><td>An entity ID set to add the IDs to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64725dca76f3592b9ccc48e0330eccbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64725dca76f3592b9ccc48e0330eccbc">&#9670;&nbsp;</a></span>GetMyAsset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_z_1_1_slice_asset.html">SliceAsset</a>* AZ::SliceComponent::GetMyAsset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the asset that owns this component. </p>

</div>
</div>
<a id="a13fd59c4a4880807ab7f8dafdf3d22f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fd59c4a4880807ab7f8dafdf3d22f6">&#9670;&nbsp;</a></span>GetReferencedSliceAssets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::GetReferencedSliceAssets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1unordered__set.html">AssetIdSet</a> &amp;&#160;</td>
          <td class="paramname"><em>idSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gathers referenced slice assets for this slice (slice assets this contains, slice assets this depends on) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idSet</td><td>the container that contains the referenced assets after this function is called </td></tr>
    <tr><td class="paramname">recurse</td><td>whether to recurse. true by default so you get ALL referenced assets, false will return only directly-referenced assets </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3f4215322115fea8f3a4327f368f1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f4215322115fea8f3a4327f368f1ec">&#9670;&nbsp;</a></span>InitMetadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::InitMetadata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Newly created slices and legacy slices won't have required metadata components. This will check to see if necessary components to the function of the metadata entities are present and </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Source slice instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51967daaa453bd0cacce1955ba45ae36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51967daaa453bd0cacce1955ba45ae36">&#9670;&nbsp;</a></span>Instantiate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InstantiateResult AZ::SliceComponent::Instantiate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_serialize_context.html">AZ::SerializeContext</a> *&#160;</td>
          <td class="paramname"><em>serializeContext</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map</a>&lt; <a class="el" href="class_a_z_std_1_1basic__string.html">AZStd::string</a>, <a class="el" href="class_a_z_std_1_1basic__string.html">AZStd::string</a> &gt; *&#160;</td>
          <td class="paramname"><em>relativeToAbsoluteSlicePaths</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instantiate entities for this slice, otherwise only the data are stored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serializeContext</td><td>and relativeToAbsoluteSlicePaths are used for a specific case when asset processor is not available </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac99620a7e88f364ced47a8aad7f994f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99620a7e88f364ced47a8aad7f994f6">&#9670;&nbsp;</a></span>IsAllowPartialInstantiation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SliceComponent::IsAllowPartialInstantiation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not the slice allows partial instantiation. </p>

</div>
</div>
<a id="a5d9c219059195af65e9fde74cc4caa3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9c219059195af65e9fde74cc4caa3d">&#9670;&nbsp;</a></span>IsDynamic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SliceComponent::IsDynamic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not this is a dynamic slice to be exported for runtime instantiation. </p>

</div>
</div>
<a id="a93a16da3f1c28c020f03e2d359ab6ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a16da3f1c28c020f03e2d359ab6ea8">&#9670;&nbsp;</a></span>ListenForDependentAssetChanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::ListenForDependentAssetChanges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This will listen for child asset changes and instruct all other slices in the slice hierarchy to do the same. </p>

</div>
</div>
<a id="ad107ec8caa86921079e48662d5850e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad107ec8caa86921079e48662d5850e95">&#9670;&nbsp;</a></span>RemoveAllEntities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::RemoveAllEntities </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteEntities</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeEmptyInstances</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A performant way to remove every entity from a <a class="el" href="class_a_z_1_1_slice_component.html">SliceComponent</a>. Operates in the same way as though you were to loop through every entity in a <a class="el" href="class_a_z_1_1_slice_component.html">SliceComponent</a> and call RemoveEntity(entityId) on them, but using this method will be much faster and is highly recommended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deleteEntities</td><td>true by default as we own all entities, pass false to just remove the entity and gain ownership of it </td></tr>
    <tr><td class="paramname">removeEmptyInstances</td><td>true by default. When set to true, instances will be removed when the last of their entities is removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1efce7ae47d09449c8cf08fc50b3e0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efce7ae47d09449c8cf08fc50b3e0fa">&#9670;&nbsp;</a></span>RemoveAndCacheInstances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::RemoveAndCacheInstances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_std_1_1unordered__map.html">SliceReferenceToInstancePtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>instancesToRemove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the passed in instances from this slice, and caches them to restore later. Used by the layer system so layers can briefly take ownership of these instances. This allows the level slice to save with only slice instances and references unique to the level, and allows layers to save slices instances and references to themselves. instancesToRemove The collection of instances that should be removed from this slice. </p>

</div>
</div>
<a id="a18c5785d02de87725b652924df2c0d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c5785d02de87725b652924df2c0d61">&#9670;&nbsp;</a></span>RemoveMetaDataEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SliceComponent::RemoveMetaDataEntity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a>&#160;</td>
          <td class="paramname"><em>metaDataEntityId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes and deletes a meta data entity from the current slice </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metaDataEntityId</td><td><a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a> of the to be removed meta data entity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the operation succeeds. Otherwise returns false and logs an error. </dd></dl>

</div>
</div>
<a id="ad5fc08a3f53004893af440428634c2c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fc08a3f53004893af440428634c2c3">&#9670;&nbsp;</a></span>ReplaceEntities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::ReplaceEntities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_std_1_1vector.html">EntityList</a> &amp;&#160;</td>
          <td class="paramname"><em>entities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the m_entities list for this slice and replaces it with the passed in entity list. Used by the layer system to return entities it borrowed. Used as a performance shortcut, the layer system will have already retrieved a complete list of all entities managed by this slice. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entities</td><td>The list of entities to replace m_entities with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19f5a3747bf87022c9e88958e597d77c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f5a3747bf87022c9e88958e597d77c">&#9670;&nbsp;</a></span>RestoreCachedInstances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::RestoreCachedInstances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restores slice instances that were cached when RemoveAndCacheInstances was called. </p>

</div>
</div>
<a id="ac83cbe8a9d97cf1e7328c3e23b308805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83cbe8a9d97cf1e7328c3e23b308805">&#9670;&nbsp;</a></span>RestoreEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance_address.html">SliceInstanceAddress</a> AZ::SliceComponent::RestoreEntity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_entity.html">AZ::Entity</a> *&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_slice_component_1_1_entity_restore_info.html">EntityRestoreInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>restoreInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isEntityAdd</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds an entity back to an existing instance. This create a reference for the specified asset if it doesn't already exist. If the reference exists, but the instance with the specified id does not, one will be created. Ownership of the entity is transferred to the instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>A pointer to the entity to be restored. </td></tr>
    <tr><td class="paramname">restoreInfo</td><td>An object holding various information for restoring the entity. Please see <a class="el" href="struct_a_z_1_1_slice_component_1_1_entity_restore_info.html">EntityRestoreInfo</a>. </td></tr>
    <tr><td class="paramname">isEntityAdd</td><td>specifies if the entity we're restoring is part of an entity add. Skips checks for if the entity is in the <a class="el" href="class_a_z_1_1_slice_component.html">SliceComponent</a>. As the entity will not be a part of the <a class="el" href="class_a_z_1_1_slice_component.html">SliceComponent</a> until it is restored. Defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_reference.html">SliceReference</a> and <a class="el" href="class_a_z_1_1_slice_component_1_1_slice_instance.html">SliceInstance</a>, or null if the operation failed. </dd></dl>

</div>
</div>
<a id="afc21f7771499bd33ffbc96c07be36c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc21f7771499bd33ffbc96c07be36c60">&#9670;&nbsp;</a></span>SetEntityDataFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SliceComponent::SetEntityDataFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a>&#160;</td>
          <td class="paramname"><em>entityId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">DataPatch::FlagsMap</a> &amp;&#160;</td>
          <td class="paramname"><em>dataFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set all data flags for this entity. Addresses should be relative the entity. </p><dl class="section return"><dt>Returns</dt><dd>True if flags are set. False if the entity does not exist in this slice. </dd></dl>

</div>
</div>
<a id="a0e9b6d22b4887a5ed93fd8f80dcaea27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9b6d22b4887a5ed93fd8f80dcaea27">&#9670;&nbsp;</a></span>SetEntityDataFlagsAtAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SliceComponent::SetEntityDataFlagsAtAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a>&#160;</td>
          <td class="paramname"><em>entityId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataPatch::AddressType &amp;&#160;</td>
          <td class="paramname"><em>dataAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">DataPatch::Flags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the data flags at a particular address within this entity. </p><dl class="section return"><dt>Returns</dt><dd>True if flags are set. False if the entity does not exist in this slice. </dd></dl>

</div>
</div>
<a id="ac2299e54a002df6a073af6d3563578b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2299e54a002df6a073af6d3563578b1">&#9670;&nbsp;</a></span>SetIsDynamic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::SetIsDynamic </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isDynamic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Designates this slice as dynamic (can be instantiated at runtime). </p>

</div>
</div>
<a id="adc79dcd09acbbd88e819b5ce3ca05527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc79dcd09acbbd88e819b5ce3ca05527">&#9670;&nbsp;</a></span>SetMyAsset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::SliceComponent::SetMyAsset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_slice_asset.html">SliceAsset</a> *&#160;</td>
          <td class="paramname"><em>asset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the asset that owns this component, which allows us to listen for asset changes. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Code/Framework/AzCore/AzCore/Slice/SliceComponent.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><a class="el" href="class_a_z_1_1_slice_component.html">SliceComponent</a></li>
    <li class="footer">Generated on Tue Oct 8 2024 21:02:56 for Open 3D Engine AzCore API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
