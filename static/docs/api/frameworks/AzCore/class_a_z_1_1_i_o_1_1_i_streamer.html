<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine AzCore API Reference: AZ::IO::IStreamer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Open 3D Engine AzCore API Reference<span id="projectnumber">&#160;23.10.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_a_z_1_1_i_o_1_1_i_streamer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_a_z_1_1_i_o_1_1_i_streamer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AZ::IO::IStreamer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;IStreamer.h&gt;</code></p>

<p>Inherited by <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">AZ::IO::Streamer</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3c06c726b4af619b1e89bd2e385805cc"><td class="memItemLeft" align="right" valign="top"><a id="a3c06c726b4af619b1e89bd2e385805cc" name="a3c06c726b4af619b1e89bd2e385805cc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>OnCompleteCallback</b> = <a class="el" href="class_a_z_std_1_1function.html">AZStd::function</a>&lt; void(<a class="el" href="class_a_z_1_1_i_o_1_1_file_request_handle.html">FileRequestHandle</a>)&gt;</td></tr>
<tr class="separator:a3c06c726b4af619b1e89bd2e385805cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0027fd6bd745030051c2c1206f7472b3"><td class="memItemLeft" align="right" valign="top"><a id="a0027fd6bd745030051c2c1206f7472b3" name="a0027fd6bd745030051c2c1206f7472b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_RTTI</b> (<a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html">IStreamer</a>, &quot;{0015594D-6EA5-4309-A2AD-1D704F264A66}&quot;)</td></tr>
<tr class="separator:a0027fd6bd745030051c2c1206f7472b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af047bf1a30057c619bc7665505f0f2cf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#af047bf1a30057c619bc7665505f0f2cf">Read</a> (<a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> relativePath, void *outputBuffer, size_t outputBufferSize, size_t readSize, IStreamerTypes::Deadline deadline=IStreamerTypes::s_noDeadline, IStreamerTypes::Priority priority=IStreamerTypes::s_priorityMedium, size_t offset=0)=0</td></tr>
<tr class="separator:af047bf1a30057c619bc7665505f0f2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbb035097f1e5afe49b79d1879848bd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a9dbb035097f1e5afe49b79d1879848bd">Read</a> (<a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;request, <a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> relativePath, void *outputBuffer, size_t outputBufferSize, size_t readSize, IStreamerTypes::Deadline deadline=IStreamerTypes::s_noDeadline, IStreamerTypes::Priority priority=IStreamerTypes::s_priorityMedium, size_t offset=0)=0</td></tr>
<tr class="separator:a9dbb035097f1e5afe49b79d1879848bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4ac48e2031143bea92f441ade98c0e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a8e4ac48e2031143bea92f441ade98c0e">Read</a> (<a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> relativePath, <a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer_types_1_1_request_memory_allocator.html">IStreamerTypes::RequestMemoryAllocator</a> &amp;allocator, size_t size, IStreamerTypes::Deadline deadline=IStreamerTypes::s_noDeadline, IStreamerTypes::Priority priority=IStreamerTypes::s_priorityMedium, size_t offset=0)=0</td></tr>
<tr class="separator:a8e4ac48e2031143bea92f441ade98c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1a5cb382883e162d1570a74bd35614"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#adf1a5cb382883e162d1570a74bd35614">Read</a> (<a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;request, <a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> relativePath, <a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer_types_1_1_request_memory_allocator.html">IStreamerTypes::RequestMemoryAllocator</a> &amp;allocator, size_t size, IStreamerTypes::Deadline deadline=IStreamerTypes::s_noDeadline, IStreamerTypes::Priority priority=IStreamerTypes::s_priorityMedium, size_t offset=0)=0</td></tr>
<tr class="separator:adf1a5cb382883e162d1570a74bd35614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16dc4ad8dca1aaa1a2d068fee4d5a48"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#ac16dc4ad8dca1aaa1a2d068fee4d5a48">Cancel</a> (<a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> target)=0</td></tr>
<tr class="separator:ac16dc4ad8dca1aaa1a2d068fee4d5a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8197112e9cf82d670a2b686e24db679"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#ac8197112e9cf82d670a2b686e24db679">Cancel</a> (<a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;request, <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> target)=0</td></tr>
<tr class="separator:ac8197112e9cf82d670a2b686e24db679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec33dcefad386469289ab60c332ad879"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#aec33dcefad386469289ab60c332ad879">RescheduleRequest</a> (<a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> target, IStreamerTypes::Deadline newDeadline, IStreamerTypes::Priority newPriority)=0</td></tr>
<tr class="separator:aec33dcefad386469289ab60c332ad879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a992f8d549d08d983e9d12356c330c4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a8a992f8d549d08d983e9d12356c330c4">RescheduleRequest</a> (<a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;request, <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> target, IStreamerTypes::Deadline newDeadline, IStreamerTypes::Priority newPriority)=0</td></tr>
<tr class="separator:a8a992f8d549d08d983e9d12356c330c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35ad31b600b2444f3e97fbd57ec4628"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#ae35ad31b600b2444f3e97fbd57ec4628">CreateDedicatedCache</a> (<a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> relativePath)=0</td></tr>
<tr class="separator:ae35ad31b600b2444f3e97fbd57ec4628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc0bb14ed671132f8810e2ee4e266ec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a3bc0bb14ed671132f8810e2ee4e266ec">CreateDedicatedCache</a> (<a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;request, <a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> relativePath)=0</td></tr>
<tr class="separator:a3bc0bb14ed671132f8810e2ee4e266ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca6d7b540b205fe2e63c316855c3f24"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a1ca6d7b540b205fe2e63c316855c3f24">DestroyDedicatedCache</a> (<a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> relativePath)=0</td></tr>
<tr class="separator:a1ca6d7b540b205fe2e63c316855c3f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93ef5d08495269e6f9fcf0da929423b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#ad93ef5d08495269e6f9fcf0da929423b">DestroyDedicatedCache</a> (<a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;request, <a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> relativePath)=0</td></tr>
<tr class="separator:ad93ef5d08495269e6f9fcf0da929423b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56001e804abef59b3ae60aecb7a0409a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a56001e804abef59b3ae60aecb7a0409a">FlushCache</a> (<a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> relativePath)=0</td></tr>
<tr class="separator:a56001e804abef59b3ae60aecb7a0409a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c24ae8c01ca677e9ea019192a34e96"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#ac9c24ae8c01ca677e9ea019192a34e96">FlushCache</a> (<a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;request, <a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> relativePath)=0</td></tr>
<tr class="separator:ac9c24ae8c01ca677e9ea019192a34e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6198b5b1315860da3cb70d3008dad4e1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a6198b5b1315860da3cb70d3008dad4e1">FlushCaches</a> ()=0</td></tr>
<tr class="separator:a6198b5b1315860da3cb70d3008dad4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7ee204ec28fac3aff649c0315bbe56"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a2f7ee204ec28fac3aff649c0315bbe56">FlushCaches</a> (<a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;request)=0</td></tr>
<tr class="separator:a2f7ee204ec28fac3aff649c0315bbe56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dd009be6368b3f068c66d8f71c847c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#aa3dd009be6368b3f068c66d8f71c847c">Report</a> (<a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_1_1_i_o_1_1_statistic.html">Statistic</a> &gt; &amp;output, IStreamerTypes::ReportType reportType)=0</td></tr>
<tr class="separator:aa3dd009be6368b3f068c66d8f71c847c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42966527f9b479b254cbdf68bde369f3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a42966527f9b479b254cbdf68bde369f3">Report</a> (<a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;request, <a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_1_1_i_o_1_1_statistic.html">Statistic</a> &gt; &amp;output, IStreamerTypes::ReportType reportType)=0</td></tr>
<tr class="separator:a42966527f9b479b254cbdf68bde369f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce5f7f6adc9b0a57ded9ed03c1b6934"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#afce5f7f6adc9b0a57ded9ed03c1b6934">Custom</a> (<a class="el" href="class_a_z_std_1_1any.html">AZStd::any</a> data)=0</td></tr>
<tr class="separator:afce5f7f6adc9b0a57ded9ed03c1b6934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1d4dc3c3ddfb8367edefeeed052cee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#acc1d4dc3c3ddfb8367edefeeed052cee">Custom</a> (<a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;request, <a class="el" href="class_a_z_std_1_1any.html">AZStd::any</a> data)=0</td></tr>
<tr class="separator:acc1d4dc3c3ddfb8367edefeeed052cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3bd050417a0c565d13a20559784cc2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#aba3bd050417a0c565d13a20559784cc2">SetRequestCompleteCallback</a> (<a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;request, <a class="el" href="class_a_z_std_1_1function.html">OnCompleteCallback</a> callback)=0</td></tr>
<tr class="separator:aba3bd050417a0c565d13a20559784cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1fe4fb39debd0a1b7af503c2e47f07"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a6f1fe4fb39debd0a1b7af503c2e47f07">CreateRequest</a> ()=0</td></tr>
<tr class="separator:a6f1fe4fb39debd0a1b7af503c2e47f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275b8cbc12dc47f0cd8840d392d2cc45"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a275b8cbc12dc47f0cd8840d392d2cc45">CreateRequestBatch</a> (<a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &gt; &amp;requests, size_t count)=0</td></tr>
<tr class="separator:a275b8cbc12dc47f0cd8840d392d2cc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926d12da828d3a66bee803ae156bad69"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a926d12da828d3a66bee803ae156bad69">QueueRequest</a> (const <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;request)=0</td></tr>
<tr class="separator:a926d12da828d3a66bee803ae156bad69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cf76cc762cf31287e6c4511a8b1300"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#ab1cf76cc762cf31287e6c4511a8b1300">QueueRequestBatch</a> (const <a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &gt; &amp;requests)=0</td></tr>
<tr class="separator:ab1cf76cc762cf31287e6c4511a8b1300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b0b25563ff4d143ed548df00e131dc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a61b0b25563ff4d143ed548df00e131dc">QueueRequestBatch</a> (<a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &gt; &amp;&amp;requests)=0</td></tr>
<tr class="separator:a61b0b25563ff4d143ed548df00e131dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4a73bd5d8603995c80ea1fdc32c80d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#aae4a73bd5d8603995c80ea1fdc32c80d">HasRequestCompleted</a> (<a class="el" href="class_a_z_1_1_i_o_1_1_file_request_handle.html">FileRequestHandle</a> request) const =0</td></tr>
<tr class="separator:aae4a73bd5d8603995c80ea1fdc32c80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a99d73452bdc019af0e88d9c1c6729"><td class="memItemLeft" align="right" valign="top">virtual IStreamerTypes::RequestStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a74a99d73452bdc019af0e88d9c1c6729">GetRequestStatus</a> (<a class="el" href="class_a_z_1_1_i_o_1_1_file_request_handle.html">FileRequestHandle</a> request) const =0</td></tr>
<tr class="separator:a74a99d73452bdc019af0e88d9c1c6729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa58f2f01e52672b0873af88d7023485"><td class="memItemLeft" align="right" valign="top">virtual AZStd::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#aaa58f2f01e52672b0873af88d7023485">GetEstimatedRequestCompletionTime</a> (<a class="el" href="class_a_z_1_1_i_o_1_1_file_request_handle.html">FileRequestHandle</a> request) const =0</td></tr>
<tr class="separator:aaa58f2f01e52672b0873af88d7023485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b2bd2d1ab820bfff9834fc7acd36b8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a53b2bd2d1ab820bfff9834fc7acd36b8">GetReadRequestResult</a> (<a class="el" href="class_a_z_1_1_i_o_1_1_file_request_handle.html">FileRequestHandle</a> request, void *&amp;buffer, u64 &amp;numBytesRead, IStreamerTypes::ClaimMemory claimMemory=IStreamerTypes::ClaimMemory::No) const =0</td></tr>
<tr class="separator:a53b2bd2d1ab820bfff9834fc7acd36b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad840e17a81b5ef59b7331221f6d09444"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#ad840e17a81b5ef59b7331221f6d09444">CollectStatistics</a> (<a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_1_1_i_o_1_1_statistic.html">Statistic</a> &gt; &amp;statistics)=0</td></tr>
<tr class="separator:ad840e17a81b5ef59b7331221f6d09444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05578b8244d7807118644b87bc253415"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_a_z_1_1_i_o_1_1_i_streamer_types_1_1_recommendations.html">IStreamerTypes::Recommendations</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a05578b8244d7807118644b87bc253415">GetRecommendations</a> () const =0</td></tr>
<tr class="separator:a05578b8244d7807118644b87bc253415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fa4b214a979b551b1db61cc7996fc9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a02fa4b214a979b551b1db61cc7996fc9">SuspendProcessing</a> ()=0</td></tr>
<tr class="separator:a02fa4b214a979b551b1db61cc7996fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072d940a510bc0d5bbfcdc416d59554f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a072d940a510bc0d5bbfcdc416d59554f">ResumeProcessing</a> ()=0</td></tr>
<tr class="separator:a072d940a510bc0d5bbfcdc416d59554f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6adeea97fcf08504a841be2852de68"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html#a3f6adeea97fcf08504a841be2852de68">IsSuspended</a> () const =0</td></tr>
<tr class="memdesc:a3f6adeea97fcf08504a841be2852de68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not processing of requests has been suspended.  <br /></td></tr>
<tr class="separator:a3f6adeea97fcf08504a841be2852de68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Data <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a> <a class="el" href="class_a_z_1_1_interface.html">Interface</a> </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac8197112e9cf82d670a2b686e24db679" name="ac8197112e9cf82d670a2b686e24db679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8197112e9cf82d670a2b686e24db679">&#9670;&#160;</a></span>Cancel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp; AZ::IO::IStreamer::Cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a request to the cancel command. When this request completes it's not guaranteed to have canceled the target request. Not all requests can be canceled and requests that already processing may complete. It's recommended to let the target request handle the completion of the request as normal and handle cancellation by checking the status on the target request is set to IStreamerTypes::RequestStatus::Canceled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request that will store the cancel command. </td></tr>
    <tr><td class="paramname">target</td><td>The request to cancel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the provided request. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a9fce54fcb69a91c10d4c35ebad8913fe">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="ac16dc4ad8dca1aaa1a2d068fee4d5a48" name="ac16dc4ad8dca1aaa1a2d068fee4d5a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16dc4ad8dca1aaa1a2d068fee4d5a48">&#9670;&#160;</a></span>Cancel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> AZ::IO::IStreamer::Cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a request to cancel a previously queued request. When this request completes it's not guaranteed to have canceled the target request. Not all requests can be canceled and requests that already processing may complete. It's recommended to let the target request handle the completion of the request as normal and handle cancellation by checking the status on the target request is set to IStreamerTypes::RequestStatus::Canceled. @target The request to cancel. </p><dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created request with the cancel command. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a01a07f3b1d547284a4db0a2c6c4236b1">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="ad840e17a81b5ef59b7331221f6d09444" name="ad840e17a81b5ef59b7331221f6d09444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad840e17a81b5ef59b7331221f6d09444">&#9670;&#160;</a></span>CollectStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AZ::IO::IStreamer::CollectStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_1_1_i_o_1_1_statistic.html">Statistic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>statistics</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collect statistics from all the components that make up <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>. This function is immediately executed and returns immediately with the results. Due to this behavior there's a limit to the number of statistics that can be returned as only lockless retrieval data can be retrieved. The data is also a snapshot so may be slightly out of date. To get additional data use Report. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statistics</td><td>The container where statistics will be added to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a44de9e4a2cad05a4995254dc99c45958">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="ae35ad31b600b2444f3e97fbd57ec4628" name="ae35ad31b600b2444f3e97fbd57ec4628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35ad31b600b2444f3e97fbd57ec4628">&#9670;&#160;</a></span>CreateDedicatedCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> AZ::IO::IStreamer::CreateDedicatedCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>&#160;</td>
          <td class="paramname"><em>relativePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a dedicated cache for the target file. The target file won't be removed from the cache until DestroyDedicatedCache is called. Typical use of a dedicated cache is for files that have their own compression and are periodically visited to read a section, e.g. streaming video play or streaming audio banks. This request will fail if there are no nodes in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>'s stack that deal with dedicated caches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relativePath</td><td>Relative path to the file to receive a dedicated cache. This can include aliases such as @products. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created request with the command to create a dedicated cache. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#ac1a2e20711c1e1157f609dc0fbb034a5">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a3bc0bb14ed671132f8810e2ee4e266ec" name="a3bc0bb14ed671132f8810e2ee4e266ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc0bb14ed671132f8810e2ee4e266ec">&#9670;&#160;</a></span>CreateDedicatedCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp; AZ::IO::IStreamer::CreateDedicatedCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>&#160;</td>
          <td class="paramname"><em>relativePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a dedicated cache for the target file. The target file won't be removed from the cache until DestroyDedicatedCache is called. Typical use of a dedicated cache is for files that have their own compression and are periodically visited to read a section, e.g. streaming video play or streaming audio banks. This request will fail if there are no nodes in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>'s stack that deal with dedicated caches. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request that will store the command to create a dedicated cache. </td></tr>
    <tr><td class="paramname">relativePath</td><td>Relative path to the file to receive a dedicated cache. This can include aliases such as @products. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the provided request. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#ae65c3a65b2d22973b8440ecdd03029a6">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a6f1fe4fb39debd0a1b7af503c2e47f07" name="a6f1fe4fb39debd0a1b7af503c2e47f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1fe4fb39debd0a1b7af503c2e47f07">&#9670;&#160;</a></span>CreateRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> AZ::IO::IStreamer::CreateRequest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new blank request. Before queuing this request a command must be assigned first. </p><dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created request. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#abe0ac1a3da62ffbaf8504fd8984b9555">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a275b8cbc12dc47f0cd8840d392d2cc45" name="a275b8cbc12dc47f0cd8840d392d2cc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275b8cbc12dc47f0cd8840d392d2cc45">&#9670;&#160;</a></span>CreateRequestBatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AZ::IO::IStreamer::CreateRequestBatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>requests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a number of new blank requests. The requests need to be assigned a command before they can be queued. This function is preferable over CreateRequest if multiple requests are needed as it avoids repeatedly syncing with <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>'s stack. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requests</td><td>Container where the requests will be stored in. </td></tr>
    <tr><td class="paramname">count</td><td>The number of requests to create. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a698c0981cb671e684896bf9ba55f773c">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="afce5f7f6adc9b0a57ded9ed03c1b6934" name="afce5f7f6adc9b0a57ded9ed03c1b6934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce5f7f6adc9b0a57ded9ed03c1b6934">&#9670;&#160;</a></span>Custom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> AZ::IO::IStreamer::Custom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1any.html">AZStd::any</a>&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a custom request. This can be used by extensions to <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>'s stack to add their own commands. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Storage for the arguments to the command. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created request with the custom command. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a0c2ca297acbce0bb218aed6dd9b67e8c">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="acc1d4dc3c3ddfb8367edefeeed052cee" name="acc1d4dc3c3ddfb8367edefeeed052cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1d4dc3c3ddfb8367edefeeed052cee">&#9670;&#160;</a></span>Custom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp; AZ::IO::IStreamer::Custom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1any.html">AZStd::any</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a custom request. This can be used by extensions to <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>'s stack to add their own commands. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request that will store the custom command. </td></tr>
    <tr><td class="paramname">data</td><td>Storage for the arguments to the command. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the provided request. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a3dcffe31eeffce0ccfbad24b370d090f">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a1ca6d7b540b205fe2e63c316855c3f24" name="a1ca6d7b540b205fe2e63c316855c3f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca6d7b540b205fe2e63c316855c3f24">&#9670;&#160;</a></span>DestroyDedicatedCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> AZ::IO::IStreamer::DestroyDedicatedCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>&#160;</td>
          <td class="paramname"><em>relativePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroy a dedicated cache created by CreateDedicatedCache. See CreateDedicatedCache for more details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relativePath</td><td>Relative path to the file that got a dedicated cache. This can include aliases such as @products. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created request with the command to destroy a dedicated cache. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#ab9dadbf46bac81e3e2836e944bd27e82">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="ad93ef5d08495269e6f9fcf0da929423b" name="ad93ef5d08495269e6f9fcf0da929423b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93ef5d08495269e6f9fcf0da929423b">&#9670;&#160;</a></span>DestroyDedicatedCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp; AZ::IO::IStreamer::DestroyDedicatedCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>&#160;</td>
          <td class="paramname"><em>relativePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroy a dedicated cache created by CreateDedicatedCache. See CreateDedicatedCache for more details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request that will store the command to destroy a dedicated cache. </td></tr>
    <tr><td class="paramname">relativePath</td><td>Relative path to the file that got a dedicated cache. This can include aliases such as @products. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the provided request. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a43c5b83915c94253ced62deffc60ca1d">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a56001e804abef59b3ae60aecb7a0409a" name="a56001e804abef59b3ae60aecb7a0409a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56001e804abef59b3ae60aecb7a0409a">&#9670;&#160;</a></span>FlushCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> AZ::IO::IStreamer::FlushCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>&#160;</td>
          <td class="paramname"><em>relativePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears a file from all caches in use by <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>. Flushing the cache will cause the streaming stack to pause processing until it's idle before issuing the flush and resuming processing. This can result in a noticeable interruption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relativePath</td><td>Relative path to the file that will be cleared from all caches. This can include aliases such as @products. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created request with the command to flush a file from all caches. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#ac5545baf77406fb28c59892cf5a39505">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="ac9c24ae8c01ca677e9ea019192a34e96" name="ac9c24ae8c01ca677e9ea019192a34e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c24ae8c01ca677e9ea019192a34e96">&#9670;&#160;</a></span>FlushCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp; AZ::IO::IStreamer::FlushCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>&#160;</td>
          <td class="paramname"><em>relativePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears a file from all caches in use by <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>. Flushing the cache will cause the streaming stack to pause processing until it's idle before issuing the flush and resuming processing. This can result in a noticeable interruption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request that will store the command to flush a file from all caches. </td></tr>
    <tr><td class="paramname">relativePath</td><td>Relative path to the file that will be cleared from all caches. This can include aliases such as @products. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the provided request. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#ac4d7e3c709ec1f01baab8f616d0ff56f">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a6198b5b1315860da3cb70d3008dad4e1" name="a6198b5b1315860da3cb70d3008dad4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6198b5b1315860da3cb70d3008dad4e1">&#9670;&#160;</a></span>FlushCaches() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> AZ::IO::IStreamer::FlushCaches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Forcefully clears out all caches internally held by the streaming stack. This removes all cached information and can result in needing to reload a substantial amount of data. Flushing will cause the streaming stack to pause processing until it's idle before issuing the flush and resuming processing. Both behaviors combined can result in a noticeable interruption. If possible, prefer to use FlushCache instead to reduce the amount of data that would potentially need to be reloaded. </p><dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created request with the command to flush all caches. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a67a47fefd0d839365406191b7e297ae3">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a2f7ee204ec28fac3aff649c0315bbe56" name="a2f7ee204ec28fac3aff649c0315bbe56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7ee204ec28fac3aff649c0315bbe56">&#9670;&#160;</a></span>FlushCaches() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp; AZ::IO::IStreamer::FlushCaches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Forcefully clears out all caches internally held by the streaming stack. This removes all cached information and can result in needing to reload a substantial amount of data. Flushing will cause the streaming stack to pause processing until it's idle before issuing the flush and resuming processing. Both behaviors combined can result in a noticeable interruption. If possible, prefer to use FlushCache instead to reduce the amount of data that would potentially need to be reloaded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request that will store the command to flush all caches. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the provided request. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#aef683923195b250fbf11113925fb7a41">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="aaa58f2f01e52672b0873af88d7023485" name="aaa58f2f01e52672b0873af88d7023485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa58f2f01e52672b0873af88d7023485">&#9670;&#160;</a></span>GetEstimatedRequestCompletionTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AZStd::chrono::steady_clock::time_point AZ::IO::IStreamer::GetEstimatedRequestCompletionTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_i_o_1_1_file_request_handle.html">FileRequestHandle</a>&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the estimated time that the provided request will complete. Estimation doesn't happen until <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>'s stack has picked up the request and zero will be returned until then. As requests complete and new ones are added the estimated completion time will change over time until the request completes. Not all requests well get an estimation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request to get the estimation for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The system time the request will complete or zero of no estimation has been done. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a31298748287d5b5c1e2fa5e51a50fce3">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a53b2bd2d1ab820bfff9834fc7acd36b8" name="a53b2bd2d1ab820bfff9834fc7acd36b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b2bd2d1ab820bfff9834fc7acd36b8">&#9670;&#160;</a></span>GetReadRequestResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool AZ::IO::IStreamer::GetReadRequestResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_i_o_1_1_file_request_handle.html">FileRequestHandle</a>&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 &amp;&#160;</td>
          <td class="paramname"><em>numBytesRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IStreamerTypes::ClaimMemory&#160;</td>
          <td class="paramname"><em>claimMemory</em> = <code>IStreamerTypes::ClaimMemory::No</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the result for operations that read data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request to query. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer the data was written to. </td></tr>
    <tr><td class="paramname">numBytesRead</td><td>The total number of bytes that were read from the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if data could be retrieved, otherwise false. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a384297730e74e681360bed63ae1a3c7f">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a05578b8244d7807118644b87bc253415" name="a05578b8244d7807118644b87bc253415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05578b8244d7807118644b87bc253415">&#9670;&#160;</a></span>GetRecommendations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="struct_a_z_1_1_i_o_1_1_i_streamer_types_1_1_recommendations.html">IStreamerTypes::Recommendations</a> &amp; AZ::IO::IStreamer::GetRecommendations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the recommended configuration options for read requests. Following these recommendations will help improve performance, but are optional. </p>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#af23c4b1df76ec610d669bf8f47064aa5">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a74a99d73452bdc019af0e88d9c1c6729" name="a74a99d73452bdc019af0e88d9c1c6729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a99d73452bdc019af0e88d9c1c6729">&#9670;&#160;</a></span>GetRequestStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual IStreamerTypes::RequestStatus AZ::IO::IStreamer::GetRequestStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_i_o_1_1_file_request_handle.html">FileRequestHandle</a>&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the status of a request. This can be called even if the request has not been queued yet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current status of the request. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#ae2e4639e4eb1afb2f666b2f8de3ddc9a">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="aae4a73bd5d8603995c80ea1fdc32c80d" name="aae4a73bd5d8603995c80ea1fdc32c80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4a73bd5d8603995c80ea1fdc32c80d">&#9670;&#160;</a></span>HasRequestCompleted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool AZ::IO::IStreamer::HasRequestCompleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_i_o_1_1_file_request_handle.html">FileRequestHandle</a>&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the provided request has completed. This can mean it was successful, failed or was canceled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the request is no longer pending or processing and has completed, otherwise false. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a36895cc544a084a2dbeda71c08b357ea">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a3f6adeea97fcf08504a841be2852de68" name="a3f6adeea97fcf08504a841be2852de68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6adeea97fcf08504a841be2852de68">&#9670;&#160;</a></span>IsSuspended()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool AZ::IO::IStreamer::IsSuspended </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether or not processing of requests has been suspended. </p>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a5c23c9c0a5425e0829448e87b65aef5b">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a926d12da828d3a66bee803ae156bad69" name="a926d12da828d3a66bee803ae156bad69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926d12da828d3a66bee803ae156bad69">&#9670;&#160;</a></span>QueueRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AZ::IO::IStreamer::QueueRequest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queues a request for processing by <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>'s stack. After a request has been queued the request pointer can optionally be stored as <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a> supports fire-and-forget for requests. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request that will be processed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#adac6437a0f9546839004846a0d0f827e">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a61b0b25563ff4d143ed548df00e131dc" name="a61b0b25563ff4d143ed548df00e131dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b0b25563ff4d143ed548df00e131dc">&#9670;&#160;</a></span>QueueRequestBatch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AZ::IO::IStreamer::QueueRequestBatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>requests</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queue a batch of requests for processing by <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>'s stack. This version will move requests from the container, but not delete them. This function is preferable over QueueRequest if multiple requests need to be queued at the same time as it avoids repeatedly syncing with the <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>'s stack. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requests</td><td>The requests that will be processed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#ad94817aa38228df84ae963908d602450">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="ab1cf76cc762cf31287e6c4511a8b1300" name="ab1cf76cc762cf31287e6c4511a8b1300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1cf76cc762cf31287e6c4511a8b1300">&#9670;&#160;</a></span>QueueRequestBatch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AZ::IO::IStreamer::QueueRequestBatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>requests</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queue a batch of requests for processing by <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>'s stack. This function is preferable over QueueRequest if multiple requests need to be queued at the same time as it avoids repeatedly syncing with the <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>'s stack. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requests</td><td>The requests that will be processed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a53b39e18dc328295d9f89957a4e8a2db">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a8e4ac48e2031143bea92f441ade98c0e" name="a8e4ac48e2031143bea92f441ade98c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4ac48e2031143bea92f441ade98c0e">&#9670;&#160;</a></span>Read() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> AZ::IO::IStreamer::Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>&#160;</td>
          <td class="paramname"><em>relativePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer_types_1_1_request_memory_allocator.html">IStreamerTypes::RequestMemoryAllocator</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IStreamerTypes::Deadline&#160;</td>
          <td class="paramname"><em>deadline</em> = <code>IStreamerTypes::s_noDeadline</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IStreamerTypes::Priority&#160;</td>
          <td class="paramname"><em>priority</em> = <code>IStreamerTypes::s_priorityMedium</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a request to the read command. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relativePath</td><td>Relative path to the file to load. This can include aliases such as @products. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator used to reserve and release memory for the read request. Memory allocated this way will be automatically freed when there are no more references to the FileRequestPtr. To avoid this, use GetReadRequestResult to claim the pointer and use the provided allocator to release the memory at a later point. The allocator needs to live at least as long as the FileRequestPtr is in use. Do not store the FileRequestPtr in the allocator as this will result in a circular dependency and a memory leak. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to read from the file at the relative path. </td></tr>
    <tr><td class="paramname">deadline</td><td>The amount of time from calling Read that the request should complete. Is FileRequest::s_noDeadline if the request doesn't need to be completed before a specific time. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority used to order requests if multiple requests are at risk of missing their deadline. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the file where reading begins. Warning: reading at an offset other than 0 has a significant impact on performance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created request with the read command. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a07ea865608fb43e1ab9ad0ec9a658829">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="af047bf1a30057c619bc7665505f0f2cf" name="af047bf1a30057c619bc7665505f0f2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af047bf1a30057c619bc7665505f0f2cf">&#9670;&#160;</a></span>Read() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> AZ::IO::IStreamer::Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>&#160;</td>
          <td class="paramname"><em>relativePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outputBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outputBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>readSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IStreamerTypes::Deadline&#160;</td>
          <td class="paramname"><em>deadline</em> = <code>IStreamerTypes::s_noDeadline</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IStreamerTypes::Priority&#160;</td>
          <td class="paramname"><em>priority</em> = <code>IStreamerTypes::s_priorityMedium</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a request to read a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relativePath</td><td>Relative path to the file to load. This can include aliases such as @products. </td></tr>
    <tr><td class="paramname">outputBuffer</td><td>The buffer that will hold the loaded data. This must be able to at least hold "size" number of bytes. </td></tr>
    <tr><td class="paramname">outputBufferSize</td><td>The size of the buffer that will hold the loaded data. This must be equal or larger than "size" number of bytes. </td></tr>
    <tr><td class="paramname">readSize</td><td>The number of bytes to read from the file at the relative path. </td></tr>
    <tr><td class="paramname">deadline</td><td>The amount of time from calling Read that the request should complete. Is FileRequest::s_noDeadline if the request doesn't need to be completed before a specific time. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority used to order requests if multiple requests are at risk of missing their deadline. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the file where reading begins. Warning: reading at an offset other than 0 has a significant impact on performance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created request with the read command. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#ac31db62bc908a930e1a052e3a32ffa79">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="adf1a5cb382883e162d1570a74bd35614" name="adf1a5cb382883e162d1570a74bd35614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1a5cb382883e162d1570a74bd35614">&#9670;&#160;</a></span>Read() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp; AZ::IO::IStreamer::Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>&#160;</td>
          <td class="paramname"><em>relativePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer_types_1_1_request_memory_allocator.html">IStreamerTypes::RequestMemoryAllocator</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IStreamerTypes::Deadline&#160;</td>
          <td class="paramname"><em>deadline</em> = <code>IStreamerTypes::s_noDeadline</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IStreamerTypes::Priority&#160;</td>
          <td class="paramname"><em>priority</em> = <code>IStreamerTypes::s_priorityMedium</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a request to the read command. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request that will store the read command. </td></tr>
    <tr><td class="paramname">relativePath</td><td>Relative path to the file to load. This can include aliases such as @products. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator used to reserve and release memory for the read request. Memory allocated this way will be automatically freed when there are no more references to the FileRequestPtr. To avoid this, use GetReadRequestResult to claim the pointer and use the provided allocator to release the memory at a later point. The allocator needs to live at least as long as the FileRequestPtr is in use. Do not store the FileRequestPtr in the allocator as this will result in a circular dependency and a memory leak. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to read from the file at the relative path. </td></tr>
    <tr><td class="paramname">deadline</td><td>The amount of time from calling Read that the request should complete. Is FileRequest::s_noDeadline if the request doesn't need to be completed before a specific time. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority used to order requests if multiple requests are at risk of missing their deadline. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the file where reading begins. Warning: reading at an offset other than 0 has a significant impact on performance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the provided request. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#adb367fcaa5d2711e07889a332b2c77b2">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a9dbb035097f1e5afe49b79d1879848bd" name="a9dbb035097f1e5afe49b79d1879848bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbb035097f1e5afe49b79d1879848bd">&#9670;&#160;</a></span>Read() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp; AZ::IO::IStreamer::Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>&#160;</td>
          <td class="paramname"><em>relativePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>outputBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outputBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>readSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IStreamerTypes::Deadline&#160;</td>
          <td class="paramname"><em>deadline</em> = <code>IStreamerTypes::s_noDeadline</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IStreamerTypes::Priority&#160;</td>
          <td class="paramname"><em>priority</em> = <code>IStreamerTypes::s_priorityMedium</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a request to the read command. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request that will store the read command. </td></tr>
    <tr><td class="paramname">relativePath</td><td>Relative path to the file to load. This can include aliases such as @products. </td></tr>
    <tr><td class="paramname">outputBuffer</td><td>The buffer that will hold the loaded data. This must be able to at least hold "size" number of bytes. </td></tr>
    <tr><td class="paramname">outputBufferSize</td><td>The size of the buffer that will hold the loaded data. This must be equal or larger than "size" number of bytes. </td></tr>
    <tr><td class="paramname">readSize</td><td>The number of bytes to read from the file at the relative path. </td></tr>
    <tr><td class="paramname">deadline</td><td>The amount of time from calling Read that the request should complete. Is FileRequest::s_noDeadline if the request doesn't need to be completed before a specific time. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority used to order requests if multiple requests are at risk of missing their deadline. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the file where reading begins. Warning: reading at an offset other than 0 has a significant impact on performance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the provided request. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a0611b8927dc4450b14495f9d97bd5aab">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="aa3dd009be6368b3f068c66d8f71c847c" name="aa3dd009be6368b3f068c66d8f71c847c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3dd009be6368b3f068c66d8f71c847c">&#9670;&#160;</a></span>Report() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> AZ::IO::IStreamer::Report </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_1_1_i_o_1_1_statistic.html">Statistic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IStreamerTypes::ReportType&#160;</td>
          <td class="paramname"><em>reportType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves statistics for the requested type. This is meant for statistics that can't be retrieved in a lockless manner. For metrics that can be retrieved lockless use CollectStatistics. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The storage for the information that's being reported. The container needs to remain alive for the duration of the call. Register a callback with SetRequestCompleteCallback to determine when the container is no longer needed. </td></tr>
    <tr><td class="paramname">reportType</td><td>The type of information to report. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created request with the command to report statistics. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a05ff6f73c9d8832ecffeb3803e885f0e">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a42966527f9b479b254cbdf68bde369f3" name="a42966527f9b479b254cbdf68bde369f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42966527f9b479b254cbdf68bde369f3">&#9670;&#160;</a></span>Report() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp; AZ::IO::IStreamer::Report </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_1_1_i_o_1_1_statistic.html">Statistic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IStreamerTypes::ReportType&#160;</td>
          <td class="paramname"><em>reportType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves statistics for the requested type. This is meant for statistics that can't be retrieved in a lockless manner. For metrics that can be retrieved lockless use CollectStatistics. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request that will store the command to report. </td></tr>
    <tr><td class="paramname">output</td><td>The storage for the information that's being reported. The container needs to remain alive for the duration of the call. Register a callback with SetRequestCompleteCallback to determine when the container is no longer needed. </td></tr>
    <tr><td class="paramname">reportType</td><td>The type of information to report. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the provided request. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a20034dedc9db19e4b1b7a669cd8faf79">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a8a992f8d549d08d983e9d12356c330c4" name="a8a992f8d549d08d983e9d12356c330c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a992f8d549d08d983e9d12356c330c4">&#9670;&#160;</a></span>RescheduleRequest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp; AZ::IO::IStreamer::RescheduleRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IStreamerTypes::Deadline&#160;</td>
          <td class="paramname"><em>newDeadline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IStreamerTypes::Priority&#160;</td>
          <td class="paramname"><em>newPriority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adjusts the deadline and priority of a request. This has no effect if the requests is already being processed, if the request doesn't contain a command that can be rescheduled or if the request hasn't been queued. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request that will store the reschedule command. </td></tr>
    <tr><td class="paramname">target</td><td>The request that will be rescheduled. </td></tr>
    <tr><td class="paramname">newDeadline</td><td>The new deadline for the request. </td></tr>
    <tr><td class="paramname">newPriority</td><td>The new priority for the request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the provided request. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a4fdee93fc5c633e8e4d02b5d4e080c16">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="aec33dcefad386469289ab60c332ad879" name="aec33dcefad386469289ab60c332ad879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec33dcefad386469289ab60c332ad879">&#9670;&#160;</a></span>RescheduleRequest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> AZ::IO::IStreamer::RescheduleRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IStreamerTypes::Deadline&#160;</td>
          <td class="paramname"><em>newDeadline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IStreamerTypes::Priority&#160;</td>
          <td class="paramname"><em>newPriority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adjusts the deadline and priority of a request. This has no effect if the requests is already being processed, if the request doesn't contain a command that can be rescheduled or if the request hasn't been queued. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The request that will be rescheduled. </td></tr>
    <tr><td class="paramname">newDeadline</td><td>The new deadline for the request. </td></tr>
    <tr><td class="paramname">newPriority</td><td>The new priority for the request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the newly created request with the reschedule command. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#adc3701dc68922fdc1f06cce3bcb339cb">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a072d940a510bc0d5bbfcdc416d59554f" name="a072d940a510bc0d5bbfcdc416d59554f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072d940a510bc0d5bbfcdc416d59554f">&#9670;&#160;</a></span>ResumeProcessing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AZ::IO::IStreamer::ResumeProcessing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resumes processing requests in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>'s stack if previously one or more calls to SuspendProcessing were made. </p>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a4a5ce251e64a8b606aea0f1bd21bff75">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="aba3bd050417a0c565d13a20559784cc2" name="aba3bd050417a0c565d13a20559784cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3bd050417a0c565d13a20559784cc2">&#9670;&#160;</a></span>SetRequestCompleteCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp; AZ::IO::IStreamer::SetRequestCompleteCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1intrusive__ptr.html">FileRequestPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1function.html">OnCompleteCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a callback function that will trigger when the provided request completes. The callback will be triggered from within the <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>'s stack on a different thread. While in the callback function <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a> can't continue processing requests so it's recommended to keep the callback short, for instance by setting an atomic value to be picked up by another thread like the main thread or to queue a job (function) to complete the work. Note avoid storing a copy of the owning FileRequestPtr in a lambda provided as the callback. This will result in the same request storing a copy of itself indirectly, which means the reference counter can never reach zero due to the circular dependency and results in a resource leak. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request that will get the callback assigned. </td></tr>
    <tr><td class="paramname">callback</td><td>A function with the signature "void(FileRequestHandle request);" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the provided request. </dd></dl>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#af603bb435ec786644da94139d762505a">AZ::IO::Streamer</a>.</p>

</div>
</div>
<a id="a02fa4b214a979b551b1db61cc7996fc9" name="a02fa4b214a979b551b1db61cc7996fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fa4b214a979b551b1db61cc7996fc9">&#9670;&#160;</a></span>SuspendProcessing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AZ::IO::IStreamer::SuspendProcessing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Suspends processing of requests in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html">Streamer</a>'s stack. New requests can still be queued, but they won't be processed until ResumeProcessing is called. </p>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_streamer.html#a4aa168b4a226c5980f74c93d4ad2b340">AZ::IO::Streamer</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Code/Framework/AzCore/AzCore/IO/IStreamer.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><a class="el" href="namespace_a_z_1_1_i_o.html">IO</a></li><li class="navelem"><a class="el" href="class_a_z_1_1_i_o_1_1_i_streamer.html">IStreamer</a></li>
    <li class="footer">Generated on Mon Oct 9 2023 13:38:46 for Open 3D Engine AzCore API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
