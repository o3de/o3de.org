<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine AzCore API Reference: AZ::IO::FileIOBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Open 3D Engine AzCore API Reference<span id="projectnumber">&#160;23.10.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_a_z_1_1_i_o_1_1_file_i_o_base.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_a_z_1_1_i_o_1_1_file_i_o_base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AZ::IO::FileIOBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The base class for file <a class="el" href="namespace_a_z_1_1_i_o.html" title="PathView implementation.">IO</a> stack classes.  
 <a href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#details">More...</a></p>

<p><code>#include &lt;FileIO.h&gt;</code></p>

<p>Inherited by <a class="el" href="class_a_z_1_1_i_o_1_1_mock_file_i_o_base.html">AZ::IO::MockFileIOBase</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2298dfcf657103f83c1ec590e615e9b5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_a_z_std_1_1function.html">AZStd::function</a>&lt; bool(const char *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#a2298dfcf657103f83c1ec590e615e9b5">FindFilesCallbackType</a></td></tr>
<tr class="separator:a2298dfcf657103f83c1ec590e615e9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab1f5fcabba2839d2f918ccfe41af51d2"><td class="memItemLeft" align="right" valign="top"><a id="ab1f5fcabba2839d2f918ccfe41af51d2" name="ab1f5fcabba2839d2f918ccfe41af51d2"></a>
virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Open</b> (const char *filePath, <a class="el" href="namespace_a_z_1_1_i_o.html#ad47e72ec86c619fc4165fd0f45e92cd2">OpenMode</a> mode, HandleType &amp;fileHandle)=0</td></tr>
<tr class="separator:ab1f5fcabba2839d2f918ccfe41af51d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54252be6ede964c1272f962797baa8b8"><td class="memItemLeft" align="right" valign="top"><a id="a54252be6ede964c1272f962797baa8b8" name="a54252be6ede964c1272f962797baa8b8"></a>
virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Close</b> (HandleType fileHandle)=0</td></tr>
<tr class="separator:a54252be6ede964c1272f962797baa8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c36dca5cc9077513b3ee0207ad8c52e"><td class="memItemLeft" align="right" valign="top"><a id="a0c36dca5cc9077513b3ee0207ad8c52e" name="a0c36dca5cc9077513b3ee0207ad8c52e"></a>
virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Tell</b> (HandleType fileHandle, AZ::u64 &amp;offset)=0</td></tr>
<tr class="separator:a0c36dca5cc9077513b3ee0207ad8c52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fdd5fef14af5c7337f4bb8060c7db3"><td class="memItemLeft" align="right" valign="top"><a id="ac8fdd5fef14af5c7337f4bb8060c7db3" name="ac8fdd5fef14af5c7337f4bb8060c7db3"></a>
virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Seek</b> (HandleType fileHandle, AZ::s64 offset, SeekType type)=0</td></tr>
<tr class="separator:ac8fdd5fef14af5c7337f4bb8060c7db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cf0507863672358c0b8863b4396b0d"><td class="memItemLeft" align="right" valign="top"><a id="ac7cf0507863672358c0b8863b4396b0d" name="ac7cf0507863672358c0b8863b4396b0d"></a>
virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Read</b> (HandleType fileHandle, void *buffer, AZ::u64 size, bool failOnFewerThanSizeBytesRead=false, AZ::u64 *bytesRead=nullptr)=0</td></tr>
<tr class="separator:ac7cf0507863672358c0b8863b4396b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23133c6def6578297d3ba4fa36d65930"><td class="memItemLeft" align="right" valign="top"><a id="a23133c6def6578297d3ba4fa36d65930" name="a23133c6def6578297d3ba4fa36d65930"></a>
virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Write</b> (HandleType fileHandle, const void *buffer, AZ::u64 size, AZ::u64 *bytesWritten=nullptr)=0</td></tr>
<tr class="separator:a23133c6def6578297d3ba4fa36d65930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012c0a9b1dd0590b743281db4e9da87b"><td class="memItemLeft" align="right" valign="top"><a id="a012c0a9b1dd0590b743281db4e9da87b" name="a012c0a9b1dd0590b743281db4e9da87b"></a>
virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Flush</b> (HandleType fileHandle)=0</td></tr>
<tr class="separator:a012c0a9b1dd0590b743281db4e9da87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1631114d914af4ae9bc03954f90e653a"><td class="memItemLeft" align="right" valign="top"><a id="a1631114d914af4ae9bc03954f90e653a" name="a1631114d914af4ae9bc03954f90e653a"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>Eof</b> (HandleType fileHandle)=0</td></tr>
<tr class="separator:a1631114d914af4ae9bc03954f90e653a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2574fb40dea49afa2f3ad30e7b51b3"><td class="memItemLeft" align="right" valign="top">virtual AZ::u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#afd2574fb40dea49afa2f3ad30e7b51b3">ModificationTime</a> (HandleType fileHandle)=0</td></tr>
<tr class="separator:afd2574fb40dea49afa2f3ad30e7b51b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66401a3994a9f9df48765125695d7f01"><td class="memItemLeft" align="right" valign="top"><a id="a66401a3994a9f9df48765125695d7f01" name="a66401a3994a9f9df48765125695d7f01"></a>
virtual AZ::u64&#160;</td><td class="memItemRight" valign="bottom"><b>ModificationTime</b> (const char *filePath)=0</td></tr>
<tr class="separator:a66401a3994a9f9df48765125695d7f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eecb0ccca0ef611a952024620db526a"><td class="memItemLeft" align="right" valign="top"><a id="a6eecb0ccca0ef611a952024620db526a" name="a6eecb0ccca0ef611a952024620db526a"></a>
virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Size</b> (const char *filePath, AZ::u64 &amp;size)=0</td></tr>
<tr class="memdesc:a6eecb0ccca0ef611a952024620db526a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the file. Returns Success if we report size. <br /></td></tr>
<tr class="separator:a6eecb0ccca0ef611a952024620db526a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafdaa3f86e2cbf981bb1c00d1d954c5"><td class="memItemLeft" align="right" valign="top"><a id="adafdaa3f86e2cbf981bb1c00d1d954c5" name="adafdaa3f86e2cbf981bb1c00d1d954c5"></a>
virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Size</b> (HandleType fileHandle, AZ::u64 &amp;size)=0</td></tr>
<tr class="separator:adafdaa3f86e2cbf981bb1c00d1d954c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085855d14f59d17d9c6253e64792ae9a"><td class="memItemLeft" align="right" valign="top"><a id="a085855d14f59d17d9c6253e64792ae9a" name="a085855d14f59d17d9c6253e64792ae9a"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>Exists</b> (const char *filePath)=0</td></tr>
<tr class="memdesc:a085855d14f59d17d9c6253e64792ae9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">no fail, returns false if it does not exist <br /></td></tr>
<tr class="separator:a085855d14f59d17d9c6253e64792ae9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df81040c70fd53a55779485b3345462"><td class="memItemLeft" align="right" valign="top"><a id="a7df81040c70fd53a55779485b3345462" name="a7df81040c70fd53a55779485b3345462"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsDirectory</b> (const char *filePath)=0</td></tr>
<tr class="memdesc:a7df81040c70fd53a55779485b3345462"><td class="mdescLeft">&#160;</td><td class="mdescRight">no fail, returns false if its not a directory or does not exist <br /></td></tr>
<tr class="separator:a7df81040c70fd53a55779485b3345462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbaa256d8392f6836cacdb0b8df6bdb"><td class="memItemLeft" align="right" valign="top"><a id="adcbaa256d8392f6836cacdb0b8df6bdb" name="adcbaa256d8392f6836cacdb0b8df6bdb"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsReadOnly</b> (const char *filePath)=0</td></tr>
<tr class="memdesc:adcbaa256d8392f6836cacdb0b8df6bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">no fail, returns false if its read only or does not exist <br /></td></tr>
<tr class="separator:adcbaa256d8392f6836cacdb0b8df6bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d169afbdf33e381cf187ac4977d679"><td class="memItemLeft" align="right" valign="top"><a id="a07d169afbdf33e381cf187ac4977d679" name="a07d169afbdf33e381cf187ac4977d679"></a>
virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CreatePath</b> (const char *filePath)=0</td></tr>
<tr class="memdesc:a07d169afbdf33e381cf187ac4977d679"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a path, recursively <br /></td></tr>
<tr class="separator:a07d169afbdf33e381cf187ac4977d679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44665a51c2b6df91b3fbdc710e3e2bed"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#a44665a51c2b6df91b3fbdc710e3e2bed">DestroyPath</a> (const char *filePath)=0</td></tr>
<tr class="separator:a44665a51c2b6df91b3fbdc710e3e2bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fe3fbe1a6f453d5a98a29fa2d4fe1b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#ac1fe3fbe1a6f453d5a98a29fa2d4fe1b">Remove</a> (const char *filePath)=0</td></tr>
<tr class="separator:ac1fe3fbe1a6f453d5a98a29fa2d4fe1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e051a69ef48cc16cda7914effb97e05"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#a0e051a69ef48cc16cda7914effb97e05">Copy</a> (const char *sourceFilePath, const char *destinationFilePath)=0</td></tr>
<tr class="separator:a0e051a69ef48cc16cda7914effb97e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb11bb0f628a9bb130be55458107c262"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#abb11bb0f628a9bb130be55458107c262">Rename</a> (const char *originalFilePath, const char *newFilePath)=0</td></tr>
<tr class="separator:abb11bb0f628a9bb130be55458107c262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a26052d2e818aa750327efc039ced2d"><td class="memItemLeft" align="right" valign="top"><a id="a4a26052d2e818aa750327efc039ced2d" name="a4a26052d2e818aa750327efc039ced2d"></a>
virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FindFiles</b> (const char *filePath, const char *filter, <a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#a2298dfcf657103f83c1ec590e615e9b5">FindFilesCallbackType</a> callback)=0</td></tr>
<tr class="separator:a4a26052d2e818aa750327efc039ced2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e886668bfbee3dbf5873f3fcd18054"><td class="memItemLeft" align="right" valign="top"><a id="a41e886668bfbee3dbf5873f3fcd18054" name="a41e886668bfbee3dbf5873f3fcd18054"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetAlias</b> (const char *alias, const char *path)=0</td></tr>
<tr class="memdesc:a41e886668bfbee3dbf5873f3fcd18054"><td class="mdescLeft">&#160;</td><td class="mdescRight">SetAlias - Adds an alias to the path resolution system, e.g. @user@, @products@, etc. <br /></td></tr>
<tr class="separator:a41e886668bfbee3dbf5873f3fcd18054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9298684c78e9b8ff2c75fe3dd1fd680d"><td class="memItemLeft" align="right" valign="top"><a id="a9298684c78e9b8ff2c75fe3dd1fd680d" name="a9298684c78e9b8ff2c75fe3dd1fd680d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>ClearAlias</b> (const char *alias)=0</td></tr>
<tr class="memdesc:a9298684c78e9b8ff2c75fe3dd1fd680d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ClearAlias - Removes an alias from the path resolution system. <br /></td></tr>
<tr class="separator:a9298684c78e9b8ff2c75fe3dd1fd680d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c9f31bc8111c9319d2389413a8d82a"><td class="memItemLeft" align="right" valign="top"><a id="aa1c9f31bc8111c9319d2389413a8d82a" name="aa1c9f31bc8111c9319d2389413a8d82a"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><b>GetAlias</b> (const char *alias) const =0</td></tr>
<tr class="memdesc:aa1c9f31bc8111c9319d2389413a8d82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">GetAlias - Returns the destination path for a given alias, or nullptr if the alias does not exist. <br /></td></tr>
<tr class="separator:aa1c9f31bc8111c9319d2389413a8d82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1468946d7eac349fc53a078fdf6ca4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#aac1468946d7eac349fc53a078fdf6ca4">SetDeprecatedAlias</a> (<a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> oldAlias, <a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> newAlias)=0</td></tr>
<tr class="separator:aac1468946d7eac349fc53a078fdf6ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc3fcc7767ae6d508fb7ef7aa88ed21"><td class="memItemLeft" align="right" valign="top">virtual AZStd::optional&lt; AZ::u64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#a8fc3fcc7767ae6d508fb7ef7aa88ed21">ConvertToAlias</a> (char *inOutBuffer, AZ::u64 bufferLength) const =0</td></tr>
<tr class="separator:a8fc3fcc7767ae6d508fb7ef7aa88ed21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57707093783baedbbdcc813e9636661"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#aa57707093783baedbbdcc813e9636661">ConvertToAlias</a> (<a class="el" href="class_a_z_1_1_i_o_1_1_basic_path.html">AZ::IO::FixedMaxPath</a> &amp;convertedPath, const <a class="el" href="class_a_z_1_1_i_o_1_1_path_view.html">AZ::IO::PathView</a> &amp;path) const =0</td></tr>
<tr class="separator:aa57707093783baedbbdcc813e9636661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfae1c6ad04e5567120006ea445c49a4"><td class="memItemLeft" align="right" valign="top"><a id="adfae1c6ad04e5567120006ea445c49a4" name="adfae1c6ad04e5567120006ea445c49a4"></a>
AZStd::optional&lt; <a class="el" href="class_a_z_1_1_i_o_1_1_basic_path.html">AZ::IO::FixedMaxPath</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConvertToAlias</b> (const <a class="el" href="class_a_z_1_1_i_o_1_1_path_view.html">AZ::IO::PathView</a> &amp;path) const</td></tr>
<tr class="separator:adfae1c6ad04e5567120006ea445c49a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbae30792f2f0ca81a1ea46805d411b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#a2bbae30792f2f0ca81a1ea46805d411b">ResolvePath</a> (const char *path, char *resolvedPath, AZ::u64 resolvedPathSize) const =0</td></tr>
<tr class="separator:a2bbae30792f2f0ca81a1ea46805d411b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9844a46310e0789d315c40f68efff60e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#a9844a46310e0789d315c40f68efff60e">ResolvePath</a> (<a class="el" href="class_a_z_1_1_i_o_1_1_basic_path.html">AZ::IO::FixedMaxPath</a> &amp;resolvedPath, const <a class="el" href="class_a_z_1_1_i_o_1_1_path_view.html">AZ::IO::PathView</a> &amp;path) const =0</td></tr>
<tr class="separator:a9844a46310e0789d315c40f68efff60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6e9f0aadcfef993f18368d12b08fd2"><td class="memItemLeft" align="right" valign="top"><a id="aba6e9f0aadcfef993f18368d12b08fd2" name="aba6e9f0aadcfef993f18368d12b08fd2"></a>
AZStd::optional&lt; <a class="el" href="class_a_z_1_1_i_o_1_1_basic_path.html">AZ::IO::FixedMaxPath</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ResolvePath</b> (const <a class="el" href="class_a_z_1_1_i_o_1_1_path_view.html">AZ::IO::PathView</a> &amp;path) const</td></tr>
<tr class="separator:aba6e9f0aadcfef993f18368d12b08fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8b4689b45dce88aa48f8583f9b4393"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#a4d8b4689b45dce88aa48f8583f9b4393">ReplaceAlias</a> (<a class="el" href="class_a_z_1_1_i_o_1_1_basic_path.html">AZ::IO::FixedMaxPath</a> &amp;replacedAliasPath, const <a class="el" href="class_a_z_1_1_i_o_1_1_path_view.html">AZ::IO::PathView</a> &amp;path) const =0</td></tr>
<tr class="separator:a4d8b4689b45dce88aa48f8583f9b4393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd70e6af3b4911f0592cf0daf3c254e9"><td class="memItemLeft" align="right" valign="top"><a id="acd70e6af3b4911f0592cf0daf3c254e9" name="acd70e6af3b4911f0592cf0daf3c254e9"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetFilename</b> (HandleType fileHandle, char *filename, AZ::u64 filenameSize) const =0</td></tr>
<tr class="memdesc:acd70e6af3b4911f0592cf0daf3c254e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divulge the filename used to originally open that handle. <br /></td></tr>
<tr class="separator:acd70e6af3b4911f0592cf0daf3c254e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ca7c864af3837aa7d66171bc0039ba"><td class="memItemLeft" align="right" valign="top"><a id="a69ca7c864af3837aa7d66171bc0039ba" name="a69ca7c864af3837aa7d66171bc0039ba"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsRemoteIOEnabled</b> ()</td></tr>
<tr class="separator:a69ca7c864af3837aa7d66171bc0039ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab69336bf9b02f2dd844886972e4ab4f9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html">FileIOBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#ab69336bf9b02f2dd844886972e4ab4f9">GetInstance</a> ()</td></tr>
<tr class="separator:ab69336bf9b02f2dd844886972e4ab4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac95ad4e7d95dd5f97fecf662168670d"><td class="memItemLeft" align="right" valign="top"><a id="aac95ad4e7d95dd5f97fecf662168670d" name="aac95ad4e7d95dd5f97fecf662168670d"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>SetInstance</b> (<a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html">FileIOBase</a> *instance)</td></tr>
<tr class="separator:aac95ad4e7d95dd5f97fecf662168670d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639d6d2c3518f403353196b34ef6a0d8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html">FileIOBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#a639d6d2c3518f403353196b34ef6a0d8">GetDirectInstance</a> ()</td></tr>
<tr class="separator:a639d6d2c3518f403353196b34ef6a0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c6444e7e7ff1bb13ec70ae1612cb5b"><td class="memItemLeft" align="right" valign="top"><a id="a46c6444e7e7ff1bb13ec70ae1612cb5b" name="a46c6444e7e7ff1bb13ec70ae1612cb5b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>SetDirectInstance</b> (<a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html">FileIOBase</a> *instance)</td></tr>
<tr class="separator:a46c6444e7e7ff1bb13ec70ae1612cb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The base class for file <a class="el" href="namespace_a_z_1_1_i_o.html" title="PathView implementation.">IO</a> stack classes. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2298dfcf657103f83c1ec590e615e9b5" name="a2298dfcf657103f83c1ec590e615e9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2298dfcf657103f83c1ec590e615e9b5">&#9670;&#160;</a></span>FindFilesCallbackType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_a_z_std_1_1function.html">AZStd::function</a>&lt;bool(const char*)&gt; <a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#a2298dfcf657103f83c1ec590e615e9b5">AZ::IO::FileIOBase::FindFilesCallbackType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FindFiles - return all files and directories matching that filter (dos-style filters) at that file path does not recurse. does not return the . or .. directories not all filters are supported. You must include &lt;AzCore/std/functional.h&gt; if you use this note: the callback will contain the full concatenated path (filePath + slash + fileName) not just the individual file name found. note: if the file path of the found file corresponds to a registered ALIAS, the longest matching alias will be returned so expect return values like @products@/textures/mytexture.dds instead of a full path. This is so that fileIO works over remote connections. note: if rootPath is specified the implementation has the option of substituting it for the current directory as would be the case on a file server. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa57707093783baedbbdcc813e9636661" name="aa57707093783baedbbdcc813e9636661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57707093783baedbbdcc813e9636661">&#9670;&#160;</a></span>ConvertToAlias() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool AZ::IO::FileIOBase::ConvertToAlias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_i_o_1_1_basic_path.html">AZ::IO::FixedMaxPath</a> &amp;&#160;</td>
          <td class="paramname"><em>convertedPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_i_o_1_1_path_view.html">AZ::IO::PathView</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ConvertToAlias - Converts the start of the path to alias form. i.e @alias@/... if possible i.e if  </p>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_mock_file_i_o_base.html#aeb08c38417d243451d4b4f6e3bf0cb68">AZ::IO::MockFileIOBase</a>.</p>

</div>
</div>
<a id="a8fc3fcc7767ae6d508fb7ef7aa88ed21" name="a8fc3fcc7767ae6d508fb7ef7aa88ed21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc3fcc7767ae6d508fb7ef7aa88ed21">&#9670;&#160;</a></span>ConvertToAlias() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AZStd::optional&lt; AZ::u64 &gt; AZ::IO::FileIOBase::ConvertToAlias </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>inOutBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::u64&#160;</td>
          <td class="paramname"><em>bufferLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shorten the given path if it contains an alias. it will always pick the longest alias match. note that it re-uses the buffer, since the data can only get smaller and we don't want to internally allocate memory if we can avoid it. If for some reason the @alias@ is longer than the path it represents and the path cannot fit in the buffer a nullopt is returned, otherwise it returns the length of the result </p>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_mock_file_i_o_base.html#a66431e0a4b5091a9cd320791c7ee0254">AZ::IO::MockFileIOBase</a>.</p>

</div>
</div>
<a id="a0e051a69ef48cc16cda7914effb97e05" name="a0e051a69ef48cc16cda7914effb97e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e051a69ef48cc16cda7914effb97e05">&#9670;&#160;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a> AZ::IO::FileIOBase::Copy </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sourceFilePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>destinationFilePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>does not overwrite the destination if it exists. note that attributes are not required to be copied the modtime of the destination path must be equal or greater than the source path but doesn't have to be equal (some operating systems forbid modifying modtimes due to security constraints) </p>

</div>
</div>
<a id="a44665a51c2b6df91b3fbdc710e3e2bed" name="a44665a51c2b6df91b3fbdc710e3e2bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44665a51c2b6df91b3fbdc710e3e2bed">&#9670;&#160;</a></span>DestroyPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a> AZ::IO::FileIOBase::DestroyPath </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DestroyPath - Destroys the entire path and all of its contents (all files, all subdirectories, etc) succeeds if the directory was successfully destroys succeeds if the directory didn't exist in the first place fails if the path could not be destroyed (for example, if a file could not be erased for any reason) also fails if filePath refers to a file name which exists instead of a directory name. It must be a directory name. </p>

</div>
</div>
<a id="a639d6d2c3518f403353196b34ef6a0d8" name="a639d6d2c3518f403353196b34ef6a0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639d6d2c3518f403353196b34ef6a0d8">&#9670;&#160;</a></span>GetDirectInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html">FileIOBase</a> * AZ::IO::FileIOBase::GetDirectInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Direct <a class="el" href="namespace_a_z_1_1_i_o.html" title="PathView implementation.">IO</a> is the underlying <a class="el" href="namespace_a_z_1_1_i_o.html" title="PathView implementation.">IO</a> system and does not route through pack files. This should only be used by the pack system itself, or systems with similar needs that should be "blind" to packages and only see the real file system. </p>

</div>
</div>
<a id="ab69336bf9b02f2dd844886972e4ab4f9" name="ab69336bf9b02f2dd844886972e4ab4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69336bf9b02f2dd844886972e4ab4f9">&#9670;&#160;</a></span>GetInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html">FileIOBase</a> * AZ::IO::FileIOBase::GetInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html#ab69336bf9b02f2dd844886972e4ab4f9">GetInstance()</a> A utility function to get the one global instance of File <a class="el" href="namespace_a_z_1_1_i_o.html" title="PathView implementation.">IO</a> to use when talking to engine. returns an instance which is aware of concepts such as pak and loose files and can be used to interact with them. Note that the PAK system itself should not call GetInstance but instead should use the direct underlying <a class="el" href="namespace_a_z_1_1_i_o.html" title="PathView implementation.">IO</a> system using GetDirectInstance instead since otherwise an infinite loop will be caused. </p>

</div>
</div>
<a id="afd2574fb40dea49afa2f3ad30e7b51b3" name="afd2574fb40dea49afa2f3ad30e7b51b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2574fb40dea49afa2f3ad30e7b51b3">&#9670;&#160;</a></span>ModificationTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AZ::u64 AZ::IO::FileIOBase::ModificationTime </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>fileHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the only requirement on the ModTime functions is that it must be comparable with subsequent calls to the same function. there is no specific requirement that they be cross-platform or adhere to any standard, but they should still be comparable across sessions. </p>

</div>
</div>
<a id="ac1fe3fbe1a6f453d5a98a29fa2d4fe1b" name="ac1fe3fbe1a6f453d5a98a29fa2d4fe1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fe3fbe1a6f453d5a98a29fa2d4fe1b">&#9670;&#160;</a></span>Remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a> AZ::IO::FileIOBase::Remove </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove - erases a single file succeeds if the file didn't exist to begin with succeeds if the file did exist and we successfully erased it. fails if the file cannot be erased also fails if the specified filePath is actually a directory that exists (instead of a file) </p>

</div>
</div>
<a id="abb11bb0f628a9bb130be55458107c262" name="abb11bb0f628a9bb130be55458107c262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb11bb0f628a9bb130be55458107c262">&#9670;&#160;</a></span>Rename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_a_z_1_1_i_o_1_1_result.html">Result</a> AZ::IO::FileIOBase::Rename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>originalFilePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newFilePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>renames a file or directory name also fails if the file or directory cannot be found also succeeds if originalFilePath == newFilePath </p>

</div>
</div>
<a id="a4d8b4689b45dce88aa48f8583f9b4393" name="a4d8b4689b45dce88aa48f8583f9b4393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8b4689b45dce88aa48f8583f9b4393">&#9670;&#160;</a></span>ReplaceAlias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool AZ::IO::FileIOBase::ReplaceAlias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_i_o_1_1_basic_path.html">AZ::IO::FixedMaxPath</a> &amp;&#160;</td>
          <td class="paramname"><em>replacedAliasPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_i_o_1_1_path_view.html">AZ::IO::PathView</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ReplaceAliases - If the path starts with an ...@ alias it is substituted with the alias value otherwise the path is copied as is to the resolvedAlias path value returns true if the resulting path can fit within AZ::IO::FixedMaxPath buffer </p>

</div>
</div>
<a id="a9844a46310e0789d315c40f68efff60e" name="a9844a46310e0789d315c40f68efff60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9844a46310e0789d315c40f68efff60e">&#9670;&#160;</a></span>ResolvePath() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool AZ::IO::FileIOBase::ResolvePath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_i_o_1_1_basic_path.html">AZ::IO::FixedMaxPath</a> &amp;&#160;</td>
          <td class="paramname"><em>resolvedPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_i_o_1_1_path_view.html">AZ::IO::PathView</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ResolvePath - Replaces any @ aliases in the supplied path with their the resolved alias values Converts the path to an absolute path, and replaces path separators with unix slashes The resolved path is returned in as a FixedMaxPath, unless it is longer than MaxPathLength in which case a null optional is returned </p>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_mock_file_i_o_base.html#ad7978b34a1d0bdd5c8040eee086c3802">AZ::IO::MockFileIOBase</a>.</p>

</div>
</div>
<a id="a2bbae30792f2f0ca81a1ea46805d411b" name="a2bbae30792f2f0ca81a1ea46805d411b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbae30792f2f0ca81a1ea46805d411b">&#9670;&#160;</a></span>ResolvePath() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool AZ::IO::FileIOBase::ResolvePath </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>resolvedPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::u64&#160;</td>
          <td class="paramname"><em>resolvedPathSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ResolvePath - Replaces any aliases in path with their values and stores the result in resolvedPath, also ensures that the path is absolute NOTE: If the path does not start with an alias then the resolved value of the @products@ is used which has the effect of making the path relative to the @products@/ folder returns true if path was resolved, false otherwise note that all of the above file-finding and opening functions automatically resolve the path before operating so you should not need to call this except in very exceptional circumstances where you absolutely need to hit a physical file and don't want to use <a class="el" href="class_a_z_1_1_i_o_1_1_system_file.html">SystemFile</a> </p>

<p>Implemented in <a class="el" href="class_a_z_1_1_i_o_1_1_mock_file_i_o_base.html#a0615269d94b89c6e6cebdb7fc97e6ba5">AZ::IO::MockFileIOBase</a>.</p>

</div>
</div>
<a id="aac1468946d7eac349fc53a078fdf6ca4" name="aac1468946d7eac349fc53a078fdf6ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1468946d7eac349fc53a078fdf6ca4">&#9670;&#160;</a></span>SetDeprecatedAlias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AZ::IO::FileIOBase::SetDeprecatedAlias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>&#160;</td>
          <td class="paramname"><em>oldAlias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>&#160;</td>
          <td class="paramname"><em>newAlias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>SetDeprecateAlias - Adds a deprecated alias with path resolution which points to a new alias When the DeprecatedAlias is used an Error is logged and the alias is resolved to the path specified by the new alais </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Code/Framework/AzCore/AzCore/IO/FileIO.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><a class="el" href="namespace_a_z_1_1_i_o.html">IO</a></li><li class="navelem"><a class="el" href="class_a_z_1_1_i_o_1_1_file_i_o_base.html">FileIOBase</a></li>
    <li class="footer">Generated on Mon Oct 9 2023 13:38:46 for Open 3D Engine AzCore API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
