<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine AzCore API Reference: AZ::EBusTraits Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Open 3D Engine AzCore API Reference<span id="projectnumber">&#160;23.10.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('struct_a_z_1_1_e_bus_traits.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="struct_a_z_1_1_e_bus_traits-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AZ::EBusTraits Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;EBus.h&gt;</code></p>

<p>Inherited by <a class="el" href="class_a_z_1_1_asset_type_info.html">AZ::AssetTypeInfo</a>, <a class="el" href="class_a_z_1_1_behavior_context_events.html">AZ::BehaviorContextEvents</a>, <a class="el" href="class_a_z_1_1_behavior_object_signals_interface.html">AZ::BehaviorObjectSignalsInterface</a>, <a class="el" href="class_a_z_1_1_component_application_requests_e_bus_traits.html">AZ::ComponentApplicationRequestsEBusTraits</a>, <a class="el" href="class_a_z_1_1_component_bus.html">AZ::ComponentBus</a>, <a class="el" href="struct_a_z_1_1_component_descriptor_bus_traits.html">AZ::ComponentDescriptorBusTraits</a>, <a class="el" href="class_a_z_1_1_data_1_1_asset_catalog_requests.html">AZ::Data::AssetCatalogRequests</a>, <a class="el" href="class_a_z_1_1_data_1_1_asset_events.html">AZ::Data::AssetEvents</a>, <a class="el" href="class_a_z_1_1_data_1_1_asset_load_events.html">AZ::Data::AssetLoadEvents</a>, <a class="el" href="class_a_z_1_1_data_1_1_asset_manager_events.html">AZ::Data::AssetManagerEvents</a>, <a class="el" href="class_a_z_1_1_data_1_1_asset_manager_notifications.html">AZ::Data::AssetManagerNotifications</a>, <a class="el" href="class_a_z_1_1_data_overlay_instance_msgs.html">AZ::DataOverlayInstanceMsgs</a>, <a class="el" href="class_a_z_1_1_data_overlay_provider_msgs.html">AZ::DataOverlayProviderMsgs</a>, <a class="el" href="class_a_z_1_1_data_patch_notifications.html">AZ::DataPatchNotifications</a>, <a class="el" href="class_a_z_1_1_debug_1_1_profiler_notifications.html">AZ::Debug::ProfilerNotifications</a>, <a class="el" href="class_a_z_1_1_debug_1_1_trace_message_events.html">AZ::Debug::TraceMessageEvents</a>, <a class="el" href="struct_a_z_1_1_e_bus_shared_dispatch_traits.html">AZ::EBusSharedDispatchTraits&lt; BusType &gt;</a>, <a class="el" href="class_a_z_1_1_entity_system_events.html">AZ::EntitySystemEvents</a>, <a class="el" href="class_a_z_1_1_i_event_scheduler_requests.html">AZ::IEventSchedulerRequests</a>, <a class="el" href="class_a_z_1_1_i_logger_requests.html">AZ::ILoggerRequests</a>, <a class="el" href="class_a_z_1_1_i_o_1_1_compression.html">AZ::IO::Compression</a>, <a class="el" href="class_a_z_1_1_i_time_requests.html">AZ::ITimeRequests</a>, <a class="el" href="class_a_z_1_1_job_manager_events.html">AZ::JobManagerEvents</a>, <a class="el" href="class_a_z_1_1_module_manager_requests.html">AZ::ModuleManagerRequests</a>, <a class="el" href="class_a_z_1_1_native_u_i_1_1_native_u_i_e_bus_traits.html">AZ::NativeUI::NativeUIEBusTraits</a>, <a class="el" href="class_a_z_1_1_script_property_watcher_interface.html">AZ::ScriptPropertyWatcherInterface</a>, <a class="el" href="class_a_z_1_1_script_system_requests.html">AZ::ScriptSystemRequests</a>, <a class="el" href="class_a_z_1_1_slice_asset_serialization_notifications.html">AZ::SliceAssetSerializationNotifications</a>, <a class="el" href="class_a_z_1_1_slice_events.html">AZ::SliceEvents</a>, <a class="el" href="class_a_z_1_1_slice_instance_events.html">AZ::SliceInstanceEvents</a>, <a class="el" href="class_a_z_1_1_system_tick_events.html">AZ::SystemTickEvents</a>, <a class="el" href="class_a_z_1_1_tick_events.html">AZ::TickEvents</a>, <a class="el" href="class_a_z_1_1_tick_requests.html">AZ::TickRequests</a>, <a class="el" href="class_a_z_1_1_user_settings_component_requests.html">AZ::UserSettingsComponentRequests</a>, <a class="el" href="class_a_z_1_1_user_settings_file_locator.html">AZ::UserSettingsFileLocator</a>, <a class="el" href="class_a_z_1_1_user_settings_messages.html">AZ::UserSettingsMessages</a>, <a class="el" href="class_a_z_1_1_user_settings_notifications.html">AZ::UserSettingsNotifications</a>, <a class="el" href="class_a_z_1_1_user_settings_owner_requests.html">AZ::UserSettingsOwnerRequests</a>, and <a class="el" href="class_a_z_std_1_1_thread_events.html">AZStd::ThreadEvents</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7d18a8cf116a63f6f1a2a39089651aac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#a7d18a8cf116a63f6f1a2a39089651aac">AllocatorType</a> = <a class="el" href="class_a_z_std_1_1stateless__allocator.html">AZ::Internal::EBusEnvironmentAllocator</a></td></tr>
<tr class="separator:a7d18a8cf116a63f6f1a2a39089651aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9445433422a226bf6ca92d06e74835f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#ac9445433422a226bf6ca92d06e74835f">BusIdType</a> = <a class="el" href="struct_a_z_1_1_null_bus_id.html">NullBusId</a></td></tr>
<tr class="separator:ac9445433422a226bf6ca92d06e74835f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5cc9acf15e838b810d9371aa6b858e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#a6a5cc9acf15e838b810d9371aa6b858e">BusIdOrderCompare</a> = NullBusIdCompare</td></tr>
<tr class="separator:a6a5cc9acf15e838b810d9371aa6b858e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13c49e6f838b6fa71f762b1a5ec95e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#af13c49e6f838b6fa71f762b1a5ec95e6">BusHandlerOrderCompare</a> = BusHandlerCompareDefault</td></tr>
<tr class="separator:af13c49e6f838b6fa71f762b1a5ec95e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7caac0bc5f090561541f1ecf359040c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#af7caac0bc5f090561541f1ecf359040c">MutexType</a> = <a class="el" href="struct_a_z_1_1_null_mutex.html">NullMutex</a></td></tr>
<tr class="separator:af7caac0bc5f090561541f1ecf359040c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29d85afa3eba414331c9399eba61db7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#ae29d85afa3eba414331c9399eba61db7">EventQueueMutexType</a> = <a class="el" href="struct_a_z_1_1_null_mutex.html">NullMutex</a></td></tr>
<tr class="separator:ae29d85afa3eba414331c9399eba61db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa769c4108d542aa0dc5f5555b7588838"><td class="memTemplParams" colspan="2">template&lt;class Bus &gt; </td></tr>
<tr class="memitem:aa769c4108d542aa0dc5f5555b7588838"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#aa769c4108d542aa0dc5f5555b7588838">ConnectionPolicy</a> = <a class="el" href="struct_a_z_1_1_e_bus_connection_policy.html">EBusConnectionPolicy</a>&lt; Bus &gt;</td></tr>
<tr class="separator:aa769c4108d542aa0dc5f5555b7588838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39014982cd56f0089dfa2df757565982"><td class="memTemplParams" colspan="2">template&lt;class Context &gt; </td></tr>
<tr class="memitem:a39014982cd56f0089dfa2df757565982"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#a39014982cd56f0089dfa2df757565982">StoragePolicy</a> = <a class="el" href="struct_a_z_1_1_e_bus_environment_storage_policy.html">EBusEnvironmentStoragePolicy</a>&lt; Context &gt;</td></tr>
<tr class="separator:a39014982cd56f0089dfa2df757565982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd01ca86374f2359f691cdc496269315"><td class="memTemplParams" colspan="2">template&lt;class Bus &gt; </td></tr>
<tr class="memitem:acd01ca86374f2359f691cdc496269315"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#acd01ca86374f2359f691cdc496269315">RouterPolicy</a> = EBusRouterPolicy&lt; Bus &gt;</td></tr>
<tr class="separator:acd01ca86374f2359f691cdc496269315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e2728bcd1004fe8f1959350d55ab8f"><td class="memItemLeft" align="right" valign="top"><a id="a26e2728bcd1004fe8f1959350d55ab8f" name="a26e2728bcd1004fe8f1959350d55ab8f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EventProcessingPolicy</b> = <a class="el" href="struct_a_z_1_1_e_bus_event_processing_policy.html">EBusEventProcessingPolicy</a></td></tr>
<tr class="separator:a26e2728bcd1004fe8f1959350d55ab8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a111142fb7527a57987841927b4113"><td class="memTemplParams" colspan="2">template&lt;typename DispatchMutex , bool IsLocklessDispatch&gt; </td></tr>
<tr class="memitem:ae1a111142fb7527a57987841927b4113"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#ae1a111142fb7527a57987841927b4113">DispatchLockGuard</a> = AZStd::conditional_t&lt; IsLocklessDispatch, AZ::Internal::NullLockGuard&lt; DispatchMutex &gt;, <a class="el" href="class_a_z_std_1_1scoped__lock.html">AZStd::scoped_lock</a>&lt; DispatchMutex &gt; &gt;</td></tr>
<tr class="separator:ae1a111142fb7527a57987841927b4113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54035b6bc2b36202fd17aa9a72d6685c"><td class="memTemplParams" colspan="2">template&lt;typename ContextMutex &gt; </td></tr>
<tr class="memitem:a54035b6bc2b36202fd17aa9a72d6685c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#a54035b6bc2b36202fd17aa9a72d6685c">ConnectLockGuard</a> = AZStd::conditional_t&lt; AZStd::is_same_v&lt; ContextMutex, <a class="el" href="struct_a_z_1_1_null_mutex.html">AZ::NullMutex</a> &gt;, AZ::Internal::NullLockGuard&lt; ContextMutex &gt;, <a class="el" href="class_a_z_std_1_1unique__lock.html">AZStd::unique_lock</a>&lt; ContextMutex &gt; &gt;</td></tr>
<tr class="separator:a54035b6bc2b36202fd17aa9a72d6685c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6912736611ad7aeec68dec2cd0dcc312"><td class="memTemplParams" colspan="2">template&lt;typename ContextMutex &gt; </td></tr>
<tr class="memitem:a6912736611ad7aeec68dec2cd0dcc312"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#a6912736611ad7aeec68dec2cd0dcc312">BindLockGuard</a> = <a class="el" href="class_a_z_std_1_1scoped__lock.html">AZStd::scoped_lock</a>&lt; ContextMutex &gt;</td></tr>
<tr class="separator:a6912736611ad7aeec68dec2cd0dcc312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1b22884b906be6714741ffb4f00f5f"><td class="memTemplParams" colspan="2">template&lt;typename ContextMutex &gt; </td></tr>
<tr class="memitem:a7f1b22884b906be6714741ffb4f00f5f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#a7f1b22884b906be6714741ffb4f00f5f">CallstackTrackerLockGuard</a> = AZStd::conditional_t&lt; AZStd::is_same_v&lt; ContextMutex, <a class="el" href="struct_a_z_1_1_null_mutex.html">AZ::NullMutex</a> &gt;, AZ::Internal::NullLockGuard&lt; ContextMutex &gt;, <a class="el" href="class_a_z_std_1_1unique__lock.html">AZStd::unique_lock</a>&lt; ContextMutex &gt; &gt;</td></tr>
<tr class="separator:a7f1b22884b906be6714741ffb4f00f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5d46cb1c8cb6e0c4642175b610ed8163"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespace_a_z.html#a32ca3a3605e97c0cd07dbfa805bf3e82">EBusHandlerPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#a5d46cb1c8cb6e0c4642175b610ed8163">HandlerPolicy</a> = <a class="el" href="namespace_a_z.html#a32ca3a3605e97c0cd07dbfa805bf3e82aa0bf169f2539e893e00d7b1296bc4d8e">EBusHandlerPolicy::Multiple</a></td></tr>
<tr class="separator:a5d46cb1c8cb6e0c4642175b610ed8163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e0f785ae096b8e7b344cc51b1f1bf4"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873">EBusAddressPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#a04e0f785ae096b8e7b344cc51b1f1bf4">AddressPolicy</a> = <a class="el" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873a66ba162102bbf6ae31b522aec561735e">EBusAddressPolicy::Single</a></td></tr>
<tr class="separator:a04e0f785ae096b8e7b344cc51b1f1bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028e63d906349155be1a0bfced09adf0"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#a028e63d906349155be1a0bfced09adf0">EnableEventQueue</a> = false</td></tr>
<tr class="separator:a028e63d906349155be1a0bfced09adf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebed35954e0ffb0dd0d7ede44459055"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#a3ebed35954e0ffb0dd0d7ede44459055">EventQueueingActiveByDefault</a> = true</td></tr>
<tr class="separator:a3ebed35954e0ffb0dd0d7ede44459055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d70dd4df65b01bccb09271e409be9a"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#ac2d70dd4df65b01bccb09271e409be9a">EnableQueuedReferences</a> = false</td></tr>
<tr class="separator:ac2d70dd4df65b01bccb09271e409be9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3213277ff6f61b1476e0f67ec95622"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#a8a3213277ff6f61b1476e0f67ec95622">LocklessDispatch</a> = false</td></tr>
<tr class="separator:a8a3213277ff6f61b1476e0f67ec95622"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab28df8aaec278ff471e7b5bd943cdc17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_e_bus_traits.html#ab28df8aaec278ff471e7b5bd943cdc17">~EBusTraits</a> ()=default</td></tr>
<tr class="separator:ab28df8aaec278ff471e7b5bd943cdc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>EBusTraits are properties that you use to configure an <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a>.</p>
<p>The key EBusTraits to understand are <a class="el" href="struct_a_z_1_1_e_bus_traits.html#a04e0f785ae096b8e7b344cc51b1f1bf4">AddressPolicy</a>, which defines how many addresses the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> contains, <a class="el" href="struct_a_z_1_1_e_bus_traits.html#a5d46cb1c8cb6e0c4642175b610ed8163">HandlerPolicy</a>, which describes how many handlers can connect to each address, and <code>BusIdType</code>, which is the type of ID that is used to address the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> if addresses are used.</p>
<p>For example, if you want an <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> that makes requests of game objects that each have a unique integer identifier, then define an <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> with the following traits: </p><div class="fragment"><div class="line"><span class="comment">// The EBus has multiple addresses and each event is addressed to a</span></div>
<div class="line"><span class="comment">// specific ID (the game object&#39;s ID), which corresponds to an address</span></div>
<div class="line"><span class="comment">// on the bus.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_enumeration" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873">EBusAddressPolicy</a> <a class="code hl_variable" href="struct_a_z_1_1_e_bus_traits.html#a04e0f785ae096b8e7b344cc51b1f1bf4">AddressPolicy</a> = <a class="code hl_enumvalue" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873adb4f7ff88b3cc15c6c585c284600a3dd">EBusAddressPolicy::ById</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Each event is received by a single handler (the game object).</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_enumeration" href="namespace_a_z.html#a32ca3a3605e97c0cd07dbfa805bf3e82">EBusHandlerPolicy</a> <a class="code hl_variable" href="struct_a_z_1_1_e_bus_traits.html#a5d46cb1c8cb6e0c4642175b610ed8163">HandlerPolicy</a> = <a class="code hl_enumvalue" href="namespace_a_z.html#a32ca3a3605e97c0cd07dbfa805bf3e82a66ba162102bbf6ae31b522aec561735e">EBusHandlerPolicy::Single</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Events are addressed by this type of ID (the game object&#39;s ID).</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_struct" href="struct_a_z_1_1_null_bus_id.html">BusIdType</a> = int;</div>
<div class="ttc" id="anamespace_a_z_html_a32ca3a3605e97c0cd07dbfa805bf3e82"><div class="ttname"><a href="namespace_a_z.html#a32ca3a3605e97c0cd07dbfa805bf3e82">AZ::EBusHandlerPolicy</a></div><div class="ttdeci">EBusHandlerPolicy</div><div class="ttdef"><b>Definition:</b> Policies.h:64</div></div>
<div class="ttc" id="anamespace_a_z_html_a32ca3a3605e97c0cd07dbfa805bf3e82a66ba162102bbf6ae31b522aec561735e"><div class="ttname"><a href="namespace_a_z.html#a32ca3a3605e97c0cd07dbfa805bf3e82a66ba162102bbf6ae31b522aec561735e">AZ::EBusHandlerPolicy::Single</a></div><div class="ttdeci">@ Single</div></div>
<div class="ttc" id="anamespace_a_z_html_abd62fbe2e48ab376e0cce1a0ff0ea873"><div class="ttname"><a href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873">AZ::EBusAddressPolicy</a></div><div class="ttdeci">EBusAddressPolicy</div><div class="ttdef"><b>Definition:</b> Policies.h:30</div></div>
<div class="ttc" id="anamespace_a_z_html_abd62fbe2e48ab376e0cce1a0ff0ea873adb4f7ff88b3cc15c6c585c284600a3dd"><div class="ttname"><a href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873adb4f7ff88b3cc15c6c585c284600a3dd">AZ::EBusAddressPolicy::ById</a></div><div class="ttdeci">@ ById</div></div>
<div class="ttc" id="astruct_a_z_1_1_e_bus_traits_html_a04e0f785ae096b8e7b344cc51b1f1bf4"><div class="ttname"><a href="struct_a_z_1_1_e_bus_traits.html#a04e0f785ae096b8e7b344cc51b1f1bf4">AZ::EBusTraits::AddressPolicy</a></div><div class="ttdeci">static constexpr EBusAddressPolicy AddressPolicy</div><div class="ttdef"><b>Definition:</b> EBus.h:104</div></div>
<div class="ttc" id="astruct_a_z_1_1_e_bus_traits_html_a5d46cb1c8cb6e0c4642175b610ed8163"><div class="ttname"><a href="struct_a_z_1_1_e_bus_traits.html#a5d46cb1c8cb6e0c4642175b610ed8163">AZ::EBusTraits::HandlerPolicy</a></div><div class="ttdeci">static constexpr EBusHandlerPolicy HandlerPolicy</div><div class="ttdef"><b>Definition:</b> EBus.h:97</div></div>
<div class="ttc" id="astruct_a_z_1_1_null_bus_id_html"><div class="ttname"><a href="struct_a_z_1_1_null_bus_id.html">AZ::NullBusId</a></div><div class="ttdef"><b>Definition:</b> BusImpl.h:53</div></div>
</div><!-- fragment --><p>For more information about EBuses, see <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> in this guide and <a href="https://o3de.org/docs/user-guide/engine/ebus/">Event Bus</a> in the <em>Open 3D Engine Developer Guide</em>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7d18a8cf116a63f6f1a2a39089651aac" name="a7d18a8cf116a63f6f1a2a39089651aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d18a8cf116a63f6f1a2a39089651aac">&#9670;&#160;</a></span>AllocatorType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_a_z_1_1_e_bus_traits.html#a7d18a8cf116a63f6f1a2a39089651aac">AZ::EBusTraits::AllocatorType</a> =  <a class="el" href="class_a_z_std_1_1stateless__allocator.html">AZ::Internal::EBusEnvironmentAllocator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocator used by the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a>. The default setting is Internal EBusEnvironmentAllocator <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> code stores their Context instances in static memory Therfore the configured allocator must last as long as the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> in a module </p>

</div>
</div>
<a id="a6912736611ad7aeec68dec2cd0dcc312" name="a6912736611ad7aeec68dec2cd0dcc312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6912736611ad7aeec68dec2cd0dcc312">&#9670;&#160;</a></span>BindLockGuard</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContextMutex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_a_z_1_1_e_bus_traits.html#a6912736611ad7aeec68dec2cd0dcc312">AZ::EBusTraits::BindLockGuard</a> =  <a class="el" href="class_a_z_std_1_1scoped__lock.html">AZStd::scoped_lock</a>&lt;ContextMutex&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template Lock Guard class to use for <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> bind calls. By default it will use a scoped_lock. This can be overridden to provide a different locking policy with custom <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> MutexType settings. </p>

</div>
</div>
<a id="af13c49e6f838b6fa71f762b1a5ec95e6" name="af13c49e6f838b6fa71f762b1a5ec95e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13c49e6f838b6fa71f762b1a5ec95e6">&#9670;&#160;</a></span>BusHandlerOrderCompare</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_a_z_1_1_e_bus_traits.html#af13c49e6f838b6fa71f762b1a5ec95e6">AZ::EBusTraits::BusHandlerOrderCompare</a> =  BusHandlerCompareDefault</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorting function for <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> event handlers. Used only when the <a class="el" href="struct_a_z_1_1_e_bus_traits.html#a5d46cb1c8cb6e0c4642175b610ed8163">HandlerPolicy</a> is <a class="el" href="namespace_a_z.html#a32ca3a3605e97c0cd07dbfa805bf3e82a681193d21a822afaec71e55004ea5b9c">AZ::EBusHandlerPolicy::MultipleAndOrdered</a>. This function determines the order in which handlers at an address receive an event.</p>
<p>By default, the function requires the handler to implement the following comparison function. </p><div class="fragment"><div class="line"><span class="comment">// Returns whether &#39;this&#39; should precede &#39;other&#39;.</span></div>
<div class="line"><span class="keywordtype">bool</span> Compare(<span class="keyword">const</span> <a class="code hl_class" href="class_a_z_1_1_interface.html">Interface</a>* other) <span class="keyword">const</span>;</div>
<div class="ttc" id="aclass_a_z_1_1_interface_html"><div class="ttname"><a href="class_a_z_1_1_interface.html">AZ::Interface</a></div><div class="ttdef"><b>Definition:</b> Interface.h:62</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6a5cc9acf15e838b810d9371aa6b858e" name="a6a5cc9acf15e838b810d9371aa6b858e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5cc9acf15e838b810d9371aa6b858e">&#9670;&#160;</a></span>BusIdOrderCompare</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_a_z_1_1_e_bus_traits.html#a6a5cc9acf15e838b810d9371aa6b858e">AZ::EBusTraits::BusIdOrderCompare</a> =  NullBusIdCompare</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorting function for <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> address IDs. Used only when the <a class="el" href="struct_a_z_1_1_e_bus_traits.html#a04e0f785ae096b8e7b344cc51b1f1bf4">AddressPolicy</a> is <a class="el" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873a55b30499fbf765bf728b168a1bf36410">AZ::EBusAddressPolicy::ByIdAndOrdered</a>. If an event is dispatched without an ID, this function determines the order in which each address receives the event.</p>
<p>The following example shows a sorting function that meets these requirements. </p><div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="struct_a_z_1_1_e_bus_traits.html#a6a5cc9acf15e838b810d9371aa6b858e">BusIdOrderCompare</a> = <a class="code hl_struct" href="struct_a_z_std_1_1less.html">AZStd::less&lt;BusIdType&gt;</a>; <span class="comment">// Lesser IDs first.</span></div>
<div class="ttc" id="astruct_a_z_1_1_e_bus_traits_html_a6a5cc9acf15e838b810d9371aa6b858e"><div class="ttname"><a href="struct_a_z_1_1_e_bus_traits.html#a6a5cc9acf15e838b810d9371aa6b858e">AZ::EBusTraits::BusIdOrderCompare</a></div><div class="ttdeci">NullBusIdCompare BusIdOrderCompare</div><div class="ttdef"><b>Definition:</b> EBus.h:126</div></div>
<div class="ttc" id="astruct_a_z_std_1_1less_html"><div class="ttname"><a href="struct_a_z_std_1_1less.html">AZStd::less</a></div><div class="ttdef"><b>Definition:</b> functional_basic.h:179</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac9445433422a226bf6ca92d06e74835f" name="ac9445433422a226bf6ca92d06e74835f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9445433422a226bf6ca92d06e74835f">&#9670;&#160;</a></span>BusIdType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_a_z_1_1_e_bus_traits.html#ac9445433422a226bf6ca92d06e74835f">AZ::EBusTraits::BusIdType</a> =  <a class="el" href="struct_a_z_1_1_null_bus_id.html">NullBusId</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of ID that is used to address the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a>. Used only when the <a class="el" href="struct_a_z_1_1_e_bus_traits.html#a04e0f785ae096b8e7b344cc51b1f1bf4">AddressPolicy</a> is <a class="el" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873adb4f7ff88b3cc15c6c585c284600a3dd">AZ::EBusAddressPolicy::ById</a> or <a class="el" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873a55b30499fbf765bf728b168a1bf36410">AZ::EBusAddressPolicy::ByIdAndOrdered</a>. The type must support <code><a class="el" href="struct_a_z_std_1_1hash.html" title="Default template (just try to cast the value to size_t)">AZStd::hash</a>&lt;ID&gt;</code> and <code>bool operator==(const ID&amp;, const ID&amp;)</code>. </p>

</div>
</div>
<a id="a7f1b22884b906be6714741ffb4f00f5f" name="a7f1b22884b906be6714741ffb4f00f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1b22884b906be6714741ffb4f00f5f">&#9670;&#160;</a></span>CallstackTrackerLockGuard</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContextMutex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_a_z_1_1_e_bus_traits.html#a7f1b22884b906be6714741ffb4f00f5f">AZ::EBusTraits::CallstackTrackerLockGuard</a> =  AZStd::conditional_t&lt; AZStd::is_same_v&lt;ContextMutex, <a class="el" href="struct_a_z_1_1_null_mutex.html">AZ::NullMutex</a>&gt;, AZ::Internal::NullLockGuard&lt;ContextMutex&gt;, <a class="el" href="class_a_z_std_1_1unique__lock.html">AZStd::unique_lock</a>&lt;ContextMutex&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template Lock Guard class to use for <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> callstack tracking. By default it will use a unique_lock if the ContextMutex is anything but a <a class="el" href="struct_a_z_1_1_null_mutex.html">NullMutex</a>. This can be overridden to provide a different locking policy with custom <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> MutexType settings. </p>

</div>
</div>
<a id="aa769c4108d542aa0dc5f5555b7588838" name="aa769c4108d542aa0dc5f5555b7588838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa769c4108d542aa0dc5f5555b7588838">&#9670;&#160;</a></span>ConnectionPolicy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Bus &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_a_z_1_1_e_bus_traits.html#aa769c4108d542aa0dc5f5555b7588838">AZ::EBusTraits::ConnectionPolicy</a> =  <a class="el" href="struct_a_z_1_1_e_bus_connection_policy.html">EBusConnectionPolicy</a>&lt;Bus&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables custom logic to run when a handler connects or disconnects from the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a>. For example, you can make a handler execute an event immediately upon connecting to the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> by modifying the <a class="el" href="struct_a_z_1_1_e_bus_connection_policy.html">EBusConnectionPolicy</a> of the bus. By default, no extra logic is run. </p>

</div>
</div>
<a id="a54035b6bc2b36202fd17aa9a72d6685c" name="a54035b6bc2b36202fd17aa9a72d6685c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54035b6bc2b36202fd17aa9a72d6685c">&#9670;&#160;</a></span>ConnectLockGuard</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContextMutex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_a_z_1_1_e_bus_traits.html#a54035b6bc2b36202fd17aa9a72d6685c">AZ::EBusTraits::ConnectLockGuard</a> =  AZStd::conditional_t&lt; AZStd::is_same_v&lt;ContextMutex, <a class="el" href="struct_a_z_1_1_null_mutex.html">AZ::NullMutex</a>&gt;, AZ::Internal::NullLockGuard&lt;ContextMutex&gt;, <a class="el" href="class_a_z_std_1_1unique__lock.html">AZStd::unique_lock</a>&lt;ContextMutex&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template Lock Guard class to use during connection / disconnection. By default it will use a unique_lock if the ContextMutex is anything but a <a class="el" href="struct_a_z_1_1_null_mutex.html">NullMutex</a>. This can be overridden to provide a different locking policy with custom <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> MutexType settings. Also, some specialized policies execute handler methods which can cause unnecessary delays holding the context mutex, such as performing blocking waits. These methods must unlock the context mutex before doing so to prevent deadlocks, especially when the wait is for an event in another thread which is trying to connect to the same bus before it can complete. </p>

</div>
</div>
<a id="ae1a111142fb7527a57987841927b4113" name="ae1a111142fb7527a57987841927b4113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a111142fb7527a57987841927b4113">&#9670;&#160;</a></span>DispatchLockGuard</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DispatchMutex , bool IsLocklessDispatch&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_a_z_1_1_e_bus_traits.html#ae1a111142fb7527a57987841927b4113">AZ::EBusTraits::DispatchLockGuard</a> =  AZStd::conditional_t&lt;IsLocklessDispatch, AZ::Internal::NullLockGuard&lt;DispatchMutex&gt;, <a class="el" href="class_a_z_std_1_1scoped__lock.html">AZStd::scoped_lock</a>&lt;DispatchMutex&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The following Lock Guard classes are exposed so that it's possible to redefine them with custom lock/unlock functionality when using custom types for the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> MutexType. Template Lock Guard class to use during event dispatches. By default it will use a scoped_lock, but IsLocklessDispatch=true will cause it to use a NullLockGuard. The IsLocklessDispatch bool is there to defer evaluation of the LocklessDispatch constant Otherwise the value above in EBusTraits.h is always used and not the value that the derived trait class sets. </p>

</div>
</div>
<a id="ae29d85afa3eba414331c9399eba61db7" name="ae29d85afa3eba414331c9399eba61db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29d85afa3eba414331c9399eba61db7">&#9670;&#160;</a></span>EventQueueMutexType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_a_z_1_1_e_bus_traits.html#ae29d85afa3eba414331c9399eba61db7">AZ::EBusTraits::EventQueueMutexType</a> =  <a class="el" href="struct_a_z_1_1_null_mutex.html">NullMutex</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locking primitive that is used when adding and removing events from the queue. Not used for connection or event execution. Used only when <a class="el" href="struct_a_z_1_1_e_bus_traits.html#a028e63d906349155be1a0bfced09adf0">EnableEventQueue</a> is true. If left unspecified, it will use the <a class="el" href="struct_a_z_1_1_e_bus_traits.html#af7caac0bc5f090561541f1ecf359040c">MutexType</a>. </p>

</div>
</div>
<a id="af7caac0bc5f090561541f1ecf359040c" name="af7caac0bc5f090561541f1ecf359040c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7caac0bc5f090561541f1ecf359040c">&#9670;&#160;</a></span>MutexType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_a_z_1_1_e_bus_traits.html#af7caac0bc5f090561541f1ecf359040c">AZ::EBusTraits::MutexType</a> =  <a class="el" href="struct_a_z_1_1_null_mutex.html">NullMutex</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locking primitive that is used when connecting handlers to the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> or executing events. By default, all access is assumed to be single threaded and no locking occurs. For multithreaded access, specify a mutex of the following type.</p><ul>
<li>For simple multithreaded cases, use <a class="el" href="class_a_z_std_1_1mutex.html">AZStd::mutex</a>.</li>
<li>For multithreaded cases where an event handler sends a new event on the same bus or connects/disconnects while handling an event on the same bus, use <a class="el" href="class_a_z_std_1_1recursive__mutex.html">AZStd::recursive_mutex</a>.</li>
<li>For specialized multithreading cases, such as allowing events to execute in parallel with each other but not with connects / disconnects, use custom mutex types along with custom LockGuard policies to control the specific locking requirements for each mutex use case (connection, dispatch, binding, callstack tracking). </li>
</ul>

</div>
</div>
<a id="acd01ca86374f2359f691cdc496269315" name="acd01ca86374f2359f691cdc496269315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd01ca86374f2359f691cdc496269315">&#9670;&#160;</a></span>RouterPolicy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Bus &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_a_z_1_1_e_bus_traits.html#acd01ca86374f2359f691cdc496269315">AZ::EBusTraits::RouterPolicy</a> =  EBusRouterPolicy&lt;Bus&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls the flow of <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> events. Enables an event to be forwarded, and possibly stopped, before reaching the normal event handlers. Use cases for routing include tracing, debugging, and versioning an EBus. The default <code>EBusRouterPolicy</code> forwards the event to each connected <code>EBusRouterNode</code> before sending the event to the normal handlers. Each node can stop the event or let it continue. </p>

</div>
</div>
<a id="a39014982cd56f0089dfa2df757565982" name="a39014982cd56f0089dfa2df757565982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39014982cd56f0089dfa2df757565982">&#9670;&#160;</a></span>StoragePolicy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Context &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_a_z_1_1_e_bus_traits.html#a39014982cd56f0089dfa2df757565982">AZ::EBusTraits::StoragePolicy</a> =  <a class="el" href="struct_a_z_1_1_e_bus_environment_storage_policy.html">EBusEnvironmentStoragePolicy</a>&lt;Context&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies where <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> data is stored. This drives how many instances of this <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> exist at runtime. Available storage policies include the following:</p><ul>
<li>(Default) <a class="el" href="struct_a_z_1_1_e_bus_environment_storage_policy.html">EBusEnvironmentStoragePolicy</a> - EBus data is stored in the <a class="el" href="namespace_a_z_1_1_environment.html">AZ::Environment</a>. With this policy, a single EBus instance is shared across all modules (DLLs) that attach to the <a class="el" href="namespace_a_z_1_1_environment.html">AZ::Environment</a>. It also supports multiple <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> environments.</li>
<li><a class="el" href="struct_a_z_1_1_e_bus_global_storage_policy.html">EBusGlobalStoragePolicy</a> - EBus data is stored in a global static variable. With this policy, each module (DLL) has its own instance of the EBus.</li>
<li><a class="el" href="struct_a_z_1_1_e_bus_thread_local_storage_policy.html">EBusThreadLocalStoragePolicy</a> - EBus data is stored in a thread_local static variable. With this policy, each thread has its own instance of the EBus.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Make sure you carefully consider the implication of switching this policy. If your code use EBusEnvironments and your storage policy is not complaint in the best case you will cause contention and unintended communication across environments, separation is a goal of environments. In the worst case when you have listeners, you can receive messages when you environment is NOT active, potentially causing all kinds of havoc especially if you execute environments in parallel. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab28df8aaec278ff471e7b5bd943cdc17" name="ab28df8aaec278ff471e7b5bd943cdc17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28df8aaec278ff471e7b5bd943cdc17">&#9670;&#160;</a></span>~EBusTraits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AZ::EBusTraits::~EBusTraits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Note - the destructor is intentionally not virtual to avoid adding vtable overhead to every <a class="el" href="struct_a_z_1_1_e_bus_traits.html">EBusTraits</a> derived class. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a04e0f785ae096b8e7b344cc51b1f1bf4" name="a04e0f785ae096b8e7b344cc51b1f1bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e0f785ae096b8e7b344cc51b1f1bf4">&#9670;&#160;</a></span>AddressPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873">EBusAddressPolicy</a> AZ::EBusTraits::AddressPolicy = <a class="el" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873a66ba162102bbf6ae31b522aec561735e">EBusAddressPolicy::Single</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines how many addresses exist on the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a>. For available settings, see <a class="el" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873">AZ::EBusAddressPolicy</a>. By default, an <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> uses a single address. </p>

</div>
</div>
<a id="a028e63d906349155be1a0bfced09adf0" name="a028e63d906349155be1a0bfced09adf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028e63d906349155be1a0bfced09adf0">&#9670;&#160;</a></span>EnableEventQueue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool AZ::EBusTraits::EnableEventQueue = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specifies whether the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> supports an event queue. You can use the event queue to execute events at a later time. To execute the queued events, you must call <code>&lt;BusName&gt;::ExecuteQueuedEvents()</code>. By default, the event queue is disabled. </p>

</div>
</div>
<a id="ac2d70dd4df65b01bccb09271e409be9a" name="ac2d70dd4df65b01bccb09271e409be9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d70dd4df65b01bccb09271e409be9a">&#9670;&#160;</a></span>EnableQueuedReferences</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool AZ::EBusTraits::EnableQueuedReferences = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specifies whether the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> supports queueing functions which take reference arguments. This means that the sender is responsible for the lifetime of the arguments (they should be static or class members or otherwise persistently stored). You should only use this if you know that the data being passed as arguments will outlive the dispatch of the queued event. </p>

</div>
</div>
<a id="a3ebed35954e0ffb0dd0d7ede44459055" name="a3ebed35954e0ffb0dd0d7ede44459055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebed35954e0ffb0dd0d7ede44459055">&#9670;&#160;</a></span>EventQueueingActiveByDefault</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool AZ::EBusTraits::EventQueueingActiveByDefault = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specifies whether the bus should accept queued messages by default or not. If set to false, Bus::AllowFunctionQueuing(true) must be called before events are accepted. Used only when <a class="el" href="struct_a_z_1_1_e_bus_traits.html#a028e63d906349155be1a0bfced09adf0">EnableEventQueue</a> is true. </p>

</div>
</div>
<a id="a5d46cb1c8cb6e0c4642175b610ed8163" name="a5d46cb1c8cb6e0c4642175b610ed8163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d46cb1c8cb6e0c4642175b610ed8163">&#9670;&#160;</a></span>HandlerPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespace_a_z.html#a32ca3a3605e97c0cd07dbfa805bf3e82">EBusHandlerPolicy</a> AZ::EBusTraits::HandlerPolicy = <a class="el" href="namespace_a_z.html#a32ca3a3605e97c0cd07dbfa805bf3e82aa0bf169f2539e893e00d7b1296bc4d8e">EBusHandlerPolicy::Multiple</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines how many handlers can connect to an address on the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> and the order in which handlers at each address receive events. For available settings, see <a class="el" href="namespace_a_z.html#a32ca3a3605e97c0cd07dbfa805bf3e82">AZ::EBusHandlerPolicy</a>. By default, an <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> supports any number of handlers. </p>

</div>
</div>
<a id="a8a3213277ff6f61b1476e0f67ec95622" name="a8a3213277ff6f61b1476e0f67ec95622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3213277ff6f61b1476e0f67ec95622">&#9670;&#160;</a></span>LocklessDispatch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool AZ::EBusTraits::LocklessDispatch = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines whether the bus will lock during dispatch On buses where handlers are attached at startup and removed at shutdown, or where connect/disconnect are not done from within handlers, this is safe to do. By default, the standard policy is used, which locks around all dispatches </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Code/Framework/AzCore/AzCore/EBus/<a class="el" href="_e_bus_8h.html">EBus.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><a class="el" href="struct_a_z_1_1_e_bus_traits.html">EBusTraits</a></li>
    <li class="footer">Generated on Mon Oct 9 2023 13:38:45 for Open 3D Engine AzCore API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
