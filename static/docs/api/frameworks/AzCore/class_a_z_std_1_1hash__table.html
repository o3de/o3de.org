<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine AzCore API Reference: AZStd::hash_table&lt; Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Open 3D Engine AzCore API Reference<span id="projectnumber">&#160;23.10.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_a_z_std_1_1hash__table.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_a_z_std_1_1hash__table-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AZStd::hash_table&lt; Traits &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;hash_table.h&gt;</code></p>

<p>Inherited by <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; StringType, StringVector, AZStd::hash&lt; StringType &gt;, AZStd::equal_to&lt; StringType &gt;, StdAllocatorType &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::basic_string, AZ::BehaviorMethod * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::basic_string, AZ::BehaviorProperty * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::basic_string, AZ::BehaviorClass * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, AZ::BehaviorClass * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::basic_string, AZ::BehaviorEBus * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; const AZ::BehaviorMethod *, AZStd::pair&lt; const AZ::BehaviorMethod *, const AZ::BehaviorClass * &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::basic_string, AZ::BehaviorEBusEventSender &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::basic_string, AZ::BehaviorEBus::VirtualProperty &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; EntityId, Entity * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; CVarFixedString, AZStd::vector&lt; ConsoleFunctorBase * &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Data::AssetId, AZ::Data::Asset&lt; AssetData &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Data::AssetId, AZStd::unordered_set&lt; AZ::Data::AssetId &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AssetType, AssetHandler * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AssetType, AssetCatalog * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AssetId, AssetData * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AssetContainerKey, AZStd::weak_ptr&lt; AssetContainer &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AssetContainer *, AZStd::shared_ptr&lt; AssetContainer &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AssetId, Asset&lt; AssetData &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AssetId, AZStd::shared_ptr&lt; AssetDataStream &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; void *, AllocationInfo, AZStd::hash&lt; void * &gt;, AZStd::equal_to&lt; void * &gt;, AZStd::stateless_allocator &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::basic_string, AZ::Statistics::NamedRunningStatistic * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::basic_string, AZStd::chrono::steady_clock::time_point &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Dom::PathEntry, Node &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, Edit::ElementData &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Name, AZStd::weak_ptr&lt; AZ::InstancePoolBase &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; Uuid, AZStd::unique_ptr&lt; BaseJsonSerializer &gt;, AZStd::hash&lt; Uuid &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; Uuid, BaseJsonSerializer *, AZStd::hash&lt; Uuid &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, AZStd::any &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::OSString, AZStd::weak_ptr&lt; ModuleDataImpl &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; Name::Hash, ScopedNameDataWrapper &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; size_t, AZStd::vector&lt; const AZ::BehaviorParameter * &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, AZStd::weak_ptr&lt; Internal::ReflectionFunctionRef &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, EntryPointList::iterator &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; StaticReflectionFunctionPtr, EntryPointList::iterator &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; BreakpointId, Breakpoint, AZStd::hash&lt; BreakpointId &gt;, AZStd::equal_to&lt; BreakpointId &gt;, OSStdAllocator &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; T, MapValuePair &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; int, ScriptProperty * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Crc32, ScriptProperty * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, ScriptPropertyGenericClassMap * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, AZ::ScriptSystemComponent::LoadedScriptInfo &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, AZ::Data::Asset&lt; AZ::ScriptAsset &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; Uuid, ClassData &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, CreateAnyFunc &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, AZ::Uuid &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Crc32, DataPatchUpgradeMap &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, AZ::GenericClassInfo * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; EntityId, EntityInfo &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; Data::Asset&lt; SliceAsset &gt;, SliceReference::SliceInstances &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::EntityId, AZStd::unordered_map &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AddressType, Flags &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; EntityId, EntityId &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::string, AZ::Statistics::NamedRunningStatistic * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; StatisticalProfilerId, ProfilerInfo &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; StatIdType, AZ::Statistics::NamedRunningStatistic * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; uint32_t, AZStd::vector&lt; uint32_t &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::u32, AZStd::intrusive_ptr&lt; UserSettings &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__multimap.html">AZStd::unordered_multimap&lt; AZ::Data::AssetId, AZ::Data::AssetContainer * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__multimap.html">AZStd::unordered_multimap&lt; AssetId, WaitForAsset * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__multimap.html">AZStd::unordered_multimap&lt; AZ::IO::FileRequest *, AZ::IO::BlockCache::Section &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__multimap.html">AZStd::unordered_multimap&lt; AZ::Crc32, AZ::Uuid &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__multimap.html">AZStd::unordered_multimap&lt; AZ::Uuid, AZ::GenericClassInfo * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__multimap.html">AZStd::unordered_multimap&lt; AZ::Uuid, AZ::Uuid &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; AZ::IO::Path &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; AZStd::basic_string &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; AZ::ExplicitOverloadInfo &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; AZ::Data::AssetId &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; AZ::Uuid &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; size_t &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; AZ::SerializeContext::PerModuleGenericClassInfo * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; SerializeContext * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; SliceInstance &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; AZ::EntityId &gt;</a>, <a class="el" href="class_a_z_std_1_1fixed__unordered__map.html">AZStd::fixed_unordered_map&lt; Key, MappedType, FixedNumBuckets, FixedNumElements, Hasher, EqualKey &gt;</a>, <a class="el" href="class_a_z_std_1_1fixed__unordered__multimap.html">AZStd::fixed_unordered_multimap&lt; Key, MappedType, FixedNumBuckets, FixedNumElements, Hasher, EqualKey &gt;</a>, <a class="el" href="class_a_z_std_1_1fixed__unordered__multiset.html">AZStd::fixed_unordered_multiset&lt; Key, FixedNumBuckets, FixedNumElements, Hasher, EqualKey &gt;</a>, <a class="el" href="class_a_z_std_1_1fixed__unordered__set.html">AZStd::fixed_unordered_set&lt; Key, FixedNumBuckets, FixedNumElements, Hasher, EqualKey &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; Key, MappedType, Hasher, EqualKey, Allocator &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__multimap.html">AZStd::unordered_multimap&lt; Key, MappedType, Hasher, EqualKey, Allocator &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__multiset.html">AZStd::unordered_multiset&lt; Key, Hasher, EqualKey, Allocator &gt;</a>, and <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; Key, Hasher, EqualKey, Allocator &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_std_1_1hash__table_1_1_convert_from_value.html">ConvertFromValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae514a34963b5338c47eb74a171ac56d2"><td class="memItemLeft" align="right" valign="top"><a id="ae514a34963b5338c47eb74a171ac56d2" name="ae514a34963b5338c47eb74a171ac56d2"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><b>traits_type</b></td></tr>
<tr class="separator:ae514a34963b5338c47eb74a171ac56d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467c545861ace831af9d7d4a12a1fe94"><td class="memItemLeft" align="right" valign="top"><a id="a467c545861ace831af9d7d4a12a1fe94" name="a467c545861ace831af9d7d4a12a1fe94"></a>
typedef Traits::key_type&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr class="separator:a467c545861ace831af9d7d4a12a1fe94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d32532535e28543fddfe8fce6a768f8"><td class="memItemLeft" align="right" valign="top"><a id="a3d32532535e28543fddfe8fce6a768f8" name="a3d32532535e28543fddfe8fce6a768f8"></a>
typedef Traits::key_equal&#160;</td><td class="memItemRight" valign="bottom"><b>key_equal</b></td></tr>
<tr class="separator:a3d32532535e28543fddfe8fce6a768f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75f90127c3c4d7f574c52c392eb5fa5"><td class="memItemLeft" align="right" valign="top"><a id="ae75f90127c3c4d7f574c52c392eb5fa5" name="ae75f90127c3c4d7f574c52c392eb5fa5"></a>
typedef Traits::hasher&#160;</td><td class="memItemRight" valign="bottom"><b>hasher</b></td></tr>
<tr class="separator:ae75f90127c3c4d7f574c52c392eb5fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95de53dafaeaa5220f52ec9599cf13a"><td class="memItemLeft" align="right" valign="top"><a id="aa95de53dafaeaa5220f52ec9599cf13a" name="aa95de53dafaeaa5220f52ec9599cf13a"></a>
typedef Traits::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:aa95de53dafaeaa5220f52ec9599cf13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747afa8af49a1ccb3518fd05cf93cf6a"><td class="memItemLeft" align="right" valign="top"><a id="a747afa8af49a1ccb3518fd05cf93cf6a" name="a747afa8af49a1ccb3518fd05cf93cf6a"></a>
typedef <a class="el" href="class_a_z_std_1_1list.html">storage_type::list_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>list_type</b></td></tr>
<tr class="separator:a747afa8af49a1ccb3518fd05cf93cf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788464389632245c454b6caf6eaa6db8"><td class="memItemLeft" align="right" valign="top"><a id="a788464389632245c454b6caf6eaa6db8" name="a788464389632245c454b6caf6eaa6db8"></a>
typedef list_type::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a788464389632245c454b6caf6eaa6db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4039ad6cacd9efd7ef27a10bb5f30c"><td class="memItemLeft" align="right" valign="top"><a id="a7c4039ad6cacd9efd7ef27a10bb5f30c" name="a7c4039ad6cacd9efd7ef27a10bb5f30c"></a>
typedef list_type::difference_type&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a7c4039ad6cacd9efd7ef27a10bb5f30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6556231c4b0a1bdcdb71769d5ba28019"><td class="memItemLeft" align="right" valign="top"><a id="a6556231c4b0a1bdcdb71769d5ba28019" name="a6556231c4b0a1bdcdb71769d5ba28019"></a>
typedef list_type::pointer&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a6556231c4b0a1bdcdb71769d5ba28019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40efb5994041f0270586d596df31d56"><td class="memItemLeft" align="right" valign="top"><a id="af40efb5994041f0270586d596df31d56" name="af40efb5994041f0270586d596df31d56"></a>
typedef list_type::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:af40efb5994041f0270586d596df31d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277ac2d4eb19cdd439aa042d7b204362"><td class="memItemLeft" align="right" valign="top"><a id="a277ac2d4eb19cdd439aa042d7b204362" name="a277ac2d4eb19cdd439aa042d7b204362"></a>
typedef list_type::reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a277ac2d4eb19cdd439aa042d7b204362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39bff33131b5cf852e85ed099744a40"><td class="memItemLeft" align="right" valign="top"><a id="af39bff33131b5cf852e85ed099744a40" name="af39bff33131b5cf852e85ed099744a40"></a>
typedef list_type::const_reference&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:af39bff33131b5cf852e85ed099744a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae049dba5273781d99877c255904ae67a"><td class="memItemLeft" align="right" valign="top"><a id="ae049dba5273781d99877c255904ae67a" name="ae049dba5273781d99877c255904ae67a"></a>
typedef <a class="el" href="class_a_z_std_1_1list__iterator.html">list_type::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:ae049dba5273781d99877c255904ae67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835145080e2f46e25a44c9beadb1eeb4"><td class="memItemLeft" align="right" valign="top"><a id="a835145080e2f46e25a44c9beadb1eeb4" name="a835145080e2f46e25a44c9beadb1eeb4"></a>
typedef <a class="el" href="class_a_z_std_1_1basic__const__iterator.html">list_type::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a835145080e2f46e25a44c9beadb1eeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3094c12f8c0bb30eaf6dfe5fefb978"><td class="memItemLeft" align="right" valign="top"><a id="a9d3094c12f8c0bb30eaf6dfe5fefb978" name="a9d3094c12f8c0bb30eaf6dfe5fefb978"></a>
typedef list_type::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a9d3094c12f8c0bb30eaf6dfe5fefb978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7371bf82b01aa694db21a5959bbbc337"><td class="memItemLeft" align="right" valign="top"><a id="a7371bf82b01aa694db21a5959bbbc337" name="a7371bf82b01aa694db21a5959bbbc337"></a>
typedef list_type::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:a7371bf82b01aa694db21a5959bbbc337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574afbaeb075c01bf94666da2447eb03"><td class="memItemLeft" align="right" valign="top"><a id="a574afbaeb075c01bf94666da2447eb03" name="a574afbaeb075c01bf94666da2447eb03"></a>
typedef list_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a574afbaeb075c01bf94666da2447eb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8506013b4d82d9bfce1cef40b4e20de"><td class="memItemLeft" align="right" valign="top"><a id="ae8506013b4d82d9bfce1cef40b4e20de" name="ae8506013b4d82d9bfce1cef40b4e20de"></a>
typedef <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>local_iterator</b></td></tr>
<tr class="separator:ae8506013b4d82d9bfce1cef40b4e20de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35525d9d989d082fd20a388665441640"><td class="memItemLeft" align="right" valign="top"><a id="a35525d9d989d082fd20a388665441640" name="a35525d9d989d082fd20a388665441640"></a>
typedef <a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_local_iterator</b></td></tr>
<tr class="separator:a35525d9d989d082fd20a388665441640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee3a86acb84086dd7b05ccbf4bbc14e"><td class="memItemLeft" align="right" valign="top"><a id="aeee3a86acb84086dd7b05ccbf4bbc14e" name="aeee3a86acb84086dd7b05ccbf4bbc14e"></a>
typedef <a class="el" href="struct_a_z_std_1_1pair.html">storage_type::vector_value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vector_value_type</b></td></tr>
<tr class="separator:aeee3a86acb84086dd7b05ccbf4bbc14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f95099f823cc0c453a1ed4ec8b540e"><td class="memItemLeft" align="right" valign="top"><a id="a89f95099f823cc0c453a1ed4ec8b540e" name="a89f95099f823cc0c453a1ed4ec8b540e"></a>
typedef <a class="el" href="class_a_z_std_1_1vector.html">storage_type::vector_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vector_type</b></td></tr>
<tr class="separator:a89f95099f823cc0c453a1ed4ec8b540e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2751f8ec27a2ca3405deca04eb3906"><td class="memItemLeft" align="right" valign="top"><a id="ada2751f8ec27a2ca3405deca04eb3906" name="ada2751f8ec27a2ca3405deca04eb3906"></a>
typedef <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pair_iter_bool</b></td></tr>
<tr class="separator:ada2751f8ec27a2ca3405deca04eb3906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6992a794548538910a563ad64bc4cd54"><td class="memItemLeft" align="right" valign="top"><a id="a6992a794548538910a563ad64bc4cd54" name="a6992a794548538910a563ad64bc4cd54"></a>
typedef <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a>, <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pair_iter_iter</b></td></tr>
<tr class="separator:a6992a794548538910a563ad64bc4cd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc79bb58f166aed277888fa3902dd558"><td class="memItemLeft" align="right" valign="top"><a id="acc79bb58f166aed277888fa3902dd558" name="acc79bb58f166aed277888fa3902dd558"></a>
typedef <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a>, <a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pair_citer_citer</b></td></tr>
<tr class="separator:acc79bb58f166aed277888fa3902dd558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b769dd59dfc68faa76ee25a5a9f9ac"><td class="memItemLeft" align="right" valign="top"><a id="a72b769dd59dfc68faa76ee25a5a9f9ac" name="a72b769dd59dfc68faa76ee25a5a9f9ac"></a>
typedef list_type::node_type&#160;</td><td class="memItemRight" valign="bottom"><b>list_node_type</b></td></tr>
<tr class="separator:a72b769dd59dfc68faa76ee25a5a9f9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd92d9906545160fcbbb1b96047b862"><td class="memItemLeft" align="right" valign="top"><a id="a3bd92d9906545160fcbbb1b96047b862" name="a3bd92d9906545160fcbbb1b96047b862"></a>
typedef <a class="el" href="class_a_z_std_1_1vector.html#aff112f83ca769e2e80897653d8937cc1">vector_type::node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>vector_node_type</b></td></tr>
<tr class="separator:a3bd92d9906545160fcbbb1b96047b862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbde678dd96d10403f86ecfdcfc66df3"><td class="memItemLeft" align="right" valign="top"><a id="afbde678dd96d10403f86ecfdcfc66df3" name="afbde678dd96d10403f86ecfdcfc66df3"></a>
typedef <a class="el" href="class_a_z_std_1_1hash__node__destructor.html">hash_node_destructor</a>&lt; allocator_type, list_node_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>node_deleter</b></td></tr>
<tr class="separator:afbde678dd96d10403f86ecfdcfc66df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a25528d77f4b940fef0a60f47dc974210"><td class="memItemLeft" align="right" valign="top"><a id="a25528d77f4b940fef0a60f47dc974210" name="a25528d77f4b940fef0a60f47dc974210"></a>
AZ_FORCE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table</b> (const hasher &amp;<a class="el" href="struct_a_z_std_1_1hash.html">hash</a>, const key_equal &amp;keyEqual, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="separator:a25528d77f4b940fef0a60f47dc974210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fedcbf9d44d80b0643902f4ad1902f5"><td class="memItemLeft" align="right" valign="top"><a id="a1fedcbf9d44d80b0643902f4ad1902f5" name="a1fedcbf9d44d80b0643902f4ad1902f5"></a>
AZ_FORCE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table</b> (const value_type *first, const value_type *last, const hasher &amp;<a class="el" href="struct_a_z_std_1_1hash.html">hash</a>, const key_equal &amp;keyEqual, const allocator_type &amp;alloc)</td></tr>
<tr class="separator:a1fedcbf9d44d80b0643902f4ad1902f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610ef16e12172fe503e45564cb575212"><td class="memItemLeft" align="right" valign="top"><a id="a610ef16e12172fe503e45564cb575212" name="a610ef16e12172fe503e45564cb575212"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table</b> (const <a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a> &amp;rhs)</td></tr>
<tr class="separator:a610ef16e12172fe503e45564cb575212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d87b0e9af0baa430e1542fcc795b99"><td class="memItemLeft" align="right" valign="top"><a id="a51d87b0e9af0baa430e1542fcc795b99" name="a51d87b0e9af0baa430e1542fcc795b99"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table</b> (const <a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a> &amp;rhs, const type_identity_t&lt; allocator_type &gt; &amp;alloc)</td></tr>
<tr class="separator:a51d87b0e9af0baa430e1542fcc795b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbf4a6911b77f8f0d2b1946daa7758b"><td class="memItemLeft" align="right" valign="top"><a id="a9dbf4a6911b77f8f0d2b1946daa7758b" name="a9dbf4a6911b77f8f0d2b1946daa7758b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table</b> (<a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a9dbf4a6911b77f8f0d2b1946daa7758b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c425277974b194c567569f1bde34170"><td class="memItemLeft" align="right" valign="top"><a id="a5c425277974b194c567569f1bde34170" name="a5c425277974b194c567569f1bde34170"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table</b> (<a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a> &amp;&amp;rhs, const type_identity_t&lt; allocator_type &gt; &amp;alloc)</td></tr>
<tr class="separator:a5c425277974b194c567569f1bde34170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec32392afaf2f067a4ac2fdc021f21c"><td class="memItemLeft" align="right" valign="top"><a id="a5ec32392afaf2f067a4ac2fdc021f21c" name="a5ec32392afaf2f067a4ac2fdc021f21c"></a>
<a class="el" href="class_a_z_std_1_1hash__table.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_a_z_std_1_1hash__table.html">this_type</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a5ec32392afaf2f067a4ac2fdc021f21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cc8ffc951a16eca819cd3eae60e372"><td class="memItemLeft" align="right" valign="top"><a id="ab1cc8ffc951a16eca819cd3eae60e372" name="ab1cc8ffc951a16eca819cd3eae60e372"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1hash__table.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_a_z_std_1_1hash__table.html">this_type</a> &amp;rhs)</td></tr>
<tr class="separator:ab1cc8ffc951a16eca819cd3eae60e372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdf7be1fb3f1c02b24ffc9910a4cc7c"><td class="memItemLeft" align="right" valign="top"><a id="accdf7be1fb3f1c02b24ffc9910a4cc7c" name="accdf7be1fb3f1c02b24ffc9910a4cc7c"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:accdf7be1fb3f1c02b24ffc9910a4cc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18abd20fc45b19fb064ebab188d19216"><td class="memItemLeft" align="right" valign="top"><a id="a18abd20fc45b19fb064ebab188d19216" name="a18abd20fc45b19fb064ebab188d19216"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="separator:a18abd20fc45b19fb064ebab188d19216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4e9c17c5840a6ff2f6b6edae00d8b8"><td class="memItemLeft" align="right" valign="top"><a id="a0a4e9c17c5840a6ff2f6b6edae00d8b8" name="a0a4e9c17c5840a6ff2f6b6edae00d8b8"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:a0a4e9c17c5840a6ff2f6b6edae00d8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad742bc016131bb5a54e3f6026bbdf5fd"><td class="memItemLeft" align="right" valign="top"><a id="ad742bc016131bb5a54e3f6026bbdf5fd" name="ad742bc016131bb5a54e3f6026bbdf5fd"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="separator:ad742bc016131bb5a54e3f6026bbdf5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c2c7794ed33a862fc6639628d72cbd"><td class="memItemLeft" align="right" valign="top"><a id="a17c2c7794ed33a862fc6639628d72cbd" name="a17c2c7794ed33a862fc6639628d72cbd"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1list__iterator.html">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (size_type bucket)</td></tr>
<tr class="separator:a17c2c7794ed33a862fc6639628d72cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef861cfd275e946e5cf08c37e92b83e"><td class="memItemLeft" align="right" valign="top"><a id="abef861cfd275e946e5cf08c37e92b83e" name="abef861cfd275e946e5cf08c37e92b83e"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (size_type bucket) const</td></tr>
<tr class="separator:abef861cfd275e946e5cf08c37e92b83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b39ba9aa9def8e3eddfe6a3c1f2d7d"><td class="memItemLeft" align="right" valign="top"><a id="a80b39ba9aa9def8e3eddfe6a3c1f2d7d" name="a80b39ba9aa9def8e3eddfe6a3c1f2d7d"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1list__iterator.html">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (size_type bucket)</td></tr>
<tr class="separator:a80b39ba9aa9def8e3eddfe6a3c1f2d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedd02485766e7beb24e56cf94e32ae4"><td class="memItemLeft" align="right" valign="top"><a id="adedd02485766e7beb24e56cf94e32ae4" name="adedd02485766e7beb24e56cf94e32ae4"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (size_type bucket) const</td></tr>
<tr class="separator:adedd02485766e7beb24e56cf94e32ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd5d1ac0f8a234512d7feb2c94ef146"><td class="memItemLeft" align="right" valign="top"><a id="a2bd5d1ac0f8a234512d7feb2c94ef146" name="a2bd5d1ac0f8a234512d7feb2c94ef146"></a>
AZ_FORCE_INLINE reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> ()</td></tr>
<tr class="separator:a2bd5d1ac0f8a234512d7feb2c94ef146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1de3e0ceb86da69375e73567f042f6"><td class="memItemLeft" align="right" valign="top"><a id="a1e1de3e0ceb86da69375e73567f042f6" name="a1e1de3e0ceb86da69375e73567f042f6"></a>
AZ_FORCE_INLINE const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const</td></tr>
<tr class="separator:a1e1de3e0ceb86da69375e73567f042f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a07787db956ff915f26beb0cf1814a"><td class="memItemLeft" align="right" valign="top"><a id="a02a07787db956ff915f26beb0cf1814a" name="a02a07787db956ff915f26beb0cf1814a"></a>
AZ_FORCE_INLINE reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> ()</td></tr>
<tr class="separator:a02a07787db956ff915f26beb0cf1814a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121da265e50600e6a8f01ccb057189b4"><td class="memItemLeft" align="right" valign="top"><a id="a121da265e50600e6a8f01ccb057189b4" name="a121da265e50600e6a8f01ccb057189b4"></a>
AZ_FORCE_INLINE const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const</td></tr>
<tr class="separator:a121da265e50600e6a8f01ccb057189b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2ba5cf94f399a00e6caf94359e70bd"><td class="memItemLeft" align="right" valign="top"><a id="a7c2ba5cf94f399a00e6caf94359e70bd" name="a7c2ba5cf94f399a00e6caf94359e70bd"></a>
AZ_FORCE_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a7c2ba5cf94f399a00e6caf94359e70bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e9ac7fcbc1425636686df254290789"><td class="memItemLeft" align="right" valign="top"><a id="ab8e9ac7fcbc1425636686df254290789" name="ab8e9ac7fcbc1425636686df254290789"></a>
AZ_FORCE_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>max_size</b> () const</td></tr>
<tr class="separator:ab8e9ac7fcbc1425636686df254290789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5441cac208098d6955daa3c9cd124ee6"><td class="memItemLeft" align="right" valign="top"><a id="a5441cac208098d6955daa3c9cd124ee6" name="a5441cac208098d6955daa3c9cd124ee6"></a>
AZ_FORCE_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="separator:a5441cac208098d6955daa3c9cd124ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e9e44ca49878ee39c8eca4a995707e"><td class="memItemLeft" align="right" valign="top"><a id="a95e9e44ca49878ee39c8eca4a995707e" name="a95e9e44ca49878ee39c8eca4a995707e"></a>
AZ_FORCE_INLINE key_equal&#160;</td><td class="memItemRight" valign="bottom"><b>key_eq</b> () const</td></tr>
<tr class="separator:a95e9e44ca49878ee39c8eca4a995707e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2601c1af51c1f58ced2c2f33c4d853a"><td class="memItemLeft" align="right" valign="top"><a id="ad2601c1af51c1f58ced2c2f33c4d853a" name="ad2601c1af51c1f58ced2c2f33c4d853a"></a>
AZ_FORCE_INLINE hasher&#160;</td><td class="memItemRight" valign="bottom"><b>get_hasher</b> () const</td></tr>
<tr class="separator:ad2601c1af51c1f58ced2c2f33c4d853a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5611c6138af51cc18834d7a333331e"><td class="memItemLeft" align="right" valign="top"><a id="afc5611c6138af51cc18834d7a333331e" name="afc5611c6138af51cc18834d7a333331e"></a>
AZ_FORCE_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_count</b> () const</td></tr>
<tr class="separator:afc5611c6138af51cc18834d7a333331e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0251f264768c2dc6f4647bbcbfe0e08e"><td class="memItemLeft" align="right" valign="top"><a id="a0251f264768c2dc6f4647bbcbfe0e08e" name="a0251f264768c2dc6f4647bbcbfe0e08e"></a>
AZ_FORCE_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>max_bucket_count</b> () const</td></tr>
<tr class="separator:a0251f264768c2dc6f4647bbcbfe0e08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985b54c527de6cd3727a8abf371d0b35"><td class="memItemLeft" align="right" valign="top"><a id="a985b54c527de6cd3727a8abf371d0b35" name="a985b54c527de6cd3727a8abf371d0b35"></a>
AZ_FORCE_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>bucket</b> (const key_type &amp;keyValue) const</td></tr>
<tr class="separator:a985b54c527de6cd3727a8abf371d0b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684ddc9372c01c87f5d45d664db2d9d8"><td class="memItemLeft" align="right" valign="top"><a id="a684ddc9372c01c87f5d45d664db2d9d8" name="a684ddc9372c01c87f5d45d664db2d9d8"></a>
AZ_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_size</b> (size_type bucket) const</td></tr>
<tr class="separator:a684ddc9372c01c87f5d45d664db2d9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82795946f16dde8b264d8a4976e4e88"><td class="memItemLeft" align="right" valign="top"><a id="ae82795946f16dde8b264d8a4976e4e88" name="ae82795946f16dde8b264d8a4976e4e88"></a>
AZ_FORCE_INLINE float&#160;</td><td class="memItemRight" valign="bottom"><b>load_factor</b> () const</td></tr>
<tr class="separator:ae82795946f16dde8b264d8a4976e4e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac991d012f2ab2998c64b73283430e077"><td class="memItemLeft" align="right" valign="top"><a id="ac991d012f2ab2998c64b73283430e077" name="ac991d012f2ab2998c64b73283430e077"></a>
AZ_FORCE_INLINE float&#160;</td><td class="memItemRight" valign="bottom"><b>max_load_factor</b> () const</td></tr>
<tr class="separator:ac991d012f2ab2998c64b73283430e077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3025763a6046a11939cae44b12601584"><td class="memItemLeft" align="right" valign="top"><a id="a3025763a6046a11939cae44b12601584" name="a3025763a6046a11939cae44b12601584"></a>
AZ_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>max_load_factor</b> (float newMaxLoadFactor)</td></tr>
<tr class="separator:a3025763a6046a11939cae44b12601584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea173acf01b776f2ab8b10ce8a1724b"><td class="memItemLeft" align="right" valign="top"><a id="a0ea173acf01b776f2ab8b10ce8a1724b" name="a0ea173acf01b776f2ab8b10ce8a1724b"></a>
AZ_FORCE_INLINE <a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (const value_type &amp;value)</td></tr>
<tr class="separator:a0ea173acf01b776f2ab8b10ce8a1724b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f38d06ae5f7acec16447d0dcc6f33b"><td class="memItemLeft" align="right" valign="top"><a id="a83f38d06ae5f7acec16447d0dcc6f33b" name="a83f38d06ae5f7acec16447d0dcc6f33b"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a>, const value_type &amp;value)</td></tr>
<tr class="separator:a83f38d06ae5f7acec16447d0dcc6f33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac261f773e1e0fc93508f6f27c93aed5e"><td class="memItemLeft" align="right" valign="top"><a id="ac261f773e1e0fc93508f6f27c93aed5e" name="ac261f773e1e0fc93508f6f27c93aed5e"></a>
AZ_FORCE_INLINE <a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (value_type &amp;&amp;value)</td></tr>
<tr class="separator:ac261f773e1e0fc93508f6f27c93aed5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1690cb4c0bce7500f92a38d557c66817"><td class="memItemLeft" align="right" valign="top"><a id="a1690cb4c0bce7500f92a38d557c66817" name="a1690cb4c0bce7500f92a38d557c66817"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (<a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a>, value_type &amp;&amp;value)</td></tr>
<tr class="separator:a1690cb4c0bce7500f92a38d557c66817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafc05ecd3a5e0a6cf943cb62f3546a9"><td class="memTemplParams" colspan="2"><a id="abafc05ecd3a5e0a6cf943cb62f3546a9" name="abafc05ecd3a5e0a6cf943cb62f3546a9"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abafc05ecd3a5e0a6cf943cb62f3546a9"><td class="memTemplItemLeft" align="right" valign="top">AZ_FORCE_INLINE <a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace</b> (Args &amp;&amp;... arguments)</td></tr>
<tr class="separator:abafc05ecd3a5e0a6cf943cb62f3546a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0364c63006af918e205e56c05292be7"><td class="memItemLeft" align="right" valign="top"><a id="ad0364c63006af918e205e56c05292be7" name="ad0364c63006af918e205e56c05292be7"></a>
AZ_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (std::initializer_list&lt; value_type &gt; <a class="el" href="class_a_z_std_1_1list.html">list</a>)</td></tr>
<tr class="separator:ad0364c63006af918e205e56c05292be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b7262d66657b19fbfed6431e692d34"><td class="memTemplParams" colspan="2"><a id="ab9b7262d66657b19fbfed6431e692d34" name="ab9b7262d66657b19fbfed6431e692d34"></a>
template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:ab9b7262d66657b19fbfed6431e692d34"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (Iterator first, Iterator last) -&gt; enable_if_t&lt; input_iterator&lt; Iterator &gt; &amp;&amp;!is_convertible_v&lt; Iterator, size_type &gt; &gt;</td></tr>
<tr class="separator:ab9b7262d66657b19fbfed6431e692d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fee46cabf889a5a68e6a61910cba47"><td class="memTemplParams" colspan="2"><a id="a14fee46cabf889a5a68e6a61910cba47" name="a14fee46cabf889a5a68e6a61910cba47"></a>
template&lt;class R &gt; </td></tr>
<tr class="memitem:a14fee46cabf889a5a68e6a61910cba47"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_range</b> (R &amp;&amp;rg) -&gt; enable_if_t&lt; Internal::container_compatible_range&lt; R, value_type &gt; &gt;</td></tr>
<tr class="separator:a14fee46cabf889a5a68e6a61910cba47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913b18ed7e1ce23870821f7338cfbc60"><td class="memTemplParams" colspan="2">template&lt;class InsertReturnType , class NodeHandle &gt; </td></tr>
<tr class="memitem:a913b18ed7e1ce23870821f7338cfbc60"><td class="memTemplItemLeft" align="right" valign="top">InsertReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1hash__table.html#a913b18ed7e1ce23870821f7338cfbc60">node_handle_insert</a> (NodeHandle &amp;&amp;nodeHandle)</td></tr>
<tr class="separator:a913b18ed7e1ce23870821f7338cfbc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e98a7e7f1888f8ce58b56e155359fc8"><td class="memTemplParams" colspan="2"><a id="a4e98a7e7f1888f8ce58b56e155359fc8" name="a4e98a7e7f1888f8ce58b56e155359fc8"></a>
template&lt;class NodeHandle &gt; </td></tr>
<tr class="memitem:a4e98a7e7f1888f8ce58b56e155359fc8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>node_handle_insert</b> (<a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a> hint, NodeHandle &amp;&amp;nodeHandle) -&gt; <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a></td></tr>
<tr class="separator:a4e98a7e7f1888f8ce58b56e155359fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade183bba58786aed7e4e15ba558319e7"><td class="memTemplParams" colspan="2">template&lt;class NodeHandle &gt; </td></tr>
<tr class="memitem:ade183bba58786aed7e4e15ba558319e7"><td class="memTemplItemLeft" align="right" valign="top">NodeHandle&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1hash__table.html#ade183bba58786aed7e4e15ba558319e7">node_handle_extract</a> (const key_type &amp;key)</td></tr>
<tr class="separator:ade183bba58786aed7e4e15ba558319e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cd5948dd03e79093495acf08f3fe11"><td class="memTemplParams" colspan="2">template&lt;class NodeHandle &gt; </td></tr>
<tr class="memitem:a24cd5948dd03e79093495acf08f3fe11"><td class="memTemplItemLeft" align="right" valign="top">NodeHandle&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1hash__table.html#a24cd5948dd03e79093495acf08f3fe11">node_handle_extract</a> (<a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a> it)</td></tr>
<tr class="separator:a24cd5948dd03e79093495acf08f3fe11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83b30693e08ed57636936e4f36cf971"><td class="memItemLeft" align="right" valign="top"><a id="ad83b30693e08ed57636936e4f36cf971" name="ad83b30693e08ed57636936e4f36cf971"></a>
AZ_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve</b> (size_type numBucketsMin)</td></tr>
<tr class="separator:ad83b30693e08ed57636936e4f36cf971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f73f89c7211d5a51a87385e68f45d5f"><td class="memItemLeft" align="right" valign="top"><a id="a2f73f89c7211d5a51a87385e68f45d5f" name="a2f73f89c7211d5a51a87385e68f45d5f"></a>
AZ_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>rehash</b> (size_type numBucketsMin)</td></tr>
<tr class="separator:a2f73f89c7211d5a51a87385e68f45d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5984b69ce59743dd39017cc6c2cf8de7"><td class="memItemLeft" align="right" valign="top"><a id="a5984b69ce59743dd39017cc6c2cf8de7" name="a5984b69ce59743dd39017cc6c2cf8de7"></a>
<a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a> erasePos)</td></tr>
<tr class="separator:a5984b69ce59743dd39017cc6c2cf8de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab706c0a796aa15efe2720d9d87f1569a"><td class="memItemLeft" align="right" valign="top"><a id="ab706c0a796aa15efe2720d9d87f1569a" name="ab706c0a796aa15efe2720d9d87f1569a"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (const key_type &amp;keyValue)</td></tr>
<tr class="separator:ab706c0a796aa15efe2720d9d87f1569a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae383048ea06f963ddcdb6e8ceee1a0e3"><td class="memItemLeft" align="right" valign="top"><a id="ae383048ea06f963ddcdb6e8ceee1a0e3" name="ae383048ea06f963ddcdb6e8ceee1a0e3"></a>
<a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a> first, <a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a> last)</td></tr>
<tr class="separator:ae383048ea06f963ddcdb6e8ceee1a0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad74518e73ea9323fbe8560f0efbbade"><td class="memItemLeft" align="right" valign="top"><a id="aad74518e73ea9323fbe8560f0efbbade" name="aad74518e73ea9323fbe8560f0efbbade"></a>
AZ_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:aad74518e73ea9323fbe8560f0efbbade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2aace28282690535aaf6c1246e642ed"><td class="memTemplParams" colspan="2"><a id="af2aace28282690535aaf6c1246e642ed" name="af2aace28282690535aaf6c1246e642ed"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:af2aace28282690535aaf6c1246e642ed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:af2aace28282690535aaf6c1246e642ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133bded4409709c30916e86f81864f4c"><td class="memTemplParams" colspan="2"><a id="a133bded4409709c30916e86f81864f4c" name="a133bded4409709c30916e86f81864f4c"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a133bded4409709c30916e86f81864f4c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:a133bded4409709c30916e86f81864f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d0ba374297f52081564a6fc2923a91"><td class="memTemplParams" colspan="2"><a id="a84d0ba374297f52081564a6fc2923a91" name="a84d0ba374297f52081564a6fc2923a91"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a84d0ba374297f52081564a6fc2923a91"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, bool &gt;</td></tr>
<tr class="separator:a84d0ba374297f52081564a6fc2923a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08505ee4aeb35c3815d27f42974c771d"><td class="memTemplParams" colspan="2"><a id="a08505ee4aeb35c3815d27f42974c771d" name="a08505ee4aeb35c3815d27f42974c771d"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a08505ee4aeb35c3815d27f42974c771d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, size_type &gt;</td></tr>
<tr class="separator:a08505ee4aeb35c3815d27f42974c771d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854458f591e96c7f6c0696b56c0c2440"><td class="memTemplParams" colspan="2"><a id="a854458f591e96c7f6c0696b56c0c2440" name="a854458f591e96c7f6c0696b56c0c2440"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a854458f591e96c7f6c0696b56c0c2440"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a854458f591e96c7f6c0696b56c0c2440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d2e0a6bdb746a3111d4966d7cd587a"><td class="memTemplParams" colspan="2"><a id="a19d2e0a6bdb746a3111d4966d7cd587a" name="a19d2e0a6bdb746a3111d4966d7cd587a"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a19d2e0a6bdb746a3111d4966d7cd587a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:a19d2e0a6bdb746a3111d4966d7cd587a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5181ca0d768afd2e162799029f936333"><td class="memTemplParams" colspan="2"><a id="a5181ca0d768afd2e162799029f936333" name="a5181ca0d768afd2e162799029f936333"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a5181ca0d768afd2e162799029f936333"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upper_bound</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a5181ca0d768afd2e162799029f936333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1460d04c0be8f3015c29341be2658aa1"><td class="memTemplParams" colspan="2"><a id="a1460d04c0be8f3015c29341be2658aa1" name="a1460d04c0be8f3015c29341be2658aa1"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a1460d04c0be8f3015c29341be2658aa1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upper_bound</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:a1460d04c0be8f3015c29341be2658aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6105e3c883e3ca6b7a84b4cc7a5b75"><td class="memTemplParams" colspan="2"><a id="adf6105e3c883e3ca6b7a84b4cc7a5b75" name="adf6105e3c883e3ca6b7a84b4cc7a5b75"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:adf6105e3c883e3ca6b7a84b4cc7a5b75"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a>, <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a> &gt; &gt;</td></tr>
<tr class="separator:adf6105e3c883e3ca6b7a84b4cc7a5b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41838df3b0ea0ea02bb11c2ef7268fd"><td class="memTemplParams" colspan="2"><a id="ad41838df3b0ea0ea02bb11c2ef7268fd" name="ad41838df3b0ea0ea02bb11c2ef7268fd"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:ad41838df3b0ea0ea02bb11c2ef7268fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a>, <a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a> &gt; &gt;</td></tr>
<tr class="separator:ad41838df3b0ea0ea02bb11c2ef7268fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c7d13da3d17a4cc6a3c1e5963e4747"><td class="memItemLeft" align="right" valign="top"><a id="a91c7d13da3d17a4cc6a3c1e5963e4747" name="a91c7d13da3d17a4cc6a3c1e5963e4747"></a>
AZ_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="class_a_z_std_1_1hash__table.html">this_type</a> &amp;rhs)</td></tr>
<tr class="separator:a91c7d13da3d17a4cc6a3c1e5963e4747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04d424303fbdc42fb26cc3f67ff6948"><td class="memTemplParams" colspan="2"><a id="ac04d424303fbdc42fb26cc3f67ff6948" name="ac04d424303fbdc42fb26cc3f67ff6948"></a>
template&lt;typename ComparableToKey , typename... Args&gt; </td></tr>
<tr class="memitem:ac04d424303fbdc42fb26cc3f67ff6948"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace_transparent</b> (ComparableToKey &amp;&amp;key, Args &amp;&amp;... arguments) -&gt; <a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a></td></tr>
<tr class="separator:ac04d424303fbdc42fb26cc3f67ff6948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06212abb12f0006cf8f8757292e3ed8"><td class="memTemplParams" colspan="2"><a id="ae06212abb12f0006cf8f8757292e3ed8" name="ae06212abb12f0006cf8f8757292e3ed8"></a>
template&lt;typename ComparableToKey , typename... Args&gt; </td></tr>
<tr class="memitem:ae06212abb12f0006cf8f8757292e3ed8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace_transparent</b> (<a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a>, ComparableToKey &amp;&amp;key, Args &amp;&amp;... arguments) -&gt; <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a></td></tr>
<tr class="separator:ae06212abb12f0006cf8f8757292e3ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0943261c516aa550fd1b823d80c630d7"><td class="memTemplParams" colspan="2"><a id="a0943261c516aa550fd1b823d80c630d7" name="a0943261c516aa550fd1b823d80c630d7"></a>
template&lt;typename ComparableToKey , typename MappedType &gt; </td></tr>
<tr class="memitem:a0943261c516aa550fd1b823d80c630d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign_transparent</b> (ComparableToKey &amp;&amp;key, MappedType &amp;&amp;value) -&gt; <a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a></td></tr>
<tr class="separator:a0943261c516aa550fd1b823d80c630d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8c73fa8d4d750e35d23ab2f8c14fc1"><td class="memTemplParams" colspan="2"><a id="aad8c73fa8d4d750e35d23ab2f8c14fc1" name="aad8c73fa8d4d750e35d23ab2f8c14fc1"></a>
template&lt;typename ComparableToKey , typename MappedType &gt; </td></tr>
<tr class="memitem:aad8c73fa8d4d750e35d23ab2f8c14fc1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign_transparent</b> (<a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a>, ComparableToKey &amp;&amp;key, MappedType &amp;&amp;value) -&gt; <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a></td></tr>
<tr class="separator:aad8c73fa8d4d750e35d23ab2f8c14fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extensions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="HashExtensions"></a></p>
</div></td></tr>
<tr class="memitem:af704e7588dabd9ead6c68552e7d33979"><td class="memItemLeft" align="right" valign="top"><a id="af704e7588dabd9ead6c68552e7d33979" name="af704e7588dabd9ead6c68552e7d33979"></a>
AZ_FORCE_INLINE allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> ()</td></tr>
<tr class="separator:af704e7588dabd9ead6c68552e7d33979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c5987dab9c0e925746dd22c82a326f"><td class="memItemLeft" align="right" valign="top"><a id="a71c5987dab9c0e925746dd22c82a326f" name="a71c5987dab9c0e925746dd22c82a326f"></a>
AZ_FORCE_INLINE const allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const</td></tr>
<tr class="separator:a71c5987dab9c0e925746dd22c82a326f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477e5431bd036dac3282df69a5535d6d"><td class="memItemLeft" align="right" valign="top"><a id="a477e5431bd036dac3282df69a5535d6d" name="a477e5431bd036dac3282df69a5535d6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_allocator</b> (const allocator_type &amp;<a class="el" href="class_a_z_std_1_1allocator.html">allocator</a>)</td></tr>
<tr class="separator:a477e5431bd036dac3282df69a5535d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e6deb47d597669bd12691d8796f411"><td class="memTemplParams" colspan="2">template&lt;class ComparableToKey , class Hasher , class KeyEqual &gt; </td></tr>
<tr class="memitem:a78e6deb47d597669bd12691d8796f411"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1hash__table.html#a78e6deb47d597669bd12691d8796f411">find_as</a> (const ComparableToKey &amp;keyCmp, const Hasher &amp;<a class="el" href="struct_a_z_std_1_1hash.html">hash</a>, const KeyEqual &amp;keyEq)</td></tr>
<tr class="separator:a78e6deb47d597669bd12691d8796f411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77830957dedb641ff32c328e4de79d7f"><td class="memTemplParams" colspan="2"><a id="a77830957dedb641ff32c328e4de79d7f" name="a77830957dedb641ff32c328e4de79d7f"></a>
template&lt;class ComparableToKey , class Hasher , class KeyEqual &gt; </td></tr>
<tr class="memitem:a77830957dedb641ff32c328e4de79d7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_as</b> (const ComparableToKey &amp;keyCmp, const Hasher &amp;<a class="el" href="struct_a_z_std_1_1hash.html">hash</a>, const KeyEqual &amp;keyEq) const</td></tr>
<tr class="separator:a77830957dedb641ff32c328e4de79d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ff15a245dff93fa4a65b454df77b8b"><td class="memTemplParams" colspan="2">template&lt;class U , class Converter , class Hasher , class KeyEqual &gt; </td></tr>
<tr class="memitem:a36ff15a245dff93fa4a65b454df77b8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1hash__table.html#a36ff15a245dff93fa4a65b454df77b8b">insert_from</a> (const U &amp;userValue, const Converter &amp;convert, const Hasher &amp;<a class="el" href="struct_a_z_std_1_1hash.html">hash</a>, const KeyEqual &amp;keyEq)</td></tr>
<tr class="separator:a36ff15a245dff93fa4a65b454df77b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf945ee49b9e2778dff42d748e02b41f"><td class="memItemLeft" align="right" valign="top"><a id="adf945ee49b9e2778dff42d748e02b41f" name="adf945ee49b9e2778dff42d748e02b41f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>validate</b> () const</td></tr>
<tr class="separator:adf945ee49b9e2778dff42d748e02b41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9377152a63cca133555ce8dd56cba36d"><td class="memItemLeft" align="right" valign="top"><a id="a9377152a63cca133555ce8dd56cba36d" name="a9377152a63cca133555ce8dd56cba36d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>validate_iterator</b> (const <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a> &amp;iter) const</td></tr>
<tr class="memdesc:a9377152a63cca133555ce8dd56cba36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates an iter iterator. Returns a combination of <a class="el" href="namespace_a_z_std.html#a77fc989e737c35ee90f2b8ef6f5e9b9c">iterator_status_flag</a>. <br /></td></tr>
<tr class="separator:a9377152a63cca133555ce8dd56cba36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4ef7573f124a6f151125f4ce53abfe"><td class="memItemLeft" align="right" valign="top"><a id="afb4ef7573f124a6f151125f4ce53abfe" name="afb4ef7573f124a6f151125f4ce53abfe"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>validate_iterator</b> (const <a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a> &amp;iter) const</td></tr>
<tr class="separator:afb4ef7573f124a6f151125f4ce53abfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21df90689557c5518c0d1d41c51c21d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1hash__table.html#a21df90689557c5518c0d1d41c51c21d5">leak_and_reset</a> ()</td></tr>
<tr class="separator:a21df90689557c5518c0d1d41c51c21d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a272bb6f933dd421dabe312a20ca98e5c"><td class="memItemLeft" align="right" valign="top"><a id="a272bb6f933dd421dabe312a20ca98e5c" name="a272bb6f933dd421dabe312a20ca98e5c"></a>
AZ_FORCE_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_from_hash</b> (const size_type key) const</td></tr>
<tr class="separator:a272bb6f933dd421dabe312a20ca98e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31994b8aa25bfb38c907d719a2f2b428"><td class="memItemLeft" align="right" valign="top"><a id="a31994b8aa25bfb38c907d719a2f2b428" name="a31994b8aa25bfb38c907d719a2f2b428"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> (const <a class="el" href="class_a_z_std_1_1hash__table.html">this_type</a> &amp;rhs)</td></tr>
<tr class="separator:a31994b8aa25bfb38c907d719a2f2b428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ccd9bf3f5d8c9611c3c12bff55703a"><td class="memItemLeft" align="right" valign="top"><a id="aa0ccd9bf3f5d8c9611c3c12bff55703a" name="aa0ccd9bf3f5d8c9611c3c12bff55703a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign_rv</b> (<a class="el" href="class_a_z_std_1_1hash__table.html">this_type</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:aa0ccd9bf3f5d8c9611c3c12bff55703a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfe83053172a17f9e8b9e9114dbde22"><td class="memTemplParams" colspan="2"><a id="a6dfe83053172a17f9e8b9e9114dbde22" name="a6dfe83053172a17f9e8b9e9114dbde22"></a>
template&lt;class ComparableToKey , class KeyEq &gt; </td></tr>
<tr class="memitem:a6dfe83053172a17f9e8b9e9114dbde22"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_insert_position</b> (const ComparableToKey &amp;keyCmp, const KeyEq &amp;keyEq, <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a> &amp;insertIter, size_type numElements, const true_type &amp;)</td></tr>
<tr class="separator:a6dfe83053172a17f9e8b9e9114dbde22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdf82e348abbdf990fe264c8abbe13a"><td class="memTemplParams" colspan="2"><a id="a8fdf82e348abbdf990fe264c8abbe13a" name="a8fdf82e348abbdf990fe264c8abbe13a"></a>
template&lt;class ComparableToKey , class KeyEq &gt; </td></tr>
<tr class="memitem:a8fdf82e348abbdf990fe264c8abbe13a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_insert_position</b> (const ComparableToKey &amp;keyCmp, const KeyEq &amp;keyEq, <a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a> &amp;insertIter, size_type numElements, const false_type &amp;)</td></tr>
<tr class="separator:a8fdf82e348abbdf990fe264c8abbe13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c415490999f0a9125f216562dd673d"><td class="memTemplParams" colspan="2"><a id="a94c415490999f0a9125f216562dd673d" name="a94c415490999f0a9125f216562dd673d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94c415490999f0a9125f216562dd673d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_impl</b> (T &amp;&amp;value)</td></tr>
<tr class="separator:a94c415490999f0a9125f216562dd673d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0c37a1ca2925c9fdcc6c1053075083"><td class="memTemplParams" colspan="2"><a id="abd0c37a1ca2925c9fdcc6c1053075083" name="abd0c37a1ca2925c9fdcc6c1053075083"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abd0c37a1ca2925c9fdcc6c1053075083"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_impl_emplace</b> (Args &amp;&amp;... arguments)</td></tr>
<tr class="separator:abd0c37a1ca2925c9fdcc6c1053075083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f3cc8aa3fb4ae1ef9ba0231f2355ac"><td class="memTemplParams" colspan="2"><a id="af6f3cc8aa3fb4ae1ef9ba0231f2355ac" name="af6f3cc8aa3fb4ae1ef9ba0231f2355ac"></a>
template&lt;typename ComparableToKey , typename... Args&gt; </td></tr>
<tr class="memitem:af6f3cc8aa3fb4ae1ef9ba0231f2355ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace_transparent</b> (ComparableToKey &amp;&amp;key, Args &amp;&amp;... arguments)</td></tr>
<tr class="separator:af6f3cc8aa3fb4ae1ef9ba0231f2355ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d57a80f313d856723ff1951607ebb58"><td class="memTemplParams" colspan="2"><a id="a5d57a80f313d856723ff1951607ebb58" name="a5d57a80f313d856723ff1951607ebb58"></a>
template&lt;typename ComparableToKey , typename... Args&gt; </td></tr>
<tr class="memitem:a5d57a80f313d856723ff1951607ebb58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace_transparent</b> (<a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a> hint, ComparableToKey &amp;&amp;key, Args &amp;&amp;... arguments)</td></tr>
<tr class="separator:a5d57a80f313d856723ff1951607ebb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a53b25294962aeac542de6b9dc7c58"><td class="memTemplParams" colspan="2"><a id="a99a53b25294962aeac542de6b9dc7c58" name="a99a53b25294962aeac542de6b9dc7c58"></a>
template&lt;typename ComparableToKey , typename MappedType &gt; </td></tr>
<tr class="memitem:a99a53b25294962aeac542de6b9dc7c58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign_transparent</b> (ComparableToKey &amp;&amp;key, MappedType &amp;&amp;value)</td></tr>
<tr class="separator:a99a53b25294962aeac542de6b9dc7c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d52612e17196d84d1c382967af9cd03"><td class="memTemplParams" colspan="2"><a id="a6d52612e17196d84d1c382967af9cd03" name="a6d52612e17196d84d1c382967af9cd03"></a>
template&lt;typename ComparableToKey , typename MappedType &gt; </td></tr>
<tr class="memitem:a6d52612e17196d84d1c382967af9cd03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign_transparent</b> (<a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a> hint, ComparableToKey &amp;&amp;key, MappedType &amp;&amp;value)</td></tr>
<tr class="separator:a6d52612e17196d84d1c382967af9cd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8f7fefc8a448e8a9bdbeed05aa3ac8a6"><td class="memItemLeft" align="right" valign="top"><a id="a8f7fefc8a448e8a9bdbeed05aa3ac8a6" name="a8f7fefc8a448e8a9bdbeed05aa3ac8a6"></a>
storage_type&#160;</td><td class="memItemRight" valign="bottom"><b>m_data</b></td></tr>
<tr class="separator:a8f7fefc8a448e8a9bdbeed05aa3ac8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb23b13a82b61bc4fd1723dd11e51f37"><td class="memItemLeft" align="right" valign="top"><a id="aeb23b13a82b61bc4fd1723dd11e51f37" name="aeb23b13a82b61bc4fd1723dd11e51f37"></a>
key_equal&#160;</td><td class="memItemRight" valign="bottom"><b>m_keyEqual</b></td></tr>
<tr class="separator:aeb23b13a82b61bc4fd1723dd11e51f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4595160addf1be65d5cc544f3d8af5"><td class="memItemLeft" align="right" valign="top"><a id="abb4595160addf1be65d5cc544f3d8af5" name="abb4595160addf1be65d5cc544f3d8af5"></a>
hasher&#160;</td><td class="memItemRight" valign="bottom"><b>m_hasher</b></td></tr>
<tr class="separator:abb4595160addf1be65d5cc544f3d8af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Traits&gt;<br />
class AZStd::hash_table&lt; Traits &gt;</div><p>Hash table is internal container used as a base class for all unordered associative containers. It provides functionality for the unordered container in CTR1. (6.3.4). In addition we introduce the following <a class="el" href="class_a_z_std_1_1hash__table.html#HashExtensions">extensions</a>.</p>
<p>Traits should have the following members typedef xxx key_type; typedef xxx key_equal; typedef xxx hasher; typedef xxx value_type; typedef xxx allocator_type; enum { max_load_factor = xxx, // What should the max load factor before we grow the map. Load factor is the average num of elements per bucket. min_buckets = xxx, // Min num of buckets to be allocated. has_multi_elements = true or false, is_dynamic = true or false, // true if we have fixed container. If we do so we will need to se fixed_num_buckets and fixed_num_elements. fixed_num_buckets = xxx, // Number of buckets to pre-allocate. For hashing purposes it will be good to be a prime number. We we get better bucket distribution. // It should be aprox. 1/3 - 1/4 (max_load_factor 3 or 4) of the number of elements, otherwise we will have too much liear searches. fixed_num_elements = xxx, // Number of elements to pre-allocate. }</p>
<p>static inline key_type key_from_value(const value_type&amp; value);</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a78e6deb47d597669bd12691d8796f411" name="a78e6deb47d597669bd12691d8796f411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e6deb47d597669bd12691d8796f411">&#9670;&#160;</a></span>find_as()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<div class="memtemplate">
template&lt;class ComparableToKey , class Hasher , class KeyEqual &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_std_1_1list__iterator.html">iterator</a> <a class="el" href="class_a_z_std_1_1hash__table.html">AZStd::hash_table</a>&lt; Traits &gt;::find_as </td>
          <td>(</td>
          <td class="paramtype">const ComparableToKey &amp;&#160;</td>
          <td class="paramname"><em>keyCmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hasher &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>keyEq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is similar to lazy_find in this paper C14IDEAS. The idea is to be able to customize the search. For non key_type objects. </p>

</div>
</div>
<a id="a36ff15a245dff93fa4a65b454df77b8b" name="a36ff15a245dff93fa4a65b454df77b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ff15a245dff93fa4a65b454df77b8b">&#9670;&#160;</a></span>insert_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<div class="memtemplate">
template&lt;class U , class Converter , class Hasher , class KeyEqual &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a> <a class="el" href="class_a_z_std_1_1hash__table.html">AZStd::hash_table</a>&lt; Traits &gt;::insert_from </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>userValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Converter &amp;&#160;</td>
          <td class="paramname"><em>convert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hasher &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>keyEq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts from a value and converter object. Converter object has the following interface struct MyConverter { typedef Map::key_type or CompareableToKeyType key_type; const key_type&amp; to_key(const&amp; MyValue) const; Map::value_type to_value(const&amp; MyValue) const; } This allow us to convert any "userValue" (U parameter) to a key, check if we can add it to the list, if so, we call to_value function to create (to_key(userValue), to_value(userValue)) and add it to the hash table. This is similar to lazy_insert in this paper C14IDEAS. There is an example why it's beneficial, you can check AZStdExamples. The main idea is that you don't to create unnecessary expensive temporaries. </p>

</div>
</div>
<a id="a21df90689557c5518c0d1d41c51c21d5" name="a21df90689557c5518c0d1d41c51c21d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21df90689557c5518c0d1d41c51c21d5">&#9670;&#160;</a></span>leak_and_reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_a_z_std_1_1hash__table.html">AZStd::hash_table</a>&lt; Traits &gt;::leak_and_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets the container without deallocating any memory or calling any destructor. This function should be used when we need very quick tear down. Generally it's used for temporary vectors and we can just nuke them that way. In addition the provided <a class="el" href="_allocators.html">Allocators</a>, has leak and reset flag which will enable automatically this behavior. So this function should be used in special cases AZStdExamples. </p><dl class="section note"><dt>Note</dt><dd>This function is added to the vector for consistency. In the vector case we have only one allocation, and if the allocator allows memory leaks it can just leave deallocate function empty, which performance wise will be the same. For more complex containers this will make big difference. </dd></dl>

</div>
</div>
<a id="ade183bba58786aed7e4e15ba558319e7" name="ade183bba58786aed7e4e15ba558319e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade183bba58786aed7e4e15ba558319e7">&#9670;&#160;</a></span>node_handle_extract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<div class="memtemplate">
template&lt;class NodeHandle &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeHandle <a class="el" href="class_a_z_std_1_1hash__table.html">AZStd::hash_table</a>&lt; Traits &gt;::node_handle_extract </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for an element which matches the value of key and extracts it from the <a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a> </p><dl class="section return"><dt>Returns</dt><dd>A NodeHandle which can be used to insert the an element between unique and non-unique containers of the same type i.e a NodeHandle from an <a class="el" href="class_a_z_std_1_1unordered__map.html">unordered_map</a> can be used to insert a node into an <a class="el" href="class_a_z_std_1_1unordered__multimap.html">unordered_multimap</a>, but not a std::map </dd></dl>

</div>
</div>
<a id="a24cd5948dd03e79093495acf08f3fe11" name="a24cd5948dd03e79093495acf08f3fe11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cd5948dd03e79093495acf08f3fe11">&#9670;&#160;</a></span>node_handle_extract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<div class="memtemplate">
template&lt;class NodeHandle &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeHandle <a class="el" href="class_a_z_std_1_1hash__table.html">AZStd::hash_table</a>&lt; Traits &gt;::node_handle_extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds an element within the <a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a> that is represented by the supplied iterator and extracts it </p><dl class="section return"><dt>Returns</dt><dd>A NodeHandle which can be used to insert the an element between unique and non-unique containers of the same type </dd></dl>

</div>
</div>
<a id="a913b18ed7e1ce23870821f7338cfbc60" name="a913b18ed7e1ce23870821f7338cfbc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913b18ed7e1ce23870821f7338cfbc60">&#9670;&#160;</a></span>node_handle_insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<div class="memtemplate">
template&lt;class InsertReturnType , class NodeHandle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InsertReturnType <a class="el" href="class_a_z_std_1_1hash__table.html">AZStd::hash_table</a>&lt; Traits &gt;::node_handle_insert </td>
          <td>(</td>
          <td class="paramtype">NodeHandle &amp;&amp;&#160;</td>
          <td class="paramname"><em>nodeHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an insert_return_type with the members initialized as follows: if nh is empty, inserted is false, position is end(), and node is empty. Otherwise if the insertion took place, inserted is true, position points to the inserted element, and node is empty. If the insertion failed, inserted is false, node has the previous value of nh, and position points to an element with a key equivalent to nh.key(). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Code/Framework/AzCore/AzCore/std/containers/node_handle.h</li>
<li>Code/Framework/AzCore/AzCore/std/hash_table.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_a_z_std.html">AZStd</a></li><li class="navelem"><a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a></li>
    <li class="footer">Generated on Mon Oct 9 2023 13:38:53 for Open 3D Engine AzCore API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
