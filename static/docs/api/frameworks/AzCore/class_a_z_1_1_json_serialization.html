<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine AzCore API Reference: AZ::JsonSerialization Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Open 3D Engine AzCore API Reference<span id="projectnumber">&#160;23.10.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_a_z_1_1_json_serialization.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_a_z_1_1_json_serialization-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AZ::JsonSerialization Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;JsonSerialization.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a476fd39201e5023749ebb02b7d3ab2e1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#a476fd39201e5023749ebb02b7d3ab2e1">ApplyPatch</a> (rapidjson::Value &amp;target, rapidjson::Document::AllocatorType &amp;allocator, const rapidjson::Value &amp;patch, <a class="el" href="namespace_a_z.html#a408cd8672ae4532f76638045f0746b5e">JsonMergeApproach</a> approach, const <a class="el" href="struct_a_z_1_1_json_apply_patch_settings.html">JsonApplyPatchSettings</a> &amp;settings=<a class="el" href="struct_a_z_1_1_json_apply_patch_settings.html">JsonApplyPatchSettings</a>{})</td></tr>
<tr class="separator:a476fd39201e5023749ebb02b7d3ab2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336f95f2f73a53915683bc8852dfd421"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#a336f95f2f73a53915683bc8852dfd421">ApplyPatch</a> (rapidjson::Value &amp;target, rapidjson::Document::AllocatorType &amp;allocator, const rapidjson::Value &amp;patch, <a class="el" href="namespace_a_z.html#a408cd8672ae4532f76638045f0746b5e">JsonMergeApproach</a> approach, <a class="el" href="struct_a_z_1_1_json_apply_patch_settings.html">JsonApplyPatchSettings</a> &amp;settings)</td></tr>
<tr class="separator:a336f95f2f73a53915683bc8852dfd421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8646f466eb065c745ec9da054ba96009"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#a8646f466eb065c745ec9da054ba96009">ApplyPatch</a> (rapidjson::Value &amp;output, rapidjson::Document::AllocatorType &amp;allocator, const rapidjson::Value &amp;source, const rapidjson::Value &amp;patch, <a class="el" href="namespace_a_z.html#a408cd8672ae4532f76638045f0746b5e">JsonMergeApproach</a> approach, const <a class="el" href="struct_a_z_1_1_json_apply_patch_settings.html">JsonApplyPatchSettings</a> &amp;settings=<a class="el" href="struct_a_z_1_1_json_apply_patch_settings.html">JsonApplyPatchSettings</a>{})</td></tr>
<tr class="separator:a8646f466eb065c745ec9da054ba96009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada308489a6ff5405be6655daa1d04a3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#aada308489a6ff5405be6655daa1d04a3">ApplyPatch</a> (rapidjson::Value &amp;output, rapidjson::Document::AllocatorType &amp;allocator, const rapidjson::Value &amp;source, const rapidjson::Value &amp;patch, <a class="el" href="namespace_a_z.html#a408cd8672ae4532f76638045f0746b5e">JsonMergeApproach</a> approach, <a class="el" href="struct_a_z_1_1_json_apply_patch_settings.html">JsonApplyPatchSettings</a> &amp;settings)</td></tr>
<tr class="separator:aada308489a6ff5405be6655daa1d04a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418c6e7f6ce6149c578a28746e17c4b0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#a418c6e7f6ce6149c578a28746e17c4b0">CreatePatch</a> (rapidjson::Value &amp;patch, rapidjson::Document::AllocatorType &amp;allocator, const rapidjson::Value &amp;source, const rapidjson::Value &amp;target, <a class="el" href="namespace_a_z.html#a408cd8672ae4532f76638045f0746b5e">JsonMergeApproach</a> approach, const <a class="el" href="struct_a_z_1_1_json_create_patch_settings.html">JsonCreatePatchSettings</a> &amp;settings=<a class="el" href="struct_a_z_1_1_json_create_patch_settings.html">JsonCreatePatchSettings</a>{})</td></tr>
<tr class="separator:a418c6e7f6ce6149c578a28746e17c4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cbbe800d40dc1980f49f67b8c5193c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#a98cbbe800d40dc1980f49f67b8c5193c">CreatePatch</a> (rapidjson::Value &amp;patch, rapidjson::Document::AllocatorType &amp;allocator, const rapidjson::Value &amp;source, const rapidjson::Value &amp;target, <a class="el" href="namespace_a_z.html#a408cd8672ae4532f76638045f0746b5e">JsonMergeApproach</a> approach, <a class="el" href="struct_a_z_1_1_json_create_patch_settings.html">JsonCreatePatchSettings</a> &amp;settings)</td></tr>
<tr class="separator:a98cbbe800d40dc1980f49f67b8c5193c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79610a6b60a203c6b1f2337b489e373f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79610a6b60a203c6b1f2337b489e373f"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#a79610a6b60a203c6b1f2337b489e373f">Load</a> (T &amp;object, const rapidjson::Value &amp;root, const <a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a> &amp;settings=<a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a>{})</td></tr>
<tr class="separator:a79610a6b60a203c6b1f2337b489e373f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814a8c28008f36ecf2e7e25df2631d4b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a814a8c28008f36ecf2e7e25df2631d4b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#a814a8c28008f36ecf2e7e25df2631d4b">Load</a> (T &amp;object, const rapidjson::Value &amp;root, <a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a> &amp;settings)</td></tr>
<tr class="separator:a814a8c28008f36ecf2e7e25df2631d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a82cbedb064cad9dd5dc94f361a7284"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#a4a82cbedb064cad9dd5dc94f361a7284">Load</a> (void *object, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;objectType, const rapidjson::Value &amp;root, const <a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a> &amp;settings=<a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a>{})</td></tr>
<tr class="separator:a4a82cbedb064cad9dd5dc94f361a7284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6453077507b1978252ae5addb307b70"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#ab6453077507b1978252ae5addb307b70">Load</a> (void *object, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;objectType, const rapidjson::Value &amp;root, <a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a> &amp;settings)</td></tr>
<tr class="separator:ab6453077507b1978252ae5addb307b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343610703da4c73bf612e65549e10376"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#a343610703da4c73bf612e65549e10376">LoadTypeId</a> (<a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;typeId, const rapidjson::Value &amp;input, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> *baseClassTypeId=nullptr, <a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> jsonPath=<a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>{}, const <a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a> &amp;settings=<a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a>{})</td></tr>
<tr class="separator:a343610703da4c73bf612e65549e10376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d78739931d76218a6e2d1498fc0a8b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#ad1d78739931d76218a6e2d1498fc0a8b">LoadTypeId</a> (<a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;typeId, const rapidjson::Value &amp;input, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> *baseClassTypeId, <a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> jsonPath, <a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a> &amp;settings)</td></tr>
<tr class="separator:ad1d78739931d76218a6e2d1498fc0a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18bdf7ef288a00bcf5652d974e04006"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab18bdf7ef288a00bcf5652d974e04006"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#ab18bdf7ef288a00bcf5652d974e04006">Store</a> (rapidjson::Value &amp;output, rapidjson::Document::AllocatorType &amp;allocator, const T &amp;object, const <a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> &amp;settings=<a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a>{})</td></tr>
<tr class="separator:ab18bdf7ef288a00bcf5652d974e04006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada52f32eba18c59c1c711b36353f4613"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada52f32eba18c59c1c711b36353f4613"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#ada52f32eba18c59c1c711b36353f4613">Store</a> (rapidjson::Value &amp;output, rapidjson::Document::AllocatorType &amp;allocator, const T &amp;object, <a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> &amp;settings)</td></tr>
<tr class="separator:ada52f32eba18c59c1c711b36353f4613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db68eae4dad0efe6a0a2118de18ad1a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0db68eae4dad0efe6a0a2118de18ad1a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#a0db68eae4dad0efe6a0a2118de18ad1a">Store</a> (rapidjson::Value &amp;output, rapidjson::Document::AllocatorType &amp;allocator, const T &amp;object, const T &amp;defaultObject, const <a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> &amp;settings=<a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a>{})</td></tr>
<tr class="separator:a0db68eae4dad0efe6a0a2118de18ad1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482bbe90b75d0a08925fb9e64fb41236"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a482bbe90b75d0a08925fb9e64fb41236"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#a482bbe90b75d0a08925fb9e64fb41236">Store</a> (rapidjson::Value &amp;output, rapidjson::Document::AllocatorType &amp;allocator, const T &amp;object, const T &amp;defaultObject, <a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> &amp;settings)</td></tr>
<tr class="separator:a482bbe90b75d0a08925fb9e64fb41236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a537d3c6cf3e082adb08af3e7e3dc4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#a79a537d3c6cf3e082adb08af3e7e3dc4">Store</a> (rapidjson::Value &amp;output, rapidjson::Document::AllocatorType &amp;allocator, const void *object, const void *defaultObject, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;objectType, const <a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> &amp;settings=<a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a>{})</td></tr>
<tr class="separator:a79a537d3c6cf3e082adb08af3e7e3dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dbd0fbdc85b3b55298db4dd8c6ac63"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#ac3dbd0fbdc85b3b55298db4dd8c6ac63">Store</a> (rapidjson::Value &amp;output, rapidjson::Document::AllocatorType &amp;allocator, const void *object, const void *defaultObject, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;objectType, <a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> &amp;settings)</td></tr>
<tr class="separator:ac3dbd0fbdc85b3b55298db4dd8c6ac63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e3318316e8de1dabed2a6a73caf63f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#ae8e3318316e8de1dabed2a6a73caf63f">StoreTypeId</a> (rapidjson::Value &amp;output, rapidjson::Document::AllocatorType &amp;allocator, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;typeId, <a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> elementPath=<a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>{}, const <a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> &amp;settings=<a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a>{})</td></tr>
<tr class="separator:ae8e3318316e8de1dabed2a6a73caf63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3551ba3a22040189cfcf59ef98b197b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#aa3551ba3a22040189cfcf59ef98b197b">StoreTypeId</a> (rapidjson::Value &amp;output, rapidjson::Document::AllocatorType &amp;allocator, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;typeId, <a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> elementPath, <a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> &amp;settings)</td></tr>
<tr class="separator:aa3551ba3a22040189cfcf59ef98b197b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021d46663b4b4b81b1e78677f3bf385d"><td class="memItemLeft" align="right" valign="top">static JsonSerializerCompareResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#a021d46663b4b4b81b1e78677f3bf385d">Compare</a> (const rapidjson::Value &amp;lhs, const rapidjson::Value &amp;rhs)</td></tr>
<tr class="separator:a021d46663b4b4b81b1e78677f3bf385d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f3632dcc803b2062b395caa56518c5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#a89f3632dcc803b2062b395caa56518c5">ResolveImports</a> (rapidjson::Value &amp;jsonDoc, rapidjson::Document::AllocatorType &amp;allocator, <a class="el" href="struct_a_z_1_1_json_import_settings.html">JsonImportSettings</a> &amp;settings)</td></tr>
<tr class="separator:a89f3632dcc803b2062b395caa56518c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383dafc031c92b85938980117bfdc68e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#a383dafc031c92b85938980117bfdc68e">RestoreImports</a> (rapidjson::Value &amp;jsonDoc, rapidjson::Document::AllocatorType &amp;allocator, <a class="el" href="struct_a_z_1_1_json_import_settings.html">JsonImportSettings</a> &amp;settings)</td></tr>
<tr class="separator:a383dafc031c92b85938980117bfdc68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411f8fc95cb8d75ce410068f3f3112e9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_a_z_1_1_registered_reflection_context_result.html">RegisteredReflectionContextResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_json_serialization.html#a411f8fc95cb8d75ce410068f3f3112e9">IsTypeSerializable</a> (const <a class="el" href="namespace_a_z.html#a5c1a2bfc05f03fd482d2fb55fbe82051">AZ::TypeId</a> &amp;typeId, <a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> settings={})</td></tr>
<tr class="separator:a411f8fc95cb8d75ce410068f3f3112e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a53c61b81e84b23f92a888ae0176ad006"><td class="memItemLeft" align="right" valign="top"><a id="a53c61b81e84b23f92a888ae0176ad006" name="a53c61b81e84b23f92a888ae0176ad006"></a>
static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><b>TypeIdFieldIdentifier</b> = &quot;$type&quot;</td></tr>
<tr class="separator:a53c61b81e84b23f92a888ae0176ad006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212ba70acd55d2f3624bec135ae7afc1"><td class="memItemLeft" align="right" valign="top"><a id="a212ba70acd55d2f3624bec135ae7afc1" name="a212ba70acd55d2f3624bec135ae7afc1"></a>
static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultStringIdentifier</b> = &quot;{}&quot;</td></tr>
<tr class="separator:a212ba70acd55d2f3624bec135ae7afc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19342e77c5cc28e44c6e20095f63cd2f"><td class="memItemLeft" align="right" valign="top"><a id="a19342e77c5cc28e44c6e20095f63cd2f" name="a19342e77c5cc28e44c6e20095f63cd2f"></a>
static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><b>KeyFieldIdentifier</b> = &quot;Key&quot;</td></tr>
<tr class="separator:a19342e77c5cc28e44c6e20095f63cd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f245683a19195fcd1353bc6da44a1a"><td class="memItemLeft" align="right" valign="top"><a id="ab3f245683a19195fcd1353bc6da44a1a" name="ab3f245683a19195fcd1353bc6da44a1a"></a>
static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><b>ValueFieldIdentifier</b> = &quot;Value&quot;</td></tr>
<tr class="separator:ab3f245683a19195fcd1353bc6da44a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc39bd5e81a517fdbb681de1a897f2d5"><td class="memItemLeft" align="right" valign="top"><a id="acc39bd5e81a517fdbb681de1a897f2d5" name="acc39bd5e81a517fdbb681de1a897f2d5"></a>
static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><b>ImportDirectiveIdentifier</b> = &quot;$import&quot;</td></tr>
<tr class="separator:acc39bd5e81a517fdbb681de1a897f2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Core class to handle serialization to and from json documents. The Json Serialization works by taking a default constructed object and then apply the information found in the JSON document on top of that object. This allows the Json Serialization to avoid storing default values and helps guarantee that the final object is in a valid state even if non-fatal issues are encountered. Note on containers: Containers such as vector or map are always considered to be empty even if there's entries in the provided default object. During deserialization entries will be appended to any existing values. A flag is provided to automatically clear containers during deserialization. Note on maps: If the key for map containers such as unordered_map can be interpret as a string the Json Serialization will use a JSON Object to store the data in instead of an array with key/value objects. Note on pointers: The Json Serialization assumes that are always constructed, so a default JSON value of "{}" is interpret as creating a new default instance even if the default value is a null pointer. A JSON Null needs to be explicitly stored in the JSON Document in order to default or explicitly set a pointer to null. Note on pointer memory: Objects created/destroyed by the Json Serialization for pointers require that the AZ_CLASS_ALLOCATOR is declared and the object is created using aznew or memory is allocated using azmalloc. Without these the application may crash if the Json Serialization tries to create or destroy an object pointed to by a pointer. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a8646f466eb065c745ec9da054ba96009" name="a8646f466eb065c745ec9da054ba96009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8646f466eb065c745ec9da054ba96009">&#9670;&#160;</a></span>ApplyPatch() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::ApplyPatch </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document::AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_a_z.html#a408cd8672ae4532f76638045f0746b5e">JsonMergeApproach</a>&#160;</td>
          <td class="paramname"><em>approach</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_json_apply_patch_settings.html">JsonApplyPatchSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="struct_a_z_1_1_json_apply_patch_settings.html">JsonApplyPatchSettings</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges two json values together by applying "patch" to a copy of "output" and written to output using the selected merge algorithm. This version of ApplyPatch is non-destructive to "source". If the patch couldn't be fully applied "output" will be left set to an empty (default) object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A copy of source with the patch applied to it or an empty object if the patch couldn't be applied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator associated with the document that holds the source. </td></tr>
    <tr><td class="paramname">target</td><td>The value where the patch will be applied to. </td></tr>
    <tr><td class="paramname">patch</td><td>The value holding the patch information. </td></tr>
    <tr><td class="paramname">approach</td><td>The merge algorithm that will be used to apply the patch on top of the target. </td></tr>
    <tr><td class="paramname">settings</td><td>Optional additional settings to control the way the patch is applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aada308489a6ff5405be6655daa1d04a3" name="aada308489a6ff5405be6655daa1d04a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada308489a6ff5405be6655daa1d04a3">&#9670;&#160;</a></span>ApplyPatch() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::ApplyPatch </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document::AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_a_z.html#a408cd8672ae4532f76638045f0746b5e">JsonMergeApproach</a>&#160;</td>
          <td class="paramname"><em>approach</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_json_apply_patch_settings.html">JsonApplyPatchSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges two json values together by applying "patch" to a copy of "output" and written to output using the selected merge algorithm. This version of ApplyPatch is non-destructive to "source". If the patch couldn't be fully applied "output" will be left set to an empty (default) object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A copy of source with the patch applied to it or an empty object if the patch couldn't be applied. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator associated with the document that holds the source. </td></tr>
    <tr><td class="paramname">target</td><td>The value where the patch will be applied to. </td></tr>
    <tr><td class="paramname">patch</td><td>The value holding the patch information. </td></tr>
    <tr><td class="paramname">approach</td><td>The merge algorithm that will be used to apply the patch on top of the target. </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings to control the way the patch is applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a476fd39201e5023749ebb02b7d3ab2e1" name="a476fd39201e5023749ebb02b7d3ab2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476fd39201e5023749ebb02b7d3ab2e1">&#9670;&#160;</a></span>ApplyPatch() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::ApplyPatch </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document::AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_a_z.html#a408cd8672ae4532f76638045f0746b5e">JsonMergeApproach</a>&#160;</td>
          <td class="paramname"><em>approach</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_json_apply_patch_settings.html">JsonApplyPatchSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="struct_a_z_1_1_json_apply_patch_settings.html">JsonApplyPatchSettings</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges two json values together by applying "patch" to "target" using the selected merge algorithm. This version of ApplyPatch is destructive to "target". If the patch can't be correctly applied it will leave target in a partially patched state. Use the other version of ApplyPatch if target should be copied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The value where the patch will be applied to. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator associated with the document that holds the target. </td></tr>
    <tr><td class="paramname">patch</td><td>The value holding the patch information. </td></tr>
    <tr><td class="paramname">approach</td><td>The merge algorithm that will be used to apply the patch on top of the target. </td></tr>
    <tr><td class="paramname">settings</td><td>Optional additional settings to control the way the patch is applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a336f95f2f73a53915683bc8852dfd421" name="a336f95f2f73a53915683bc8852dfd421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336f95f2f73a53915683bc8852dfd421">&#9670;&#160;</a></span>ApplyPatch() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::ApplyPatch </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document::AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_a_z.html#a408cd8672ae4532f76638045f0746b5e">JsonMergeApproach</a>&#160;</td>
          <td class="paramname"><em>approach</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_json_apply_patch_settings.html">JsonApplyPatchSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges two json values together by applying "patch" to "target" using the selected merge algorithm. This version of ApplyPatch is destructive to "target". If the patch can't be correctly applied it will leave target in a partially patched state. Use the other version of ApplyPatch if target should be copied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The value where the patch will be applied to. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator associated with the document that holds the target. </td></tr>
    <tr><td class="paramname">patch</td><td>The value holding the patch information. </td></tr>
    <tr><td class="paramname">approach</td><td>The merge algorithm that will be used to apply the patch on top of the target. </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings to control the way the patch is applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a021d46663b4b4b81b1e78677f3bf385d" name="a021d46663b4b4b81b1e78677f3bf385d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021d46663b4b4b81b1e78677f3bf385d">&#9670;&#160;</a></span>Compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JsonSerializerCompareResult AZ::JsonSerialization::Compare </td>
          <td>(</td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares two json values of any type and determines if the left is less, equal or greater than the right. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side value for the compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side value for the compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum containing less, equal or greater. In case of an error, the value for the enum will "error". </dd></dl>

</div>
</div>
<a id="a418c6e7f6ce6149c578a28746e17c4b0" name="a418c6e7f6ce6149c578a28746e17c4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418c6e7f6ce6149c578a28746e17c4b0">&#9670;&#160;</a></span>CreatePatch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::CreatePatch </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document::AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_a_z.html#a408cd8672ae4532f76638045f0746b5e">JsonMergeApproach</a>&#160;</td>
          <td class="paramname"><em>approach</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_json_create_patch_settings.html">JsonCreatePatchSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="struct_a_z_1_1_json_create_patch_settings.html">JsonCreatePatchSettings</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a patch using the selected merge algorithm such that when applied to source it results in target. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>The value containing the differences between source and target. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator associated with the document that will hold the patch. </td></tr>
    <tr><td class="paramname">source</td><td>The value used as a starting point. </td></tr>
    <tr><td class="paramname">target</td><td>The value that will result if the patch is applied to the source. </td></tr>
    <tr><td class="paramname">approach</td><td>The algorithm that will be used when the patch is applied to the source. </td></tr>
    <tr><td class="paramname">settings</td><td>Optional additional settings to control the way the patch is created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98cbbe800d40dc1980f49f67b8c5193c" name="a98cbbe800d40dc1980f49f67b8c5193c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98cbbe800d40dc1980f49f67b8c5193c">&#9670;&#160;</a></span>CreatePatch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::CreatePatch </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document::AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_a_z.html#a408cd8672ae4532f76638045f0746b5e">JsonMergeApproach</a>&#160;</td>
          <td class="paramname"><em>approach</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_json_create_patch_settings.html">JsonCreatePatchSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a patch using the selected merge algorithm such that when applied to source it results in target. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>The value containing the differences between source and target. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator associated with the document that will hold the patch. </td></tr>
    <tr><td class="paramname">source</td><td>The value used as a starting point. </td></tr>
    <tr><td class="paramname">target</td><td>The value that will result if the patch is applied to the source. </td></tr>
    <tr><td class="paramname">approach</td><td>The algorithm that will be used when the patch is applied to the source. </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings to control the way the patch is created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a411f8fc95cb8d75ce410068f3f3112e9" name="a411f8fc95cb8d75ce410068f3f3112e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411f8fc95cb8d75ce410068f3f3112e9">&#9670;&#160;</a></span>IsTypeSerializable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_a_z_1_1_registered_reflection_context_result.html">RegisteredReflectionContextResult</a> AZ::JsonSerialization::IsTypeSerializable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_a_z.html#a5c1a2bfc05f03fd482d2fb55fbe82051">AZ::TypeId</a> &amp;&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a>&#160;</td>
          <td class="paramname"><em>settings</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an result structure indicating if the type is reflected using either the <a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> or <a class="el" href="class_a_z_1_1_json_registration_context.html">JsonRegistrationContext</a> If the type is reflected in both contexts, then the <a class="el" href="class_a_z_1_1_json_registration_context.html">JsonRegistrationContext</a> is given preference in that case </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeId</td><td><a class="el" href="namespace_a_z.html" title="Reopen namespace to define DataPatch class.">AZ</a> TypeInfo to query in the <a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> or JSON RegistrationContext </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result structure which is convertible to bool. If the type is either reflected in <a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> or <a class="el" href="class_a_z_1_1_json_registration_context.html">JsonRegistrationContext</a> then it converts to true, otherwise the result structure converts to false </dd></dl>

</div>
</div>
<a id="a79610a6b60a203c6b1f2337b489e373f" name="a79610a6b60a203c6b1f2337b489e373f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79610a6b60a203c6b1f2337b489e373f">&#9670;&#160;</a></span>Load() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::Load </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads the data from the provided json value into the supplied object. The object is expected to be created before calling load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>Object where the data will be loaded into. </td></tr>
    <tr><td class="paramname">root</td><td>The Value or Document where the deserializer will start reading data from. </td></tr>
    <tr><td class="paramname">settings</td><td>Optional additional settings to control the way document is deserialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a814a8c28008f36ecf2e7e25df2631d4b" name="a814a8c28008f36ecf2e7e25df2631d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814a8c28008f36ecf2e7e25df2631d4b">&#9670;&#160;</a></span>Load() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::Load </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads the data from the provided json value into the supplied object. The object is expected to be created before calling load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>Object where the data will be loaded into. </td></tr>
    <tr><td class="paramname">root</td><td>The Value or Document where the deserializer will start reading data from. </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings to control the way document is deserialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a82cbedb064cad9dd5dc94f361a7284" name="a4a82cbedb064cad9dd5dc94f361a7284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a82cbedb064cad9dd5dc94f361a7284">&#9670;&#160;</a></span>Load() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::Load </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>objectType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads the data from the provided json value into the supplied object. The object is expected to be created before calling load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>Pointer to the object where the data will be loaded into. </td></tr>
    <tr><td class="paramname">objectType</td><td>Type id of the object passed in. </td></tr>
    <tr><td class="paramname">root</td><td>The Value or Document from where the deserializer will start reading data. </td></tr>
    <tr><td class="paramname">settings</td><td>Optional additional settings to control the way document is deserialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6453077507b1978252ae5addb307b70" name="ab6453077507b1978252ae5addb307b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6453077507b1978252ae5addb307b70">&#9670;&#160;</a></span>Load() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::Load </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>objectType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads the data from the provided json value into the supplied object. The object is expected to be created before calling load. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>Pointer to the object where the data will be loaded into. </td></tr>
    <tr><td class="paramname">objectType</td><td>Type id of the object passed in. </td></tr>
    <tr><td class="paramname">root</td><td>The Value or Document from where the deserializer will start reading data. </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings to control the way document is deserialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1d78739931d76218a6e2d1498fc0a8b" name="ad1d78739931d76218a6e2d1498fc0a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d78739931d76218a6e2d1498fc0a8b">&#9670;&#160;</a></span>LoadTypeId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::LoadTypeId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> *&#160;</td>
          <td class="paramname"><em>baseClassTypeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>&#160;</td>
          <td class="paramname"><em>jsonPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads the type id from the provided input. Note: it's not recommended to use this function (frequently) as it requires users of the json file to have knowledge of the internal type structure and is therefore harder to use. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeId</td><td>The uuid where the loaded data will be written to. If loading fails this will be a null uuid. </td></tr>
    <tr><td class="paramname">input</td><td>The json node to load from. The node is expected to contain a string. </td></tr>
    <tr><td class="paramname">baseClassTypeId.</td><td>An optional type id for the base class, if known. If a type name is stored in the string which references multiple types then the baseClassTypeId will be used to disambiguate between the different types by looking if exactly one of the types inherits from the base class that baseClassTypeId points to. </td></tr>
    <tr><td class="paramname">jsonPath</td><td>An optional path to the json node. This will be used for reporting. </td></tr>
    <tr><td class="paramname">settings</td><td>Settings object to change where this function collects information from. This can be same settings as used for the other Load functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a343610703da4c73bf612e65549e10376" name="a343610703da4c73bf612e65549e10376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343610703da4c73bf612e65549e10376">&#9670;&#160;</a></span>LoadTypeId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::LoadTypeId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> *&#160;</td>
          <td class="paramname"><em>baseClassTypeId</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>&#160;</td>
          <td class="paramname"><em>jsonPath</em> = <code><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="struct_a_z_1_1_json_deserializer_settings.html">JsonDeserializerSettings</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads the type id from the provided input. Note: it's not recommended to use this function (frequently) as it requires users of the json file to have knowledge of the internal type structure and is therefore harder to use. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeId</td><td>The uuid where the loaded data will be written to. If loading fails this will be a null uuid. </td></tr>
    <tr><td class="paramname">input</td><td>The json node to load from. The node is expected to contain a string. </td></tr>
    <tr><td class="paramname">baseClassTypeId.</td><td>An optional type id for the base class, if known. If a type name is stored in the string which references multiple types then the baseClassTypeId will be used to disambiguate between the different types by looking if exactly one of the types inherits from the base class that baseClassTypeId points to. </td></tr>
    <tr><td class="paramname">jsonPath</td><td>An optional path to the json node. This will be used for reporting. </td></tr>
    <tr><td class="paramname">settings</td><td>Optional settings object to change where this function collects information from. This can be same settings as used for the other Load functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89f3632dcc803b2062b395caa56518c5" name="a89f3632dcc803b2062b395caa56518c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f3632dcc803b2062b395caa56518c5">&#9670;&#160;</a></span>ResolveImports()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::ResolveImports </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>jsonDoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document::AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_json_import_settings.html">JsonImportSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resolves all import directives, including nested imports, in the given document. An importer object needs to be passed in through the settings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jsonDoc</td><td>The json document in which to resolve imports. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator associated with the json document. </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings that control the way the imports are resolved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a383dafc031c92b85938980117bfdc68e" name="a383dafc031c92b85938980117bfdc68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383dafc031c92b85938980117bfdc68e">&#9670;&#160;</a></span>RestoreImports()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::RestoreImports </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>jsonDoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document::AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_json_import_settings.html">JsonImportSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Restores all import directives that were present in the json document. The same importer object that was passed into ResolveImports through the settings needs to be passed here through settings as well. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jsonDoc</td><td>The json document in which to restore imports. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator associated with the json document. </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings that control the way the imports are restored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab18bdf7ef288a00bcf5652d974e04006" name="ab18bdf7ef288a00bcf5652d974e04006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18bdf7ef288a00bcf5652d974e04006">&#9670;&#160;</a></span>Store() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::Store </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document::AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the data in the provided object as json values starting at the provided value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The Value or Document where the converted data will start writing to. </td></tr>
    <tr><td class="paramname">allocator</td><td>The memory allocator used by RapidJSON to create the json document. </td></tr>
    <tr><td class="paramname">object</td><td>The object that will be read from for values to convert. </td></tr>
    <tr><td class="paramname">settings</td><td>Optional additional settings to control the way document is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0db68eae4dad0efe6a0a2118de18ad1a" name="a0db68eae4dad0efe6a0a2118de18ad1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db68eae4dad0efe6a0a2118de18ad1a">&#9670;&#160;</a></span>Store() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::Store </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document::AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>defaultObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the data in the provided object as json values starting at the provided value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The Value or Document where the converted data will start writing to. </td></tr>
    <tr><td class="paramname">allocator</td><td>The memory allocator used by RapidJSON to create the json document. </td></tr>
    <tr><td class="paramname">object</td><td>The object that will be read from for values to convert. </td></tr>
    <tr><td class="paramname">defaultObject</td><td>Default object used to compare the object to in order to determine if values are defaulted or not. If this is argument is provided m_keepDefaults in the settings will automatically be set to true. </td></tr>
    <tr><td class="paramname">settings</td><td>Optional additional settings to control the way document is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a482bbe90b75d0a08925fb9e64fb41236" name="a482bbe90b75d0a08925fb9e64fb41236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482bbe90b75d0a08925fb9e64fb41236">&#9670;&#160;</a></span>Store() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::Store </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document::AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>defaultObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the data in the provided object as json values starting at the provided value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The Value or Document where the converted data will start writing to. </td></tr>
    <tr><td class="paramname">allocator</td><td>The memory allocator used by RapidJSON to create the json document. </td></tr>
    <tr><td class="paramname">object</td><td>The object that will be read from for values to convert. </td></tr>
    <tr><td class="paramname">defaultObject</td><td>Default object used to compare the object to in order to determine if values are defaulted or not. If this is argument is provided m_keepDefaults in the settings will automatically be set to true. </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings to control the way document is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada52f32eba18c59c1c711b36353f4613" name="ada52f32eba18c59c1c711b36353f4613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada52f32eba18c59c1c711b36353f4613">&#9670;&#160;</a></span>Store() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::Store </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document::AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the data in the provided object as json values starting at the provided value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The Value or Document where the converted data will start writing to. </td></tr>
    <tr><td class="paramname">allocator</td><td>The memory allocator used by RapidJSON to create the json document. </td></tr>
    <tr><td class="paramname">object</td><td>The object that will be read from for values to convert. </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings to control the way document is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79a537d3c6cf3e082adb08af3e7e3dc4" name="a79a537d3c6cf3e082adb08af3e7e3dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a537d3c6cf3e082adb08af3e7e3dc4">&#9670;&#160;</a></span>Store() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::Store </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document::AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>defaultObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>objectType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the data in the provided object as json values starting at the provided value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The Value or Document where the converted data will start writing to. </td></tr>
    <tr><td class="paramname">allocator</td><td>The memory allocator used by RapidJSON to create the json document. </td></tr>
    <tr><td class="paramname">object</td><td>Pointer to the object that will be read from for values to convert. </td></tr>
    <tr><td class="paramname">defaultObject</td><td>Pointer to a default object used to compare the object to in order to determine if values are defaulted or not. This argument can be null, in which case a temporary default may be created if required by the settings. If this is argument is provided m_keepDefaults in the settings will automatically be set to true. </td></tr>
    <tr><td class="paramname">objectType</td><td>The type id of the object and default object. </td></tr>
    <tr><td class="paramname">settings</td><td>Optional additional settings to control the way document is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3dbd0fbdc85b3b55298db4dd8c6ac63" name="ac3dbd0fbdc85b3b55298db4dd8c6ac63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3dbd0fbdc85b3b55298db4dd8c6ac63">&#9670;&#160;</a></span>Store() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::Store </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document::AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>defaultObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>objectType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the data in the provided object as json values starting at the provided value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The Value or Document where the converted data will start writing to. </td></tr>
    <tr><td class="paramname">allocator</td><td>The memory allocator used by RapidJSON to create the json document. </td></tr>
    <tr><td class="paramname">object</td><td>Pointer to the object that will be read from for values to convert. </td></tr>
    <tr><td class="paramname">defaultObject</td><td>Pointer to a default object used to compare the object to in order to determine if values are defaulted or not. This argument can be null, in which case a temporary default may be created if required by the settings. If this is argument is provided m_keepDefaults in the settings will automatically be set to true. </td></tr>
    <tr><td class="paramname">objectType</td><td>The type id of the object and default object. </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings to control the way document is serialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3551ba3a22040189cfcf59ef98b197b" name="aa3551ba3a22040189cfcf59ef98b197b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3551ba3a22040189cfcf59ef98b197b">&#9670;&#160;</a></span>StoreTypeId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::StoreTypeId </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document::AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>&#160;</td>
          <td class="paramname"><em>elementPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a name for the type id in the provided output. The name can be safely used to reference a type such as a class during loading. Note: it's not recommended to use this function (frequently) as it requires users of the json file to have knowledge of the internal type structure and is therefore harder to use. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The json value the result will be written to. If successful this will contain a string object otherwise a default object. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator associated with the document that will or already holds the output. </td></tr>
    <tr><td class="paramname">typeId</td><td>The type id to store. </td></tr>
    <tr><td class="paramname">elementPath</td><td>The path to the element. This will be used for reporting. </td></tr>
    <tr><td class="paramname">settings</td><td>Settings to change where this function collects information from. This can be the same settings as used for the other Store functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8e3318316e8de1dabed2a6a73caf63f" name="ae8e3318316e8de1dabed2a6a73caf63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e3318316e8de1dabed2a6a73caf63f">&#9670;&#160;</a></span>StoreTypeId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="union_a_z_1_1_json_serialization_result_1_1_result_code.html">JsonSerializationResult::ResultCode</a> AZ::JsonSerialization::StoreTypeId </td>
          <td>(</td>
          <td class="paramtype">rapidjson::Value &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rapidjson::Document::AllocatorType &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>&#160;</td>
          <td class="paramname"><em>elementPath</em> = <code><a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="struct_a_z_1_1_json_serializer_settings.html">JsonSerializerSettings</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a name for the type id in the provided output. The name can be safely used to reference a type such as a class during loading. Note: it's not recommended to use this function (frequently) as it requires users of the json file to have knowledge of the internal type structure and is therefore harder to use. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The json value the result will be written to. If successful this will contain a string object otherwise a default object. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator associated with the document that will or already holds the output. </td></tr>
    <tr><td class="paramname">typeId</td><td>The type id to store. </td></tr>
    <tr><td class="paramname">elementPath</td><td>An optional path to the element. This will be used for reporting. </td></tr>
    <tr><td class="paramname">settings</td><td>Optional settings to change where this function collects information from. This can be the same settings as used for the other Store functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Code/Framework/AzCore/AzCore/Serialization/Json/JsonSerialization.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><a class="el" href="class_a_z_1_1_json_serialization.html">JsonSerialization</a></li>
    <li class="footer">Generated on Mon Oct 9 2023 13:38:45 for Open 3D Engine AzCore API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
