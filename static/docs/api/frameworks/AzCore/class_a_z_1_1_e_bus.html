<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine AzCore API Reference: AZ::EBus&lt; Interface, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Open 3D Engine AzCore API Reference<span id="projectnumber">&#160;24.09</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_a_z_1_1_e_bus.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_a_z_1_1_e_bus-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AZ::EBus&lt; Interface, Traits &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;EBus.h&gt;</code></p>

<p>Inherits AZ::BusInternal::EBusImpl&lt; AZ::EBus&lt; Interface, BusTraits &gt;, BusInternal::EBusImplTraits&lt; Interface, BusTraits &gt;, BusTraits::BusIdType &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a191954d412a14fbb309224725cc15185" id="r_a191954d412a14fbb309224725cc15185"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a191954d412a14fbb309224725cc15185">ImplTraits</a> = BusInternal::EBusImplTraits&lt;<a class="el" href="class_a_z_1_1_interface.html">Interface</a>, BusTraits&gt;</td></tr>
<tr class="separator:a191954d412a14fbb309224725cc15185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33be6662696ef03e1e20bbbb05fd1533" id="r_a33be6662696ef03e1e20bbbb05fd1533"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33be6662696ef03e1e20bbbb05fd1533">BaseImpl</a> = BusInternal::EBusImpl&lt;<a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt;<a class="el" href="class_a_z_1_1_interface.html">Interface</a>, BusTraits&gt;, BusInternal::EBusImplTraits&lt;<a class="el" href="class_a_z_1_1_interface.html">Interface</a>, BusTraits&gt;, typename BusTraits::BusIdType&gt;</td></tr>
<tr class="separator:a33be6662696ef03e1e20bbbb05fd1533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f61a05d19896191551e96a74909552c" id="r_a9f61a05d19896191551e96a74909552c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> = typename ImplTraits::Traits</td></tr>
<tr class="separator:a9f61a05d19896191551e96a74909552c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a99140670928a17a5ceee693ce6a9e" id="r_af4a99140670928a17a5ceee693ce6a9e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4a99140670928a17a5ceee693ce6a9e">ThisType</a> = <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt;<a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a>&gt;</td></tr>
<tr class="separator:af4a99140670928a17a5ceee693ce6a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e50b2591fd0570de2ae476d4be18a88" id="r_a4e50b2591fd0570de2ae476d4be18a88"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e50b2591fd0570de2ae476d4be18a88">AllocatorType</a> = typename ImplTraits::AllocatorType</td></tr>
<tr class="separator:a4e50b2591fd0570de2ae476d4be18a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834f1a145cd8cc99702a4f02fdaedd57" id="r_a834f1a145cd8cc99702a4f02fdaedd57"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a834f1a145cd8cc99702a4f02fdaedd57">InterfaceType</a> = typename <a class="el" href="class_a_z_1_1_interface.html">ImplTraits::InterfaceType</a></td></tr>
<tr class="separator:a834f1a145cd8cc99702a4f02fdaedd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f1b976267495e8832c3137d84f5c35" id="r_a80f1b976267495e8832c3137d84f5c35"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80f1b976267495e8832c3137d84f5c35">Events</a> = typename <a class="el" href="class_a_z_1_1_interface.html">ImplTraits::Events</a></td></tr>
<tr class="separator:a80f1b976267495e8832c3137d84f5c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a7c6aa1ffb03d37a892a33a940039f" id="r_a01a7c6aa1ffb03d37a892a33a940039f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01a7c6aa1ffb03d37a892a33a940039f">BusIdType</a> = typename ImplTraits::BusIdType</td></tr>
<tr class="separator:a01a7c6aa1ffb03d37a892a33a940039f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cbe7852dade0dd2f2128e0603de77f" id="r_ac1cbe7852dade0dd2f2128e0603de77f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1cbe7852dade0dd2f2128e0603de77f">BusIdOrderCompare</a> = typename ImplTraits::BusIdOrderCompare</td></tr>
<tr class="separator:ac1cbe7852dade0dd2f2128e0603de77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0482324bd02c568113083495e43708eb" id="r_a0482324bd02c568113083495e43708eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0482324bd02c568113083495e43708eb">MutexType</a> = typename ImplTraits::MutexType</td></tr>
<tr class="separator:a0482324bd02c568113083495e43708eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95604429c02119c83b9f2be53d547fd" id="r_ad95604429c02119c83b9f2be53d547fd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad95604429c02119c83b9f2be53d547fd">BusesContainer</a> = typename ImplTraits::BusesContainer</td></tr>
<tr class="separator:ad95604429c02119c83b9f2be53d547fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41222cf09b987c26a3fb9cbba507b17" id="r_ac41222cf09b987c26a3fb9cbba507b17"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac41222cf09b987c26a3fb9cbba507b17">EventQueueMutexType</a> = typename ImplTraits::EventQueueMutexType</td></tr>
<tr class="separator:ac41222cf09b987c26a3fb9cbba507b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff36a6a1d1eef9d10218a0dc1d23162" id="r_acff36a6a1d1eef9d10218a0dc1d23162"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acff36a6a1d1eef9d10218a0dc1d23162">BusPtr</a> = typename ImplTraits::BusPtr</td></tr>
<tr class="separator:acff36a6a1d1eef9d10218a0dc1d23162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3786afaf46610dae0168bf7c7d19646" id="r_ad3786afaf46610dae0168bf7c7d19646"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3786afaf46610dae0168bf7c7d19646">HandlerNode</a> = typename ImplTraits::HandlerNode</td></tr>
<tr class="separator:ad3786afaf46610dae0168bf7c7d19646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369a569e391367103134880bc4f5c4f7" id="r_a369a569e391367103134880bc4f5c4f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a369a569e391367103134880bc4f5c4f7">QueuePolicy</a> = <a class="el" href="struct_a_z_1_1_e_bus_queue_policy.html">EBusQueuePolicy</a>&lt;Traits::EnableEventQueue, <a class="el" href="#af4a99140670928a17a5ceee693ce6a9e">ThisType</a>, <a class="el" href="#ac41222cf09b987c26a3fb9cbba507b17">EventQueueMutexType</a>&gt;</td></tr>
<tr class="separator:a369a569e391367103134880bc4f5c4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600a59b271beea29179b216eb91e296e" id="r_a600a59b271beea29179b216eb91e296e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a600a59b271beea29179b216eb91e296e">ConnectionPolicy</a> = typename Traits::template <a class="el" href="#a600a59b271beea29179b216eb91e296e">ConnectionPolicy</a>&lt;<a class="el" href="#af4a99140670928a17a5ceee693ce6a9e">ThisType</a>&gt;</td></tr>
<tr class="separator:a600a59b271beea29179b216eb91e296e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61672aeb0c65e7e731b8f7c995df01ba" id="r_a61672aeb0c65e7e731b8f7c995df01ba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61672aeb0c65e7e731b8f7c995df01ba">CallstackEntry</a> = AZ::Internal::CallstackEntry&lt;<a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a>&gt;</td></tr>
<tr class="separator:a61672aeb0c65e7e731b8f7c995df01ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8845d894aa6543211e1f2067e756428a" id="r_a8845d894aa6543211e1f2067e756428a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8845d894aa6543211e1f2067e756428a">Router</a> = AZ::Internal::EBusRouter&lt;<a class="el" href="#af4a99140670928a17a5ceee693ce6a9e">ThisType</a>&gt;</td></tr>
<tr class="separator:a8845d894aa6543211e1f2067e756428a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4a71ccd88d5eaee8d2f516eac30f56" id="r_ace4a71ccd88d5eaee8d2f516eac30f56"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace4a71ccd88d5eaee8d2f516eac30f56">NestedVersionRouter</a> = AZ::Internal::EBusNestedVersionRouter&lt;<a class="el" href="#af4a99140670928a17a5ceee693ce6a9e">ThisType</a>&gt;</td></tr>
<tr class="separator:ace4a71ccd88d5eaee8d2f516eac30f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff20b003fa96f9746087cae939327801" id="r_aff20b003fa96f9746087cae939327801"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff20b003fa96f9746087cae939327801">RouterPolicy</a> = typename Traits::template <a class="el" href="#aff20b003fa96f9746087cae939327801">RouterPolicy</a>&lt;<a class="el" href="#af4a99140670928a17a5ceee693ce6a9e">ThisType</a>&gt;</td></tr>
<tr class="separator:aff20b003fa96f9746087cae939327801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534d207db63f1bce6db58a398f3954f0" id="r_a534d207db63f1bce6db58a398f3954f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a534d207db63f1bce6db58a398f3954f0">RouterProcessingState</a> = typename RouterPolicy::EventProcessingState</td></tr>
<tr class="separator:a534d207db63f1bce6db58a398f3954f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737237a6c0c9b99f63d30b6dcee9bc48" id="r_a737237a6c0c9b99f63d30b6dcee9bc48"><td class="memTemplParams" colspan="2">template&lt;typename DispatchMutex &gt; </td></tr>
<tr class="memitem:a737237a6c0c9b99f63d30b6dcee9bc48"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a737237a6c0c9b99f63d30b6dcee9bc48">DispatchLockGuardTemplate</a> = typename ImplTraits::template DispatchLockGuard&lt;DispatchMutex&gt;</td></tr>
<tr class="separator:a737237a6c0c9b99f63d30b6dcee9bc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f8d78c9abdae1419a7e3d75a7976b6" id="r_a04f8d78c9abdae1419a7e3d75a7976b6"><td class="memTemplParams" colspan="2">template&lt;typename ContextMutexType &gt; </td></tr>
<tr class="memitem:a04f8d78c9abdae1419a7e3d75a7976b6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a04f8d78c9abdae1419a7e3d75a7976b6">ConnectLockGuardTemplate</a> = typename ImplTraits::template ConnectLockGuard&lt;ContextMutexType&gt;</td></tr>
<tr class="separator:a04f8d78c9abdae1419a7e3d75a7976b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4638c464ae72563e4f50488831e18549" id="r_a4638c464ae72563e4f50488831e18549"><td class="memTemplParams" colspan="2">template&lt;typename ContextMutexType &gt; </td></tr>
<tr class="memitem:a4638c464ae72563e4f50488831e18549"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4638c464ae72563e4f50488831e18549">BindLockGuardTemplate</a> = typename ImplTraits::template BindLockGuard&lt;ContextMutexType&gt;</td></tr>
<tr class="separator:a4638c464ae72563e4f50488831e18549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f70ab2c71a5a318a086c324b3cfdf6" id="r_a25f70ab2c71a5a318a086c324b3cfdf6"><td class="memTemplParams" colspan="2">template&lt;typename ContextMutexType &gt; </td></tr>
<tr class="memitem:a25f70ab2c71a5a318a086c324b3cfdf6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a25f70ab2c71a5a318a086c324b3cfdf6">CallstackTrackerLockGuardTemplate</a> = typename ImplTraits::template CallstackTrackerLockGuard&lt;ContextMutexType&gt;</td></tr>
<tr class="separator:a25f70ab2c71a5a318a086c324b3cfdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4b097e2aa258cb2542fa19af800b28" id="r_a1e4b097e2aa258cb2542fa19af800b28"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e4b097e2aa258cb2542fa19af800b28">StoragePolicy</a> = typename Traits::template <a class="el" href="#a1e4b097e2aa258cb2542fa19af800b28">StoragePolicy</a>&lt;Context&gt;</td></tr>
<tr class="separator:a1e4b097e2aa258cb2542fa19af800b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b5b200f3814ca559ff9e7a043f5957" id="r_ae8b5b200f3814ca559ff9e7a043f5957"><td class="memItemLeft" align="right" valign="top"><a id="ae8b5b200f3814ca559ff9e7a043f5957" name="ae8b5b200f3814ca559ff9e7a043f5957"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ConnectLockGuard</b> = typename Context::ConnectLockGuard</td></tr>
<tr class="separator:ae8b5b200f3814ca559ff9e7a043f5957"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad8bd1c39f535bd845cc864d55edd0688" id="r_ad8bd1c39f535bd845cc864d55edd0688"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8bd1c39f535bd845cc864d55edd0688">GetTotalNumOfEventHandlers</a> ()</td></tr>
<tr class="separator:ad8bd1c39f535bd845cc864d55edd0688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eaba0941e16d413d0e3db51386ffe23" id="r_a9eaba0941e16d413d0e3db51386ffe23"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eaba0941e16d413d0e3db51386ffe23">HasHandlers</a> ()</td></tr>
<tr class="separator:a9eaba0941e16d413d0e3db51386ffe23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dced274d351314898c455c850a0294" id="r_ac7dced274d351314898c455c850a0294"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7dced274d351314898c455c850a0294">HasHandlers</a> (const <a class="el" href="#a01a7c6aa1ffb03d37a892a33a940039f">BusIdType</a> &amp;id)</td></tr>
<tr class="separator:ac7dced274d351314898c455c850a0294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae660e0fb2adc517c243c512caf4e5bf9" id="r_ae660e0fb2adc517c243c512caf4e5bf9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae660e0fb2adc517c243c512caf4e5bf9">HasHandlers</a> (const <a class="el" href="#acff36a6a1d1eef9d10218a0dc1d23162">BusPtr</a> &amp;ptr)</td></tr>
<tr class="separator:ae660e0fb2adc517c243c512caf4e5bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a470da8f1eddf6e2ad5aa30f7dcdabf" id="r_a1a470da8f1eddf6e2ad5aa30f7dcdabf"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="#a01a7c6aa1ffb03d37a892a33a940039f">BusIdType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a470da8f1eddf6e2ad5aa30f7dcdabf">GetCurrentBusId</a> ()</td></tr>
<tr class="separator:a1a470da8f1eddf6e2ad5aa30f7dcdabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab666800ef63443fc37e2179b32f7a59e" id="r_ab666800ef63443fc37e2179b32f7a59e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab666800ef63443fc37e2179b32f7a59e">HasReentrantEBusUseThisThread</a> (const <a class="el" href="#a01a7c6aa1ffb03d37a892a33a940039f">BusIdType</a> *busId=<a class="el" href="#a1a470da8f1eddf6e2ad5aa30f7dcdabf">GetCurrentBusId</a>())</td></tr>
<tr class="separator:ab666800ef63443fc37e2179b32f7a59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2b5ba3bd36cdb87cbb690ccf4fcee4" id="r_a6b2b5ba3bd36cdb87cbb690ccf4fcee4"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b2b5ba3bd36cdb87cbb690ccf4fcee4">GetName</a> ()</td></tr>
<tr class="separator:a6b2b5ba3bd36cdb87cbb690ccf4fcee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9522c24e0e1d49fbbc37a9e8ea475d5c" id="r_a9522c24e0e1d49fbbc37a9e8ea475d5c"><td class="memItemLeft" align="right" valign="top">static Context *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9522c24e0e1d49fbbc37a9e8ea475d5c">GetContext</a> (bool trackCallstack=true)</td></tr>
<tr class="separator:a9522c24e0e1d49fbbc37a9e8ea475d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07aa45a280e52a2bf3e80da52c2642ee" id="r_a07aa45a280e52a2bf3e80da52c2642ee"><td class="memItemLeft" align="right" valign="top">static Context &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07aa45a280e52a2bf3e80da52c2642ee">GetOrCreateContext</a> (bool trackCallstack=true)</td></tr>
<tr class="separator:a07aa45a280e52a2bf3e80da52c2642ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1242e239f2dcaf273b4da1f7ae2c44" id="r_add1242e239f2dcaf273b4da1f7ae2c44"><td class="memItemLeft" align="right" valign="top"><a id="add1242e239f2dcaf273b4da1f7ae2c44" name="add1242e239f2dcaf273b4da1f7ae2c44"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsInDispatch</b> (Context *context=<a class="el" href="#a9522c24e0e1d49fbbc37a9e8ea475d5c">GetContext</a>(false))</td></tr>
<tr class="separator:add1242e239f2dcaf273b4da1f7ae2c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8002f85a570382d5431bf83a058a05" id="r_a3f8002f85a570382d5431bf83a058a05"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f8002f85a570382d5431bf83a058a05">IsInDispatchThisThread</a> (Context *context=<a class="el" href="#a9522c24e0e1d49fbbc37a9e8ea475d5c">GetContext</a>(false))</td></tr>
<tr class="separator:a3f8002f85a570382d5431bf83a058a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a2d9116141ff60df3ea46fdc93a969c88" id="r_a2d9116141ff60df3ea46fdc93a969c88"><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d9116141ff60df3ea46fdc93a969c88">EnableEventQueue</a> = ImplTraits::EnableEventQueue</td></tr>
<tr class="separator:a2d9116141ff60df3ea46fdc93a969c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d94740bf37e7d5894d562b6f0de6dc" id="r_a88d94740bf37e7d5894d562b6f0de6dc"><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88d94740bf37e7d5894d562b6f0de6dc">HasId</a> = Traits::AddressPolicy != <a class="el" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873a66ba162102bbf6ae31b522aec561735e">EBusAddressPolicy::Single</a></td></tr>
<tr class="separator:a88d94740bf37e7d5894d562b6f0de6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a>&gt;<br />
class AZ::EBus&lt; Interface, Traits &gt;</div><p><a class="el" href="class_a_z_1_1_event.html">Event</a> buses (EBuses) are a general-purpose communication system that Open 3D Engine uses to dispatch notifications and receive requests.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_a_z_1_1_interface.html">Interface</a></td><td>A class whose virtual functions define the events dispatched or received by the EBus. </td></tr>
    <tr><td class="paramname">Traits</td><td>A class that inherits from <a class="el" href="struct_a_z_1_1_e_bus_traits.html">EBusTraits</a> and configures the EBus. This parameter may be left unspecified if the <code><a class="el" href="class_a_z_1_1_interface.html">Interface</a></code> class inherits from <a class="el" href="struct_a_z_1_1_e_bus_traits.html">EBusTraits</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>EBuses are configurable and support many different use cases. For more information about EBuses, see <a href="https://o3de.org/docs/user-guide/engine/ebus/">Event Bus</a> and <a href="https://o3de.org/docs/user-guide/components/development/entity-system-pg-components-ebuses-best-practices/">Components and EBuses: Best Practices</a> in the <em>Open 3D Engine Developer Guide</em>.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
How Components Use EBuses</h2>
<p>Components commonly use EBuses in two ways: to dispatch events or to handle requests. A bus that dispatches events is a <em>notification bus</em>. A bus that receives requests is a <em>request bus</em>. Some components provide one type of bus, and some components provide both types. Some components do not provide an EBus at all. You use the EBus class for both EBus types, but you configure the EBuses differently. The following sections show how to set up and configure notification buses, event handlers, and request buses.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Notification Buses</h2>
<p>Notification buses dispatch events. The events are received by <em>handlers</em>, which implement a function to handle the event. Handlers first connect to the bus. When the bus dispatches an event, the handler's function executes. This section shows how to set up a notification bus to dispatch an event and a handler to receive the event.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Setting up a Notification Bus</h3>
<p>To set up a bus to dispatch events, do the following:</p><ol type="1">
<li>Define a class that inherits from <a class="el" href="struct_a_z_1_1_e_bus_traits.html">EBusTraits</a>. This class will be the interface for the EBus.</li>
<li>Override individual <a class="el" href="struct_a_z_1_1_e_bus_traits.html">EBusTraits</a> properties to define the behavior of your bus. Three <a class="el" href="struct_a_z_1_1_e_bus_traits.html">EBusTraits</a> that notification buses commonly override are <code>AddressPolicy</code>, which defines how many addresses the EBus contains, <code>HandlerPolicy</code>, which describes how many handlers can connect to each address, and <code>BusIdType</code>, which is the type of ID that is used to address the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> if addresses are used. For example, notification buses often need to have multiple addresses, with the addresses identified by entity ID. To do so, they override the default <code>AddressPolicy</code> with <a class="el" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873adb4f7ff88b3cc15c6c585c284600a3dd">EBusAddressPolicy::ById</a> and set the <code>BusIdType</code> to <a class="el" href="class_a_z_1_1_entity_id.html">EntityId</a>.</li>
<li>Declare a function for each event that the EBus will dispatch. Handler classes will implement these functions to handle the events.</li>
<li>Declare an EBus that takes your class as a template parameter.</li>
<li>Send events. The function that you use to send the event depends on which addresses you want to send the event to, whether to return a value, the order in which to call the handlers, and whether to queue the event.<ul>
<li>To send an event to all handlers connected to the EBus, use Broadcast(). If an EBus has multiple addresses, you can use Event() to send the event only to handlers connected at the specified ID. For performance-critical code, you can avoid an address lookup by using Event() variants that take a pointer instead of an ID.</li>
<li>If an event returns a value, use BroadcastResult() or EventResult() to get the result.</li>
<li>If you want handlers to receive the events in reverse order, use BroadcastReverse() or EventReverse().</li>
<li>To send events asynchronously, queue the event. Queued events are not executed until the queue is flushed. To support queuing, set the <a class="el" href="#a2d9116141ff60df3ea46fdc93a969c88">EnableEventQueue</a> trait. To queue events, use <code>QueueBroadcast()</code> or <code>QueueEvent()</code>. To flush the event queue, use <code>ExecuteQueuedEvents()</code>.</li>
</ul>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md9"></a>
Setting up a Handler</h3>
<p>To enable a handler class to handle the events dispatched by a notification bus, do the following:</p><ol type="1">
<li>Derive your handler class from <code>&lt;BusName&gt;::Handler</code>. For example, a class that needs to handle tick requests should derive from TickRequestBus::Handler.</li>
<li>Implement the EBus interface to define how the handler class should handle the events. In the tick bus example, a handler class would implement <code>OnTick()</code>.</li>
<li>Connect and disconnect from the bus at the appropriate places within your handler class's code. Use <code>&lt;BusName&gt;:Handler::BusConnect()</code> to connect to the bus and <code>&lt;BusName&gt;:Handler::BusDisconnect()</code> to disconnect from the bus. If the handler class is a component, connect to the bus in <code>Activate()</code> and disconnect from the bus in <code>Deactivate()</code>. Non-components typically connect in the constructor and disconnect in the destructor.</li>
</ol>
<h2><a class="anchor" id="autotoc_md10"></a>
Request Buses</h2>
<p>A request bus receives and handles requests. Typically, only one class handles requests for a request bus. </p>
<h3><a class="anchor" id="autotoc_md11"></a>
Setting up a Request Bus</h3>
<p>The first several steps for setting up a request bus are similar to setting up a notification bus. After that you also need to implement the handlers for handling the requests. To set up a request bus, do the following:</p><ol type="1">
<li>Define a class that inherits from <a class="el" href="struct_a_z_1_1_e_bus_traits.html">EBusTraits</a>. This class will be the interface for requests made to the EBus.</li>
<li>Override individual <a class="el" href="struct_a_z_1_1_e_bus_traits.html">EBusTraits</a> properties to define the behavior of your bus. Two <a class="el" href="struct_a_z_1_1_e_bus_traits.html">EBusTraits</a> that request buses commonly override are <code>AddressPolicy</code>, which defines how many addresses the EBus contains, and <code>HandlerPolicy</code>, which describes how many handlers can connect to each address. For example, because there is typically only one handler class for each request bus, request buses typically override the default handler policy with <a class="el" href="namespace_a_z.html#a32ca3a3605e97c0cd07dbfa805bf3e82a66ba162102bbf6ae31b522aec561735e">EBusHandlerPolicy::Single</a>.</li>
<li>Declare a function for each event that the handler class will receive requests about. These are the functions that other classes will use to make requests of the handler class.</li>
<li>Declare an EBus that takes your class as a template parameter.</li>
<li>Implement a handler for the events as described in the previous section ("Setting up a Handler"). </li>
</ol>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a4e50b2591fd0570de2ae476d4be18a88" name="a4e50b2591fd0570de2ae476d4be18a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e50b2591fd0570de2ae476d4be18a88">&#9670;&#160;</a></span>AllocatorType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::AllocatorType = typename ImplTraits::AllocatorType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocator used by the EBus. The default setting is <a class="el" href="class_a_z_std_1_1allocator.html">AZStd::allocator</a>, which uses <a class="el" href="class_a_z_1_1_system_allocator.html">AZ::SystemAllocator</a>. </p>

</div>
</div>
<a id="a33be6662696ef03e1e20bbbb05fd1533" name="a33be6662696ef03e1e20bbbb05fd1533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33be6662696ef03e1e20bbbb05fd1533">&#9670;&#160;</a></span>BaseImpl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::BaseImpl = BusInternal::EBusImpl&lt;<a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt;<a class="el" href="class_a_z_1_1_interface.html">Interface</a>, BusTraits&gt;, BusInternal::EBusImplTraits&lt;<a class="el" href="class_a_z_1_1_interface.html">Interface</a>, BusTraits&gt;, typename BusTraits::BusIdType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents an EBus with certain broadcast, event, and routing functionality. </p>

</div>
</div>
<a id="a4638c464ae72563e4f50488831e18549" name="a4638c464ae72563e4f50488831e18549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4638c464ae72563e4f50488831e18549">&#9670;&#160;</a></span>BindLockGuardTemplate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
<div class="memtemplate">
template&lt;typename ContextMutexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::BindLockGuardTemplate = typename ImplTraits::template BindLockGuard&lt;ContextMutexType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template Lock Guard class that wraps around the Mutex the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> uses for Bus Bind calls. </p>

</div>
</div>
<a id="ad95604429c02119c83b9f2be53d547fd" name="ad95604429c02119c83b9f2be53d547fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95604429c02119c83b9f2be53d547fd">&#9670;&#160;</a></span>BusesContainer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::BusesContainer = typename ImplTraits::BusesContainer</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contains all of the addresses on the EBus. </p>

</div>
</div>
<a id="ac1cbe7852dade0dd2f2128e0603de77f" name="ac1cbe7852dade0dd2f2128e0603de77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cbe7852dade0dd2f2128e0603de77f">&#9670;&#160;</a></span>BusIdOrderCompare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::BusIdOrderCompare = typename ImplTraits::BusIdOrderCompare</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorting function for EBus address IDs. Used only when the address policy is <a class="el" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873a55b30499fbf765bf728b168a1bf36410">AZ::EBusAddressPolicy::ByIdAndOrdered</a>. If an event is dispatched without an ID, this function determines the order in which each address receives the event.</p>
<p>The following example shows a sorting function that meets these requirements. </p><div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="#ac1cbe7852dade0dd2f2128e0603de77f">BusIdOrderCompare</a> = <a class="code hl_struct" href="struct_a_z_std_1_1less.html">AZStd::less&lt;BusIdType&gt;</a>; <span class="comment">// Lesser IDs first.</span></div>
<div class="ttc" id="aclass_a_z_1_1_e_bus_html_ac1cbe7852dade0dd2f2128e0603de77f"><div class="ttname"><a href="#ac1cbe7852dade0dd2f2128e0603de77f">AZ::EBus::BusIdOrderCompare</a></div><div class="ttdeci">typename ImplTraits::BusIdOrderCompare BusIdOrderCompare</div><div class="ttdef"><b>Definition</b> EBus.h:465</div></div>
<div class="ttc" id="astruct_a_z_std_1_1less_html"><div class="ttname"><a href="struct_a_z_std_1_1less.html">AZStd::less</a></div><div class="ttdef"><b>Definition</b> functional_basic.h:179</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a01a7c6aa1ffb03d37a892a33a940039f" name="a01a7c6aa1ffb03d37a892a33a940039f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a7c6aa1ffb03d37a892a33a940039f">&#9670;&#160;</a></span>BusIdType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::BusIdType = typename ImplTraits::BusIdType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of ID that is used to address the EBus. Used only when the address policy is <a class="el" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873adb4f7ff88b3cc15c6c585c284600a3dd">AZ::EBusAddressPolicy::ById</a> or <a class="el" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873a55b30499fbf765bf728b168a1bf36410">AZ::EBusAddressPolicy::ByIdAndOrdered</a>. The type must support <code><a class="el" href="struct_a_z_std_1_1hash.html" title="Default template (just try to cast the value to size_t)">AZStd::hash</a>&lt;ID&gt;</code> and <code>bool operator==(const ID&amp;, const ID&amp;)</code>. </p>

</div>
</div>
<a id="acff36a6a1d1eef9d10218a0dc1d23162" name="acff36a6a1d1eef9d10218a0dc1d23162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff36a6a1d1eef9d10218a0dc1d23162">&#9670;&#160;</a></span>BusPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::BusPtr = typename ImplTraits::BusPtr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to an address on the bus. </p>

</div>
</div>
<a id="a61672aeb0c65e7e731b8f7c995df01ba" name="a61672aeb0c65e7e731b8f7c995df01ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61672aeb0c65e7e731b8f7c995df01ba">&#9670;&#160;</a></span>CallstackEntry</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::CallstackEntry = AZ::Internal::CallstackEntry&lt;<a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to manually create a callstack entry for a call (often used by ConnectionPolicy) </p>

</div>
</div>
<a id="a25f70ab2c71a5a318a086c324b3cfdf6" name="a25f70ab2c71a5a318a086c324b3cfdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f70ab2c71a5a318a086c324b3cfdf6">&#9670;&#160;</a></span>CallstackTrackerLockGuardTemplate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
<div class="memtemplate">
template&lt;typename ContextMutexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::CallstackTrackerLockGuardTemplate = typename ImplTraits::template CallstackTrackerLockGuard&lt;ContextMutexType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template Lock Guard class that wraps around the Mutex the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> uses for Bus callstack tracking. </p>

</div>
</div>
<a id="a600a59b271beea29179b216eb91e296e" name="a600a59b271beea29179b216eb91e296e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600a59b271beea29179b216eb91e296e">&#9670;&#160;</a></span>ConnectionPolicy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::ConnectionPolicy = typename Traits::template <a class="el" href="#a600a59b271beea29179b216eb91e296e">ConnectionPolicy</a>&lt;<a class="el" href="#af4a99140670928a17a5ceee693ce6a9e">ThisType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables custom logic to run when a handler connects to or disconnects from the EBus. For example, you can make a handler execute an event immediately upon connecting to the EBus. For available settings, see <a class="el" href="struct_a_z_1_1_e_bus_connection_policy.html">AZ::EBusConnectionPolicy</a>. By default, no extra logic is run. </p>

</div>
</div>
<a id="a04f8d78c9abdae1419a7e3d75a7976b6" name="a04f8d78c9abdae1419a7e3d75a7976b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f8d78c9abdae1419a7e3d75a7976b6">&#9670;&#160;</a></span>ConnectLockGuardTemplate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
<div class="memtemplate">
template&lt;typename ContextMutexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::ConnectLockGuardTemplate = typename ImplTraits::template ConnectLockGuard&lt;ContextMutexType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template Lock Guard class that wraps around the Mutex the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> uses for Bus Connects / Disconnects. </p>

</div>
</div>
<a id="a737237a6c0c9b99f63d30b6dcee9bc48" name="a737237a6c0c9b99f63d30b6dcee9bc48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737237a6c0c9b99f63d30b6dcee9bc48">&#9670;&#160;</a></span>DispatchLockGuardTemplate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
<div class="memtemplate">
template&lt;typename DispatchMutex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::DispatchLockGuardTemplate = typename ImplTraits::template DispatchLockGuard&lt;DispatchMutex&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template Lock Guard class that wraps around the Mutex The <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> uses for Dispatching Events. This is not <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> Context Mutex when LocklessDispatch is set </p>

</div>
</div>
<a id="ac41222cf09b987c26a3fb9cbba507b17" name="ac41222cf09b987c26a3fb9cbba507b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41222cf09b987c26a3fb9cbba507b17">&#9670;&#160;</a></span>EventQueueMutexType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::EventQueueMutexType = typename ImplTraits::EventQueueMutexType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locking primitive that is used when executing events in the event queue. </p>

</div>
</div>
<a id="a80f1b976267495e8832c3137d84f5c35" name="a80f1b976267495e8832c3137d84f5c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f1b976267495e8832c3137d84f5c35">&#9670;&#160;</a></span>Events</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::Events = typename <a class="el" href="class_a_z_1_1_interface.html">ImplTraits::Events</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The events that are defined by the EBus interface. </p>

</div>
</div>
<a id="ad3786afaf46610dae0168bf7c7d19646" name="ad3786afaf46610dae0168bf7c7d19646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3786afaf46610dae0168bf7c7d19646">&#9670;&#160;</a></span>HandlerNode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::HandlerNode = typename ImplTraits::HandlerNode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to a handler node. </p>

</div>
</div>
<a id="a191954d412a14fbb309224725cc15185" name="a191954d412a14fbb309224725cc15185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191954d412a14fbb309224725cc15185">&#9670;&#160;</a></span>ImplTraits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::ImplTraits = BusInternal::EBusImplTraits&lt;<a class="el" href="class_a_z_1_1_interface.html">Interface</a>, BusTraits&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contains data about <a class="el" href="struct_a_z_1_1_e_bus_traits.html">EBusTraits</a>. </p>

</div>
</div>
<a id="a834f1a145cd8cc99702a4f02fdaedd57" name="a834f1a145cd8cc99702a4f02fdaedd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834f1a145cd8cc99702a4f02fdaedd57">&#9670;&#160;</a></span>InterfaceType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::InterfaceType = typename <a class="el" href="class_a_z_1_1_interface.html">ImplTraits::InterfaceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The class that defines the interface of the EBus. </p>

</div>
</div>
<a id="a0482324bd02c568113083495e43708eb" name="a0482324bd02c568113083495e43708eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0482324bd02c568113083495e43708eb">&#9670;&#160;</a></span>MutexType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::MutexType = typename ImplTraits::MutexType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locking primitive that is used when connecting handlers to the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> or executing events. By default, all access is assumed to be single threaded and no locking occurs. For multithreaded access, specify a mutex of the following type.</p><ul>
<li>For simple multithreaded cases, use <a class="el" href="class_a_z_std_1_1mutex.html">AZStd::mutex</a>.</li>
<li>For multithreaded cases where an event handler sends a new event on the same bus or connects/disconnects while handling an event on the same bus, use <a class="el" href="class_a_z_std_1_1recursive__mutex.html">AZStd::recursive_mutex</a>. </li>
</ul>

</div>
</div>
<a id="ace4a71ccd88d5eaee8d2f516eac30f56" name="ace4a71ccd88d5eaee8d2f516eac30f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4a71ccd88d5eaee8d2f516eac30f56">&#9670;&#160;</a></span>NestedVersionRouter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::NestedVersionRouter = AZ::Internal::EBusNestedVersionRouter&lt;<a class="el" href="#af4a99140670928a17a5ceee693ce6a9e">ThisType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Class that implements an EBus version router. </p>

</div>
</div>
<a id="a369a569e391367103134880bc4f5c4f7" name="a369a569e391367103134880bc4f5c4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369a569e391367103134880bc4f5c4f7">&#9670;&#160;</a></span>QueuePolicy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::QueuePolicy = <a class="el" href="struct_a_z_1_1_e_bus_queue_policy.html">EBusQueuePolicy</a>&lt;Traits::EnableEventQueue, <a class="el" href="#af4a99140670928a17a5ceee693ce6a9e">ThisType</a>, <a class="el" href="#ac41222cf09b987c26a3fb9cbba507b17">EventQueueMutexType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Policy for the function queue. </p>

</div>
</div>
<a id="a8845d894aa6543211e1f2067e756428a" name="a8845d894aa6543211e1f2067e756428a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8845d894aa6543211e1f2067e756428a">&#9670;&#160;</a></span>Router</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::Router = AZ::Internal::EBusRouter&lt;<a class="el" href="#af4a99140670928a17a5ceee693ce6a9e">ThisType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Class that implements EBus routing functionality. </p>

</div>
</div>
<a id="aff20b003fa96f9746087cae939327801" name="aff20b003fa96f9746087cae939327801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff20b003fa96f9746087cae939327801">&#9670;&#160;</a></span>RouterPolicy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::RouterPolicy = typename Traits::template <a class="el" href="#aff20b003fa96f9746087cae939327801">RouterPolicy</a>&lt;<a class="el" href="#af4a99140670928a17a5ceee693ce6a9e">ThisType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls the flow of EBus events. Enables an event to be forwarded, and possibly stopped, before reaching the normal event handlers. Use cases for routing include tracing, debugging, and versioning an EBus. The default <code>EBusRouterPolicy</code> forwards the event to each connected <code>EBusRouterNode</code> before sending the event to the normal handlers. Each node can stop the event or let it continue. </p>

</div>
</div>
<a id="a534d207db63f1bce6db58a398f3954f0" name="a534d207db63f1bce6db58a398f3954f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534d207db63f1bce6db58a398f3954f0">&#9670;&#160;</a></span>RouterProcessingState</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::RouterProcessingState = typename RouterPolicy::EventProcessingState</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>State that indicates whether to continue routing the event, skip all handlers but notify other routers, or stop processing the event. </p>

</div>
</div>
<a id="a1e4b097e2aa258cb2542fa19af800b28" name="a1e4b097e2aa258cb2542fa19af800b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4b097e2aa258cb2542fa19af800b28">&#9670;&#160;</a></span>StoragePolicy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::StoragePolicy = typename Traits::template <a class="el" href="#a1e4b097e2aa258cb2542fa19af800b28">StoragePolicy</a>&lt;Context&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies where EBus data is stored. This drives how many instances of this EBus exist at runtime. Available storage policies include the following:</p><ul>
<li>(Default) <a class="el" href="struct_a_z_1_1_e_bus_environment_storage_policy.html">EBusEnvironmentStoragePolicy</a> - EBus data is stored in the <a class="el" href="namespace_a_z_1_1_environment.html">AZ::Environment</a>. With this policy, a single EBus instance is shared across all modules (DLLs) that attach to the <a class="el" href="namespace_a_z_1_1_environment.html">AZ::Environment</a>.</li>
<li><a class="el" href="struct_a_z_1_1_e_bus_global_storage_policy.html">EBusGlobalStoragePolicy</a> - EBus data is stored in a global static variable. With this policy, each module (DLL) has its own instance of the EBus.</li>
<li><a class="el" href="struct_a_z_1_1_e_bus_thread_local_storage_policy.html">EBusThreadLocalStoragePolicy</a> - EBus data is stored in a thread_local static variable. With this policy, each thread has its own instance of the EBus. </li>
</ul>

</div>
</div>
<a id="af4a99140670928a17a5ceee693ce6a9e" name="af4a99140670928a17a5ceee693ce6a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a99140670928a17a5ceee693ce6a9e">&#9670;&#160;</a></span>ThisType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::ThisType = <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt;<a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of EBus, which is defined by the interface and the <a class="el" href="struct_a_z_1_1_e_bus_traits.html">EBusTraits</a>. </p>

</div>
</div>
<a id="a9f61a05d19896191551e96a74909552c" name="a9f61a05d19896191551e96a74909552c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f61a05d19896191551e96a74909552c">&#9670;&#160;</a></span>Traits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::Traits = typename ImplTraits::Traits</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias for <a class="el" href="struct_a_z_1_1_e_bus_traits.html">EBusTraits</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9522c24e0e1d49fbbc37a9e8ea475d5c" name="a9522c24e0e1d49fbbc37a9e8ea475d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9522c24e0e1d49fbbc37a9e8ea475d5c">&#9670;&#160;</a></span>GetContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , class <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_1_1_e_bus.html">EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::Context * <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::GetContext </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trackCallstack</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the global bus data (if it was created). Depending on the storage policy, there might be one or multiple instances of the bus data. </p><dl class="section return"><dt>Returns</dt><dd>A reference to the bus context. </dd></dl>

</div>
</div>
<a id="a1a470da8f1eddf6e2ad5aa30f7dcdabf" name="a1a470da8f1eddf6e2ad5aa30f7dcdabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a470da8f1eddf6e2ad5aa30f7dcdabf">&#9670;&#160;</a></span>GetCurrentBusId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , class <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;<a class="el" href="#a01a7c6aa1ffb03d37a892a33a940039f">::BusIdType</a> * <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::GetCurrentBusId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the ID of the address that is currently receiving an event. You can use this function while handling an event to determine which ID the event concerns. This is especially useful for handlers that connect to multiple address IDs. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the address ID that is currently receiving an event. Returns a null pointer if the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> is not currently sending an event or the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> does not use an <a class="el" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873">AZ::EBusAddressPolicy</a> that has multiple addresses. </dd></dl>

</div>
</div>
<a id="a6b2b5ba3bd36cdb87cbb690ccf4fcee4" name="a6b2b5ba3bd36cdb87cbb690ccf4fcee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2b5ba3bd36cdb87cbb690ccf4fcee4">&#9670;&#160;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , class <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::GetName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a unique signature for the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a>. </p><dl class="section return"><dt>Returns</dt><dd>A unique signature for the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a>. </dd></dl>

</div>
</div>
<a id="a07aa45a280e52a2bf3e80da52c2642ee" name="a07aa45a280e52a2bf3e80da52c2642ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07aa45a280e52a2bf3e80da52c2642ee">&#9670;&#160;</a></span>GetOrCreateContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , class <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_1_1_e_bus.html">EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::Context &amp; <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::GetOrCreateContext </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trackCallstack</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the global bus data. Creates it if it wasn't already created. Depending on the storage policy, there might be one or multiple instances of the bus data. </p><dl class="section return"><dt>Returns</dt><dd>A reference to the bus context. </dd></dl>

</div>
</div>
<a id="ad8bd1c39f535bd845cc864d55edd0688" name="ad8bd1c39f535bd845cc864d55edd0688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8bd1c39f535bd845cc864d55edd0688">&#9670;&#160;</a></span>GetTotalNumOfEventHandlers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , class <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AZ_POP_DISABLE_WARNING size_t <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::GetTotalNumOfEventHandlers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the total number of handlers that are connected to the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a>. </p><dl class="section return"><dt>Returns</dt><dd>The total number of handlers that are connected to the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a>. </dd></dl>

</div>
</div>
<a id="a9eaba0941e16d413d0e3db51386ffe23" name="a9eaba0941e16d413d0e3db51386ffe23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eaba0941e16d413d0e3db51386ffe23">&#9670;&#160;</a></span>HasHandlers() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , class <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::HasHandlers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether any handlers are connected to the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a>. </p><dl class="section return"><dt>Returns</dt><dd>True if there are any handlers connected to the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a>. Otherwise, false. </dd></dl>

</div>
</div>
<a id="ac7dced274d351314898c455c850a0294" name="ac7dced274d351314898c455c850a0294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7dced274d351314898c455c850a0294">&#9670;&#160;</a></span>HasHandlers() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , class <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::HasHandlers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a01a7c6aa1ffb03d37a892a33a940039f">BusIdType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether handlers are connected to this specific address. </p><dl class="section return"><dt>Returns</dt><dd>True if there are any handlers connected at the address. Otherwise, false. </dd></dl>

</div>
</div>
<a id="ae660e0fb2adc517c243c512caf4e5bf9" name="ae660e0fb2adc517c243c512caf4e5bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae660e0fb2adc517c243c512caf4e5bf9">&#9670;&#160;</a></span>HasHandlers() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , class <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::HasHandlers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#acff36a6a1d1eef9d10218a0dc1d23162">BusPtr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether handlers are connected to the specific cached address. </p><dl class="section return"><dt>Returns</dt><dd>True if there are any handlers connected at the cached address. Otherwise, false. </dd></dl>

</div>
</div>
<a id="ab666800ef63443fc37e2179b32f7a59e" name="ab666800ef63443fc37e2179b32f7a59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab666800ef63443fc37e2179b32f7a59e">&#9670;&#160;</a></span>HasReentrantEBusUseThisThread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , class <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::HasReentrantEBusUseThisThread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a01a7c6aa1ffb03d37a892a33a940039f">BusIdType</a> *</td>          <td class="paramname"><span class="paramname"><em>busId</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a1a470da8f1eddf6e2ad5aa30f7dcdabf">GetCurrentBusId</a>()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks to see if an <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> with a given Bus ID appears twice in the callstack. This can be used to detect infinite recursive loops and other reentrancy problems. This method only checks <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> and ID, not the specific <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> event, so two different nested event calls on the same <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> and ID will still return true. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">busId</td><td>The bus ID to check for reentrancy on this thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> has been called more than once on this thread's callstack, false if not. </dd></dl>

</div>
</div>
<a id="a3f8002f85a570382d5431bf83a058a05" name="a3f8002f85a570382d5431bf83a058a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8002f85a570382d5431bf83a058a05">&#9670;&#160;</a></span>IsInDispatchThisThread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , class <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::IsInDispatchThisThread </td>
          <td>(</td>
          <td class="paramtype">Context *</td>          <td class="paramname"><span class="paramname"><em>context</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a9522c24e0e1d49fbbc37a9e8ea475d5c">GetContext</a>(false)</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> context is in the middle of a dispatch on the current thread </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2d9116141ff60df3ea46fdc93a969c88" name="a2d9116141ff60df3ea46fdc93a969c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9116141ff60df3ea46fdc93a969c88">&#9670;&#160;</a></span>EnableEventQueue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::EnableEventQueue = ImplTraits::EnableEventQueue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specifies whether the EBus supports an event queue. You can use the event queue to execute events at a later time. To execute the queued events, you must call <code>&lt;BusName&gt;::ExecuteQueuedEvents()</code>. By default, the event queue is disabled. </p>

</div>
</div>
<a id="a88d94740bf37e7d5894d562b6f0de6dc" name="a88d94740bf37e7d5894d562b6f0de6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d94740bf37e7d5894d562b6f0de6dc">&#9670;&#160;</a></span>HasId</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="class_a_z_1_1_interface.html">Interface</a> , typename <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="class_a_z_1_1_e_bus.html">AZ::EBus</a>&lt; <a class="el" href="class_a_z_1_1_interface.html">Interface</a>, <a class="el" href="#a9f61a05d19896191551e96a74909552c">Traits</a> &gt;::HasId = Traits::AddressPolicy != <a class="el" href="namespace_a_z.html#abd62fbe2e48ab376e0cce1a0ff0ea873a66ba162102bbf6ae31b522aec561735e">EBusAddressPolicy::Single</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>True if the EBus supports more than one address. Otherwise, false. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Code/Framework/AzCore/AzCore/EBus/<a class="el" href="_e_bus_8h.html">EBus.h</a></li>
<li>Code/Framework/AzCore/AzCore/EBus/Internal/<b>CallstackEntry.h</b></li>
<li>Code/Framework/AzCore/AzCore/EBus/Internal/<b>Handlers.h</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><a class="el" href="class_a_z_1_1_e_bus.html">EBus</a></li>
    <li class="footer">Generated on Mon Oct 7 2024 16:44:02 for Open 3D Engine AzCore API Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
