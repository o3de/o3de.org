<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine AzCore API Reference: AZStd::rbtree&lt; Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="/images/api-reference/api-ref-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine AzCore API Reference
   &#160;<span id="projectnumber">22.10.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_a_z_std.html">AZStd</a></li><li class="navelem"><a class="el" href="class_a_z_std_1_1rbtree.html">rbtree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_a_z_std_1_1rbtree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AZStd::rbtree&lt; Traits &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;rbtree.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a43a394625797a79d50db1b3d3b77cae8"><td class="memItemLeft" align="right" valign="top"><a id="a43a394625797a79d50db1b3d3b77cae8"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><b>traits_type</b></td></tr>
<tr class="separator:a43a394625797a79d50db1b3d3b77cae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71109d094df693500fac8cfbaf2451b9"><td class="memItemLeft" align="right" valign="top"><a id="a71109d094df693500fac8cfbaf2451b9"></a>
typedef Traits::key_type&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr class="separator:a71109d094df693500fac8cfbaf2451b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916253e87a42f01686b55b74346c4652"><td class="memItemLeft" align="right" valign="top"><a id="a916253e87a42f01686b55b74346c4652"></a>
typedef Traits::key_equal&#160;</td><td class="memItemRight" valign="bottom"><b>key_equal</b></td></tr>
<tr class="separator:a916253e87a42f01686b55b74346c4652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d4494a15250e1c22b4e757f5760110"><td class="memItemLeft" align="right" valign="top"><a id="a77d4494a15250e1c22b4e757f5760110"></a>
typedef Traits::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:a77d4494a15250e1c22b4e757f5760110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d9bb514c883b293f160b074d2c7ed9"><td class="memItemLeft" align="right" valign="top"><a id="a66d9bb514c883b293f160b074d2c7ed9"></a>
typedef allocator_type::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a66d9bb514c883b293f160b074d2c7ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01947cdc73e7a0c06740bdb5620b2a5"><td class="memItemLeft" align="right" valign="top"><a id="ab01947cdc73e7a0c06740bdb5620b2a5"></a>
typedef allocator_type::difference_type&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:ab01947cdc73e7a0c06740bdb5620b2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae672c9b7c6f4f77350abc4af1b6661c8"><td class="memItemLeft" align="right" valign="top"><a id="ae672c9b7c6f4f77350abc4af1b6661c8"></a>
typedef Traits::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:ae672c9b7c6f4f77350abc4af1b6661c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889921dfdb830ff5843ac539e1b0ddc6"><td class="memItemLeft" align="right" valign="top"><a id="a889921dfdb830ff5843ac539e1b0ddc6"></a>
typedef value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a889921dfdb830ff5843ac539e1b0ddc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b0bb109089819e86ffe222f604d2b3"><td class="memItemLeft" align="right" valign="top"><a id="a82b0bb109089819e86ffe222f604d2b3"></a>
typedef value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a82b0bb109089819e86ffe222f604d2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61d93ca053ba0b6be9fc36c8816671d"><td class="memItemLeft" align="right" valign="top"><a id="ab61d93ca053ba0b6be9fc36c8816671d"></a>
typedef <a class="el" href="namespace_a_z_std.html#a51da0cadfe49abd2822249512fa31fcb">AZStd::bidirectional_iterator_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_category</b></td></tr>
<tr class="separator:ab61d93ca053ba0b6be9fc36c8816671d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fd4f3a88f58debdbc7f29649466e8a"><td class="memItemLeft" align="right" valign="top"><a id="aa0fd4f3a88f58debdbc7f29649466e8a"></a>
typedef Internal::rbtree_node&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>node_type</b></td></tr>
<tr class="separator:aa0fd4f3a88f58debdbc7f29649466e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d77955af8f5f024713d30a3fbc20d5"><td class="memItemLeft" align="right" valign="top"><a id="a66d77955af8f5f024713d30a3fbc20d5"></a>
typedef node_type *&#160;</td><td class="memItemRight" valign="bottom"><b>node_ptr_type</b></td></tr>
<tr class="separator:a66d77955af8f5f024713d30a3fbc20d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6529bf6f03f8e6ef6a938ab9f8f14e"><td class="memItemLeft" align="right" valign="top"><a id="a2a6529bf6f03f8e6ef6a938ab9f8f14e"></a>
typedef <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">rbtree_const_iterator</a>&lt; typename Traits::value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator_impl</b></td></tr>
<tr class="separator:a2a6529bf6f03f8e6ef6a938ab9f8f14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5266865d5d3f502f4b670fe30bdea68e"><td class="memItemLeft" align="right" valign="top"><a id="a5266865d5d3f502f4b670fe30bdea68e"></a>
typedef <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">rbtree_iterator</a>&lt; typename Traits::value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_impl</b></td></tr>
<tr class="separator:a5266865d5d3f502f4b670fe30bdea68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9138fa5c2d1aa3aecc42422b57137e"><td class="memItemLeft" align="right" valign="top"><a id="a1e9138fa5c2d1aa3aecc42422b57137e"></a>
typedef <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator_impl</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a1e9138fa5c2d1aa3aecc42422b57137e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc96f9ccb90dd95705e9e58cbfc42856"><td class="memItemLeft" align="right" valign="top"><a id="adc96f9ccb90dd95705e9e58cbfc42856"></a>
typedef <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator_impl</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:adc96f9ccb90dd95705e9e58cbfc42856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de05a76c3dd6eb56c1999b63efa270b"><td class="memItemLeft" align="right" valign="top"><a id="a4de05a76c3dd6eb56c1999b63efa270b"></a>
typedef AZStd::reverse_iterator&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a4de05a76c3dd6eb56c1999b63efa270b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588620fc55b40dd0f18aeda724a3054d"><td class="memItemLeft" align="right" valign="top"><a id="a588620fc55b40dd0f18aeda724a3054d"></a>
typedef AZStd::reverse_iterator&lt; <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:a588620fc55b40dd0f18aeda724a3054d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8375a43478820ae31bb896fce4204f"><td class="memItemLeft" align="right" valign="top"><a id="aff8375a43478820ae31bb896fce4204f"></a>
typedef <a class="el" href="class_a_z_std_1_1rbtree__node__destructor.html">rbtree_node_destructor</a>&lt; allocator_type, node_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>node_deleter</b></td></tr>
<tr class="separator:aff8375a43478820ae31bb896fce4204f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6123406df99016d300e1144752ec05af"><td class="memItemLeft" align="right" valign="top"><a id="a6123406df99016d300e1144752ec05af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rbtree</b> (const key_equal &amp;keyEq)</td></tr>
<tr class="separator:a6123406df99016d300e1144752ec05af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73131bfa75f13baa311eec5654fcc91"><td class="memItemLeft" align="right" valign="top"><a id="ab73131bfa75f13baa311eec5654fcc91"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rbtree</b> (const allocator_type &amp;<a class="el" href="class_a_z_std_1_1allocator.html">allocator</a>)</td></tr>
<tr class="separator:ab73131bfa75f13baa311eec5654fcc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154a36a52c9a3b8a30edda3f3ae40434"><td class="memItemLeft" align="right" valign="top"><a id="a154a36a52c9a3b8a30edda3f3ae40434"></a>
AZ_FORCE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><b>rbtree</b> (const key_equal &amp;keyEq, const allocator_type &amp;<a class="el" href="class_a_z_std_1_1allocator.html">allocator</a>)</td></tr>
<tr class="separator:a154a36a52c9a3b8a30edda3f3ae40434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793f7c4c16139f38c8577d430fc661d2"><td class="memItemLeft" align="right" valign="top"><a id="a793f7c4c16139f38c8577d430fc661d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rbtree</b> (const <a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;rhs)</td></tr>
<tr class="separator:a793f7c4c16139f38c8577d430fc661d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c4bea61140df1d6a3c4c197ef900c7"><td class="memItemLeft" align="right" valign="top"><a id="ac7c4bea61140df1d6a3c4c197ef900c7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rbtree</b> (const <a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;rhs, const allocator_type &amp;<a class="el" href="class_a_z_std_1_1allocator.html">allocator</a>)</td></tr>
<tr class="separator:ac7c4bea61140df1d6a3c4c197ef900c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0608d14ad524657a69e3a0c49a6413e"><td class="memItemLeft" align="right" valign="top"><a id="ab0608d14ad524657a69e3a0c49a6413e"></a>
<a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;rhs)</td></tr>
<tr class="separator:ab0608d14ad524657a69e3a0c49a6413e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6a0853cb91b81d16353103ee0bd24f"><td class="memItemLeft" align="right" valign="top"><a id="aac6a0853cb91b81d16353103ee0bd24f"></a>
AZ_FORCE_INLINE key_equal&#160;</td><td class="memItemRight" valign="bottom"><b>key_comp</b> () const</td></tr>
<tr class="separator:aac6a0853cb91b81d16353103ee0bd24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad372e2261f4919aed05df94870fad0"><td class="memItemLeft" align="right" valign="top"><a id="aaad372e2261f4919aed05df94870fad0"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:aaad372e2261f4919aed05df94870fad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482f44ff87f636d8e0585698e68c46d4"><td class="memItemLeft" align="right" valign="top"><a id="a482f44ff87f636d8e0585698e68c46d4"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="separator:a482f44ff87f636d8e0585698e68c46d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9b63300efdea28e166f0cd5b2f9e45"><td class="memItemLeft" align="right" valign="top"><a id="a4a9b63300efdea28e166f0cd5b2f9e45"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:a4a9b63300efdea28e166f0cd5b2f9e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1d7f826498f565bf173aae4bb78938"><td class="memItemLeft" align="right" valign="top"><a id="a2c1d7f826498f565bf173aae4bb78938"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="separator:a2c1d7f826498f565bf173aae4bb78938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2816469503fd396e65594f215079cd29"><td class="memItemLeft" align="right" valign="top"><a id="a2816469503fd396e65594f215079cd29"></a>
AZ_FORCE_INLINE reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> ()</td></tr>
<tr class="separator:a2816469503fd396e65594f215079cd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d9f0cd88f8386410f3788640833c01"><td class="memItemLeft" align="right" valign="top"><a id="a60d9f0cd88f8386410f3788640833c01"></a>
AZ_FORCE_INLINE const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const</td></tr>
<tr class="separator:a60d9f0cd88f8386410f3788640833c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cee3bf31ffbe9e7364ac5613461bfb"><td class="memItemLeft" align="right" valign="top"><a id="ae2cee3bf31ffbe9e7364ac5613461bfb"></a>
AZ_FORCE_INLINE reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> ()</td></tr>
<tr class="separator:ae2cee3bf31ffbe9e7364ac5613461bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26cba0582cec3dc7b02f420b7968398"><td class="memItemLeft" align="right" valign="top"><a id="ab26cba0582cec3dc7b02f420b7968398"></a>
AZ_FORCE_INLINE const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const</td></tr>
<tr class="separator:ab26cba0582cec3dc7b02f420b7968398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808e99e72d298dd99a9008bcbdeb04ef"><td class="memItemLeft" align="right" valign="top"><a id="a808e99e72d298dd99a9008bcbdeb04ef"></a>
AZ_FORCE_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="separator:a808e99e72d298dd99a9008bcbdeb04ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650b57c998e5ce66bb7f67cf873cdf17"><td class="memItemLeft" align="right" valign="top"><a id="a650b57c998e5ce66bb7f67cf873cdf17"></a>
AZ_FORCE_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a650b57c998e5ce66bb7f67cf873cdf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff2c8dec8cbfbe5d064d23eee3301b2"><td class="memItemLeft" align="right" valign="top"><a id="adff2c8dec8cbfbe5d064d23eee3301b2"></a>
AZ_FORCE_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>max_size</b> () const</td></tr>
<tr class="separator:adff2c8dec8cbfbe5d064d23eee3301b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a50a0f97b5e2f21ad8110ba0ea09935"><td class="memItemLeft" align="right" valign="top"><a id="a8a50a0f97b5e2f21ad8110ba0ea09935"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rbtree</b> (<a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a8a50a0f97b5e2f21ad8110ba0ea09935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23498503b1f831c801c39aeeb630e902"><td class="memItemLeft" align="right" valign="top"><a id="a23498503b1f831c801c39aeeb630e902"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rbtree</b> (<a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;&amp;rhs, const allocator_type &amp;<a class="el" href="class_a_z_std_1_1allocator.html">allocator</a>)</td></tr>
<tr class="separator:a23498503b1f831c801c39aeeb630e902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962b6a8bce1538ff5b8e70bd4b4b144f"><td class="memItemLeft" align="right" valign="top"><a id="a962b6a8bce1538ff5b8e70bd4b4b144f"></a>
<a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a962b6a8bce1538ff5b8e70bd4b4b144f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af028fedfa1e24d361be00b52706c76bf"><td class="memItemLeft" align="right" valign="top"><a id="af028fedfa1e24d361be00b52706c76bf"></a>
<a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>insert_unique</b> (value_type &amp;&amp;value)</td></tr>
<tr class="separator:af028fedfa1e24d361be00b52706c76bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f8d46d2e11ab3d7d0cacb9be2f791a"><td class="memItemLeft" align="right" valign="top"><a id="a41f8d46d2e11ab3d7d0cacb9be2f791a"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_unique</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> insertPos, value_type &amp;&amp;value)</td></tr>
<tr class="separator:a41f8d46d2e11ab3d7d0cacb9be2f791a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c1a7faee71372f6b445934d95b0f87"><td class="memItemLeft" align="right" valign="top"><a id="a78c1a7faee71372f6b445934d95b0f87"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_equal</b> (value_type &amp;&amp;value)</td></tr>
<tr class="separator:a78c1a7faee71372f6b445934d95b0f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98756ae7798063d57cb61a866dfa416a"><td class="memTemplParams" colspan="2"><a id="a98756ae7798063d57cb61a866dfa416a"></a>
template&lt;class ... InputArguments&gt; </td></tr>
<tr class="memitem:a98756ae7798063d57cb61a866dfa416a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_unique</b> (InputArguments &amp;&amp;... arguments)</td></tr>
<tr class="separator:a98756ae7798063d57cb61a866dfa416a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba1abe7ceae6bef6ed86b41206768a4"><td class="memTemplParams" colspan="2"><a id="a3ba1abe7ceae6bef6ed86b41206768a4"></a>
template&lt;class ... InputArguments&gt; </td></tr>
<tr class="memitem:a3ba1abe7ceae6bef6ed86b41206768a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_unique</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> insertPos, InputArguments &amp;&amp;... arguments)</td></tr>
<tr class="separator:a3ba1abe7ceae6bef6ed86b41206768a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe4a9bccd7cb609da3adebcf9f3fca9"><td class="memTemplParams" colspan="2"><a id="aafe4a9bccd7cb609da3adebcf9f3fca9"></a>
template&lt;class ... InputArguments&gt; </td></tr>
<tr class="memitem:aafe4a9bccd7cb609da3adebcf9f3fca9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_equal</b> (InputArguments &amp;&amp;... arguments)</td></tr>
<tr class="separator:aafe4a9bccd7cb609da3adebcf9f3fca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b9005c56aa829d940ac8d0776dd90c"><td class="memTemplParams" colspan="2"><a id="a66b9005c56aa829d940ac8d0776dd90c"></a>
template&lt;class ... InputArguments&gt; </td></tr>
<tr class="memitem:a66b9005c56aa829d940ac8d0776dd90c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_equal</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> insertPos, InputArguments &amp;&amp;... arguments)</td></tr>
<tr class="separator:a66b9005c56aa829d940ac8d0776dd90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82752b44d86b12b74918a16494eb3fa9"><td class="memItemLeft" align="right" valign="top"><a id="a82752b44d86b12b74918a16494eb3fa9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;rhs)</td></tr>
<tr class="separator:a82752b44d86b12b74918a16494eb3fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb5987e1bffccf24fff3a83eebda7bc"><td class="memItemLeft" align="right" valign="top"><a id="a1fb5987e1bffccf24fff3a83eebda7bc"></a>
<a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>insert_unique</b> (const value_type &amp;value)</td></tr>
<tr class="separator:a1fb5987e1bffccf24fff3a83eebda7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacfc1bda881f14bb61f9ed5bab5892d"><td class="memItemLeft" align="right" valign="top"><a id="acacfc1bda881f14bb61f9ed5bab5892d"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_equal</b> (const value_type &amp;value)</td></tr>
<tr class="separator:acacfc1bda881f14bb61f9ed5bab5892d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613c935a80a037b8021ba15eb98b2f63"><td class="memItemLeft" align="right" valign="top"><a id="a613c935a80a037b8021ba15eb98b2f63"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_unique</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> insertPos, const value_type &amp;value)</td></tr>
<tr class="separator:a613c935a80a037b8021ba15eb98b2f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2daec9a8f9f7350da1d1065aa688867f"><td class="memItemLeft" align="right" valign="top"><a id="a2daec9a8f9f7350da1d1065aa688867f"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_equal</b> (const <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> insertPos, const value_type &amp;value)</td></tr>
<tr class="separator:a2daec9a8f9f7350da1d1065aa688867f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46eada7dec00a61811a84250d3aa3afd"><td class="memTemplParams" colspan="2"><a id="a46eada7dec00a61811a84250d3aa3afd"></a>
template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:a46eada7dec00a61811a84250d3aa3afd"><td class="memTemplItemLeft" align="right" valign="top">AZ_FORCE_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_equal</b> (Iterator first, Iterator last)</td></tr>
<tr class="separator:a46eada7dec00a61811a84250d3aa3afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b89588973ccb7a17b20448228a9474"><td class="memTemplParams" colspan="2"><a id="a86b89588973ccb7a17b20448228a9474"></a>
template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:a86b89588973ccb7a17b20448228a9474"><td class="memTemplItemLeft" align="right" valign="top">AZ_FORCE_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_unique</b> (Iterator first, Iterator last)</td></tr>
<tr class="separator:a86b89588973ccb7a17b20448228a9474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c4d0171c7c368b7437f2ef345238fa"><td class="memTemplParams" colspan="2"><a id="a50c4d0171c7c368b7437f2ef345238fa"></a>
template&lt;typename ComparableToKey , typename... Args&gt; </td></tr>
<tr class="memitem:a50c4d0171c7c368b7437f2ef345238fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace_unique</b> (ComparableToKey &amp;&amp;key, Args &amp;&amp;... arguments)</td></tr>
<tr class="separator:a50c4d0171c7c368b7437f2ef345238fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac343e34e6cb59094e2be6d7842746b22"><td class="memTemplParams" colspan="2"><a id="ac343e34e6cb59094e2be6d7842746b22"></a>
template&lt;typename ComparableToKey , typename... Args&gt; </td></tr>
<tr class="memitem:ac343e34e6cb59094e2be6d7842746b22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace_unique</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> hint, ComparableToKey &amp;&amp;key, Args &amp;&amp;... arguments)</td></tr>
<tr class="separator:ac343e34e6cb59094e2be6d7842746b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19f1cad3a9ce5a4cf3b24211ea74824"><td class="memTemplParams" colspan="2"><a id="af19f1cad3a9ce5a4cf3b24211ea74824"></a>
template&lt;typename ComparableToKey , typename MappedType &gt; </td></tr>
<tr class="memitem:af19f1cad3a9ce5a4cf3b24211ea74824"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign_unique</b> (ComparableToKey &amp;&amp;key, MappedType &amp;&amp;value)</td></tr>
<tr class="separator:af19f1cad3a9ce5a4cf3b24211ea74824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c3495f88ccae61a663393fd691da94"><td class="memTemplParams" colspan="2"><a id="a09c3495f88ccae61a663393fd691da94"></a>
template&lt;typename ComparableToKey , typename MappedType &gt; </td></tr>
<tr class="memitem:a09c3495f88ccae61a663393fd691da94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign_unique</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> hint, ComparableToKey &amp;&amp;key, MappedType &amp;&amp;value)</td></tr>
<tr class="separator:a09c3495f88ccae61a663393fd691da94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad679828b56edf29b1afcfabb6b6812a9"><td class="memTemplParams" colspan="2">template&lt;class InsertReturnType , class NodeHandle &gt; </td></tr>
<tr class="memitem:ad679828b56edf29b1afcfabb6b6812a9"><td class="memTemplItemLeft" align="right" valign="top">InsertReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1rbtree.html#ad679828b56edf29b1afcfabb6b6812a9">node_handle_insert_unique</a> (NodeHandle &amp;&amp;nodeHandle)</td></tr>
<tr class="separator:ad679828b56edf29b1afcfabb6b6812a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9ea86f0c99b3c5ee35b0deed62036e"><td class="memTemplParams" colspan="2"><a id="a0e9ea86f0c99b3c5ee35b0deed62036e"></a>
template&lt;class NodeHandle &gt; </td></tr>
<tr class="memitem:a0e9ea86f0c99b3c5ee35b0deed62036e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>node_handle_insert_unique</b> (const <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> hint, NodeHandle &amp;&amp;nodeHandle) -&gt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a></td></tr>
<tr class="separator:a0e9ea86f0c99b3c5ee35b0deed62036e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03292f2d5c86394b43db5755ec40431f"><td class="memTemplParams" colspan="2">template&lt;class NodeHandle &gt; </td></tr>
<tr class="memitem:a03292f2d5c86394b43db5755ec40431f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1rbtree.html#a03292f2d5c86394b43db5755ec40431f">node_handle_insert_equal</a> (NodeHandle &amp;&amp;nodeHandle) -&gt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a></td></tr>
<tr class="separator:a03292f2d5c86394b43db5755ec40431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b1ccd25b6548d7b2478b535262b885"><td class="memTemplParams" colspan="2"><a id="ae7b1ccd25b6548d7b2478b535262b885"></a>
template&lt;class NodeHandle &gt; </td></tr>
<tr class="memitem:ae7b1ccd25b6548d7b2478b535262b885"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>node_handle_insert_equal</b> (const <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> hint, NodeHandle &amp;&amp;nodeHandle) -&gt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a></td></tr>
<tr class="separator:ae7b1ccd25b6548d7b2478b535262b885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d84597279f45fd4fb59fb2e6adafc5"><td class="memTemplParams" colspan="2">template&lt;class NodeHandle &gt; </td></tr>
<tr class="memitem:a60d84597279f45fd4fb59fb2e6adafc5"><td class="memTemplItemLeft" align="right" valign="top">NodeHandle&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1rbtree.html#a60d84597279f45fd4fb59fb2e6adafc5">node_handle_extract</a> (const key_type &amp;key)</td></tr>
<tr class="separator:a60d84597279f45fd4fb59fb2e6adafc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71730ba5e3cac7386ad9c223ebf5209"><td class="memTemplParams" colspan="2">template&lt;class NodeHandle &gt; </td></tr>
<tr class="memitem:ac71730ba5e3cac7386ad9c223ebf5209"><td class="memTemplItemLeft" align="right" valign="top">NodeHandle&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1rbtree.html#ac71730ba5e3cac7386ad9c223ebf5209">node_handle_extract</a> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> it)</td></tr>
<tr class="separator:ac71730ba5e3cac7386ad9c223ebf5209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7134a80d7105d4b57da5f5b78eb96d1f"><td class="memItemLeft" align="right" valign="top"><a id="a7134a80d7105d4b57da5f5b78eb96d1f"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> erasePos)</td></tr>
<tr class="separator:a7134a80d7105d4b57da5f5b78eb96d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376e2d065043ef2baee4f98c41bc817a"><td class="memItemLeft" align="right" valign="top"><a id="a376e2d065043ef2baee4f98c41bc817a"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (const key_type &amp;key)</td></tr>
<tr class="separator:a376e2d065043ef2baee4f98c41bc817a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0857629b3fece39f2c08f625430a82"><td class="memItemLeft" align="right" valign="top"><a id="a2a0857629b3fece39f2c08f625430a82"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>erase_unique</b> (const key_type &amp;key)</td></tr>
<tr class="separator:a2a0857629b3fece39f2c08f625430a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb4a4f451fa9ba99b6745b6bd5458d1"><td class="memItemLeft" align="right" valign="top"><a id="aeeb4a4f451fa9ba99b6745b6bd5458d1"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> first, <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> last)</td></tr>
<tr class="separator:aeeb4a4f451fa9ba99b6745b6bd5458d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77332e998fb1e559110c8a9082fdbd5f"><td class="memItemLeft" align="right" valign="top"><a id="a77332e998fb1e559110c8a9082fdbd5f"></a>
AZ_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (const key_type *first, const key_type *last)</td></tr>
<tr class="separator:a77332e998fb1e559110c8a9082fdbd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee6a0458afe9cc92be134403a69dd83"><td class="memItemLeft" align="right" valign="top"><a id="a6ee6a0458afe9cc92be134403a69dd83"></a>
AZ_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a6ee6a0458afe9cc92be134403a69dd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854bec73079c515c9c3ba963b7387d21"><td class="memTemplParams" colspan="2"><a id="a854bec73079c515c9c3ba963b7387d21"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a854bec73079c515c9c3ba963b7387d21"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a854bec73079c515c9c3ba963b7387d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2bc0cac874bb165fafa8fa96e4ae7d"><td class="memTemplParams" colspan="2"><a id="acf2bc0cac874bb165fafa8fa96e4ae7d"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:acf2bc0cac874bb165fafa8fa96e4ae7d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:acf2bc0cac874bb165fafa8fa96e4ae7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f45b88a3bf93ff209a8698bae77a14d"><td class="memTemplParams" colspan="2"><a id="a9f45b88a3bf93ff209a8698bae77a14d"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a9f45b88a3bf93ff209a8698bae77a14d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, bool &gt;</td></tr>
<tr class="separator:a9f45b88a3bf93ff209a8698bae77a14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafc0fd5ddd22ba9ad55529a068c40ac"><td class="memTemplParams" colspan="2"><a id="aaafc0fd5ddd22ba9ad55529a068c40ac"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:aaafc0fd5ddd22ba9ad55529a068c40ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:aaafc0fd5ddd22ba9ad55529a068c40ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6861fcfe337f7a337dd6291fcf67e00"><td class="memTemplParams" colspan="2"><a id="ac6861fcfe337f7a337dd6291fcf67e00"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:ac6861fcfe337f7a337dd6291fcf67e00"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:ac6861fcfe337f7a337dd6291fcf67e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f32ce0f0b7c28ff1888e485bbb5360"><td class="memTemplParams" colspan="2"><a id="a62f32ce0f0b7c28ff1888e485bbb5360"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a62f32ce0f0b7c28ff1888e485bbb5360"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upper_bound</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a62f32ce0f0b7c28ff1888e485bbb5360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d007e6150e70375db25a66c1b38c8f1"><td class="memTemplParams" colspan="2"><a id="a0d007e6150e70375db25a66c1b38c8f1"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a0d007e6150e70375db25a66c1b38c8f1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upper_bound</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:a0d007e6150e70375db25a66c1b38c8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be6e24300f8d13cba08ea7f8bce5418"><td class="memTemplParams" colspan="2"><a id="a1be6e24300f8d13cba08ea7f8bce5418"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a1be6e24300f8d13cba08ea7f8bce5418"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, size_type &gt;</td></tr>
<tr class="separator:a1be6e24300f8d13cba08ea7f8bce5418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c510f9b1bb041c20642f4e31f7a07f7"><td class="memTemplParams" colspan="2"><a id="a9c510f9b1bb041c20642f4e31f7a07f7"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a9c510f9b1bb041c20642f4e31f7a07f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> &gt;&gt;</td></tr>
<tr class="separator:a9c510f9b1bb041c20642f4e31f7a07f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3384bd9c98d5e1d6ebb0816e49ca6c8e"><td class="memTemplParams" colspan="2"><a id="a3384bd9c98d5e1d6ebb0816e49ca6c8e"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a3384bd9c98d5e1d6ebb0816e49ca6c8e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a>, <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> &gt;&gt;</td></tr>
<tr class="separator:a3384bd9c98d5e1d6ebb0816e49ca6c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a51fe519f23894fa7c49c4cfcccd44"><td class="memTemplParams" colspan="2"><a id="a59a51fe519f23894fa7c49c4cfcccd44"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a59a51fe519f23894fa7c49c4cfcccd44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range_unique</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> &gt;&gt;</td></tr>
<tr class="separator:a59a51fe519f23894fa7c49c4cfcccd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588e30f56fb690ecdba13ab920dda161"><td class="memTemplParams" colspan="2"><a id="a588e30f56fb690ecdba13ab920dda161"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a588e30f56fb690ecdba13ab920dda161"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range_unique</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a>, <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> &gt;&gt;</td></tr>
<tr class="separator:a588e30f56fb690ecdba13ab920dda161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c3220ef6070b94d9a3da25d34a63dd"><td class="memTemplParams" colspan="2"><a id="a23c3220ef6070b94d9a3da25d34a63dd"></a>
template&lt;typename ComparableToKey , typename... Args&gt; </td></tr>
<tr class="memitem:a23c3220ef6070b94d9a3da25d34a63dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace_unique</b> (ComparableToKey &amp;&amp;key, Args &amp;&amp;... arguments) -&gt; <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, bool &gt;</td></tr>
<tr class="separator:a23c3220ef6070b94d9a3da25d34a63dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6966f78e4e15689a7bf5894aaab655a4"><td class="memTemplParams" colspan="2"><a id="a6966f78e4e15689a7bf5894aaab655a4"></a>
template&lt;typename ComparableToKey , typename... Args&gt; </td></tr>
<tr class="memitem:a6966f78e4e15689a7bf5894aaab655a4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace_unique</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> hint, ComparableToKey &amp;&amp;key, Args &amp;&amp;... arguments) -&gt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a></td></tr>
<tr class="separator:a6966f78e4e15689a7bf5894aaab655a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e629e0a9a5c20fda1af9f5198cf603"><td class="memTemplParams" colspan="2"><a id="a55e629e0a9a5c20fda1af9f5198cf603"></a>
template&lt;typename ComparableToKey , typename MappedType &gt; </td></tr>
<tr class="memitem:a55e629e0a9a5c20fda1af9f5198cf603"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign_unique</b> (ComparableToKey &amp;&amp;key, MappedType &amp;&amp;value) -&gt; <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, bool &gt;</td></tr>
<tr class="separator:a55e629e0a9a5c20fda1af9f5198cf603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fa1b153ad4d9a552918c7dad5c789e"><td class="memTemplParams" colspan="2"><a id="a49fa1b153ad4d9a552918c7dad5c789e"></a>
template&lt;typename ComparableToKey , typename MappedType &gt; </td></tr>
<tr class="memitem:a49fa1b153ad4d9a552918c7dad5c789e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign_unique</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> hint, ComparableToKey &amp;&amp;key, MappedType &amp;&amp;value) -&gt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a></td></tr>
<tr class="separator:a49fa1b153ad4d9a552918c7dad5c789e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extensions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="ListExtensions"></a></p>
</div></td></tr>
<tr class="memitem:af9ca84df11524d421fa25466b0cf3330"><td class="memItemLeft" align="right" valign="top"><a id="af9ca84df11524d421fa25466b0cf3330"></a>
allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> ()</td></tr>
<tr class="separator:af9ca84df11524d421fa25466b0cf3330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0c8b1f59f1ebdcea3f92bca44d4a4d"><td class="memItemLeft" align="right" valign="top"><a id="aec0c8b1f59f1ebdcea3f92bca44d4a4d"></a>
const allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const</td></tr>
<tr class="separator:aec0c8b1f59f1ebdcea3f92bca44d4a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9eaa430cab081363a3f76ebc536955"><td class="memItemLeft" align="right" valign="top"><a id="abc9eaa430cab081363a3f76ebc536955"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1rbtree.html#abc9eaa430cab081363a3f76ebc536955">set_allocator</a> (const allocator_type &amp;<a class="el" href="class_a_z_std_1_1allocator.html">allocator</a>)</td></tr>
<tr class="memdesc:abc9eaa430cab081363a3f76ebc536955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the vector allocator. If different than then current all elements will be reallocated. <br /></td></tr>
<tr class="separator:abc9eaa430cab081363a3f76ebc536955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731a55ddb6c88aebd90c96a4c8a83588"><td class="memItemLeft" align="right" valign="top"><a id="a731a55ddb6c88aebd90c96a4c8a83588"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>validate</b> () const</td></tr>
<tr class="separator:a731a55ddb6c88aebd90c96a4c8a83588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0dc283386b57bca2a78e895070ef68"><td class="memItemLeft" align="right" valign="top"><a id="a8d0dc283386b57bca2a78e895070ef68"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1rbtree.html#a8d0dc283386b57bca2a78e895070ef68">validate_iterator</a> (const <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> &amp;iter) const</td></tr>
<tr class="memdesc:a8d0dc283386b57bca2a78e895070ef68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates an iter iterator. Returns a combination of <a class="el" href="namespace_a_z_std.html#a77fc989e737c35ee90f2b8ef6f5e9b9c">iterator_status_flag</a>. <br /></td></tr>
<tr class="separator:a8d0dc283386b57bca2a78e895070ef68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001012eb2e4968c8d80dfc2a7dd1683f"><td class="memItemLeft" align="right" valign="top"><a id="a001012eb2e4968c8d80dfc2a7dd1683f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>validate_iterator</b> (const <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> &amp;iter) const</td></tr>
<tr class="separator:a001012eb2e4968c8d80dfc2a7dd1683f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a82f156a68dfe1b7553310c7b2e862"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1rbtree.html#aa2a82f156a68dfe1b7553310c7b2e862">leak_and_reset</a> ()</td></tr>
<tr class="separator:aa2a82f156a68dfe1b7553310c7b2e862"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad901a614268b4aca7eb8307e1734e970"><td class="memItemLeft" align="right" valign="top"><a id="ad901a614268b4aca7eb8307e1734e970"></a>
const typedef value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:ad901a614268b4aca7eb8307e1734e970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f8fe90892fabeef245abd1ff99ec10"><td class="memItemLeft" align="right" valign="top"><a id="a34f8fe90892fabeef245abd1ff99ec10"></a>
const typedef value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a34f8fe90892fabeef245abd1ff99ec10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fa2193cea69ef57b3873c46386f279"><td class="memItemLeft" align="right" valign="top"><a id="af1fa2193cea69ef57b3873c46386f279"></a>
const typedef node_type *&#160;</td><td class="memItemRight" valign="bottom"><b>const_node_ptr_type</b></td></tr>
<tr class="separator:af1fa2193cea69ef57b3873c46386f279"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a3f47b700cc4d99ebfe7fbc3a0bf60bbd"><td class="memItemLeft" align="right" valign="top"><a id="a3f47b700cc4d99ebfe7fbc3a0bf60bbd"></a>
typedef Internal::rbtree_node_base *&#160;</td><td class="memItemRight" valign="bottom"><b>base_node_ptr_type</b></td></tr>
<tr class="separator:a3f47b700cc4d99ebfe7fbc3a0bf60bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abb10b834bb3cd1709caaaca9398c787c"><td class="memItemLeft" align="right" valign="top"><a id="abb10b834bb3cd1709caaaca9398c787c"></a>
const typedef Internal::rbtree_node_base *&#160;</td><td class="memItemRight" valign="bottom"><b>const_base_node_ptr_type</b></td></tr>
<tr class="separator:abb10b834bb3cd1709caaaca9398c787c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Traits&gt;<br />
class AZStd::rbtree&lt; Traits &gt;</h3>

<p>Generic red-black tree. Based on the STLport implementation. In addition to all <a class="el" href="namespace_a_z_std.html" title="AZ namespace needs to be closed in order to specialize the AZStd::hash struct for AddressTypeElement ...">AZStd</a> extensions and requirements, we use compressed node which saves about ~25% of the tree overhead. This is the base container used for <a class="el" href="class_a_z_std_1_1set.html">AZStd::set</a>,<a class="el" href="class_a_z_std_1_1multiset.html">AZStd::multiset</a>,<a class="el" href="class_a_z_std_1_1map.html">AZStd::map</a> and <a class="el" href="class_a_z_std_1_1multimap.html">AZStd::multimap</a>.</p>
<p>RedBlackTreeTest for examples.</p>
<p>Traits should have the following members typedef xxx key_type; typedef xxx key_equal; typedef xxx value_type; typedef xxx allocator_type; enum { has_multi_elements = true or false, is_dynamic = true or false, // true if we have fixed container. If we do so we will need to se fixed_num_buckets and fixed_num_elements. }</p>
<p>static inline const key_type&amp; key_from_value(const value_type&amp; value); </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa2a82f156a68dfe1b7553310c7b2e862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a82f156a68dfe1b7553310c7b2e862">&#9670;&nbsp;</a></span>leak_and_reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_a_z_std_1_1rbtree.html">AZStd::rbtree</a>&lt; Traits &gt;::leak_and_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets the container without deallocating any memory or calling any destructor. This function should be used when we need very quick tear down. Generally it's used for temporary vectors and we can just nuke them that way. In addition the provided <a class="el" href="_allocators.html">Allocators</a>, has leak and reset flag which will enable automatically this behavior. So this function should be used in special cases AZStdExamples. </p><dl class="section note"><dt>Note</dt><dd>This function is added to the vector for consistency. In the vector case we have only one allocation, and if the allocator allows memory leaks it can just leave deallocate function empty, which performance wise will be the same. For more complex containers this will make big difference. </dd></dl>

</div>
</div>
<a id="a60d84597279f45fd4fb59fb2e6adafc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d84597279f45fd4fb59fb2e6adafc5">&#9670;&nbsp;</a></span>node_handle_extract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<div class="memtemplate">
template&lt;class NodeHandle &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeHandle <a class="el" href="class_a_z_std_1_1rbtree.html">AZStd::rbtree</a>&lt; Traits &gt;::node_handle_extract </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for an element which matches the value of key and extracts it from the <a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a> </p><dl class="section return"><dt>Returns</dt><dd>A NodeHandle which can be used to insert the an element between unique and non-unique containers of the same type i.e a NodeHandle from an <a class="el" href="class_a_z_std_1_1unordered__map.html">unordered_map</a> can be used to insert a node into an <a class="el" href="class_a_z_std_1_1unordered__multimap.html">unordered_multimap</a>, but not a std::map </dd></dl>

</div>
</div>
<a id="ac71730ba5e3cac7386ad9c223ebf5209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71730ba5e3cac7386ad9c223ebf5209">&#9670;&nbsp;</a></span>node_handle_extract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<div class="memtemplate">
template&lt;class NodeHandle &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeHandle <a class="el" href="class_a_z_std_1_1rbtree.html">AZStd::rbtree</a>&lt; Traits &gt;::node_handle_extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds an element within the <a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a> that is represented by the supplied iterator and extracts it </p><dl class="section return"><dt>Returns</dt><dd>A NodeHandle which can be used to insert the an element between unique and non-unique containers of the same type </dd></dl>

</div>
</div>
<a id="a03292f2d5c86394b43db5755ec40431f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03292f2d5c86394b43db5755ec40431f">&#9670;&nbsp;</a></span>node_handle_insert_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<div class="memtemplate">
template&lt;class NodeHandle &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_a_z_std_1_1rbtree.html">AZStd::rbtree</a>&lt; Traits &gt;::node_handle_insert_equal </td>
          <td>(</td>
          <td class="paramtype">NodeHandle &amp;&amp;&#160;</td>
          <td class="paramname"><em>nodeHandle</em></td><td>)</td>
          <td> -&gt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the inserted element. If the nodeHandle is empty the end() iterator is returned </p>

</div>
</div>
<a id="ad679828b56edf29b1afcfabb6b6812a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad679828b56edf29b1afcfabb6b6812a9">&#9670;&nbsp;</a></span>node_handle_insert_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<div class="memtemplate">
template&lt;class InsertReturnType , class NodeHandle &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InsertReturnType <a class="el" href="class_a_z_std_1_1rbtree.html">AZStd::rbtree</a>&lt; Traits &gt;::node_handle_insert_unique </td>
          <td>(</td>
          <td class="paramtype">NodeHandle &amp;&amp;&#160;</td>
          <td class="paramname"><em>nodeHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an insert_return_type with the members initialized as follows: if nodeHandle is empty, inserted is false, position is end(), and node is empty. Otherwise if the insertion took place, inserted is true, position points to the inserted element, and node is empty. If the insertion failed, inserted is false, node has the previous value of nodeHandle, and position points to an element with a key equivalent to nodeHandle.key(). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Code/Framework/AzCore/AzCore/std/containers/node_handle.h</li>
<li>Code/Framework/AzCore/AzCore/std/containers/rbtree.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 5 2022 14:03:57 for Open 3D Engine AzCore API Reference by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
