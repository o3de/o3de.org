<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine AzCore API Reference: AZ::DataPatch Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="/images/api-reference/api-ref-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine AzCore API Reference
   &#160;<span id="projectnumber">22.10.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><a class="el" href="class_a_z_1_1_data_patch.html">DataPatch</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_a_z_1_1_data_patch-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AZ::DataPatch Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;DataPatch.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_data_patch_1_1_legacy_stream_wrapper.html">LegacyStreamWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a39e6073764052c3b6a1115d3dc0d44ce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_data_patch.html#a39e6073764052c3b6a1115d3dc0d44ce">Flag</a> : Flags { <br />
&#160;&#160;<a class="el" href="class_a_z_1_1_data_patch.html#a39e6073764052c3b6a1115d3dc0d44ceae830e298995c51fb245d124aba8f63c8">ForceOverrideSet</a> = 1 &lt;&lt; 0, 
<a class="el" href="class_a_z_1_1_data_patch.html#a39e6073764052c3b6a1115d3dc0d44cea06d7dddbd8b8c4a188796b8e878f2ab6">PreventOverrideSet</a> = 1 &lt;&lt; 1, 
<a class="el" href="class_a_z_1_1_data_patch.html#a39e6073764052c3b6a1115d3dc0d44ceab496927b8a6ba358e7a4d70c747bb981">HidePropertySet</a> = 1 &lt;&lt; 2, 
<a class="el" href="class_a_z_1_1_data_patch.html#a39e6073764052c3b6a1115d3dc0d44cead6c43a6693627d56d8d456adf0118fe7">ForceOverrideEffect</a> = 1 &lt;&lt; 4, 
<br />
&#160;&#160;<a class="el" href="class_a_z_1_1_data_patch.html#a39e6073764052c3b6a1115d3dc0d44ceacf79bd5aae2d4d0f3c55442305b147f5">PreventOverrideEffect</a> = 1 &lt;&lt; 5, 
<a class="el" href="class_a_z_1_1_data_patch.html#a39e6073764052c3b6a1115d3dc0d44ceae7d59ce4872786fc02af614d6ba80711">HidePropertyEffect</a> = 1 &lt;&lt; 6, 
<b>SetMask</b> = 0x0F, 
<b>EffectMask</b> = 0xF0
<br />
 }</td></tr>
<tr class="separator:a39e6073764052c3b6a1115d3dc0d44ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b129d80b658edd528260f2f79978be"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">Flags</a> = AZ::u8</td></tr>
<tr class="separator:ad7b129d80b658edd528260f2f79978be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a780be087b06b5755b4d11264f18a02"><td class="memItemLeft" align="right" valign="top"><a id="a8a780be087b06b5755b4d11264f18a02"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_data_patch.html#a8a780be087b06b5755b4d11264f18a02">AddressTypeElement</a> = DataPatchInternal::AddressTypeElement</td></tr>
<tr class="memdesc:a8a780be087b06b5755b4d11264f18a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias the DataPatchInternal::AddressType inside the <a class="el" href="class_a_z_1_1_data_patch.html">DataPatch</a> declaration for backwards compatibility with DataPatch::AddressType. <br /></td></tr>
<tr class="separator:a8a780be087b06b5755b4d11264f18a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87105cd1391b3ab80202faf5f3293b8c"><td class="memItemLeft" align="right" valign="top"><a id="a87105cd1391b3ab80202faf5f3293b8c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>AddressType</b> = DataPatchInternal::AddressType</td></tr>
<tr class="separator:a87105cd1391b3ab80202faf5f3293b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68416b5bd5536fa8949e604d603d3290"><td class="memItemLeft" align="right" valign="top"><a id="a68416b5bd5536fa8949e604d603d3290"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PatchMap</b> = <a class="el" href="class_a_z_std_1_1unordered__map.html">DataPatchInternal::PatchMap</a></td></tr>
<tr class="separator:a68416b5bd5536fa8949e604d603d3290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7c3c0fff9fa2cfda69415b8a040cf5"><td class="memItemLeft" align="right" valign="top"><a id="add7c3c0fff9fa2cfda69415b8a040cf5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ChildPatchMap</b> = <a class="el" href="class_a_z_std_1_1unordered__map.html">DataPatchInternal::ChildPatchMap</a></td></tr>
<tr class="separator:add7c3c0fff9fa2cfda69415b8a040cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4c0a62c0b6096b97217a05b31db07f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a> = <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map</a>&lt; AddressType, <a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">Flags</a> &gt;</td></tr>
<tr class="separator:a3f4c0a62c0b6096b97217a05b31db07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3aa83691fa4d9a8a106cdde152f29ff"><td class="memItemLeft" align="right" valign="top"><a id="ac3aa83691fa4d9a8a106cdde152f29ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DataPatch</b> (const <a class="el" href="class_a_z_1_1_data_patch.html">DataPatch</a> &amp;rhs)</td></tr>
<tr class="separator:ac3aa83691fa4d9a8a106cdde152f29ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8f1bb3dd3fc1ad92445d901ac28f28"><td class="memItemLeft" align="right" valign="top"><a id="a6c8f1bb3dd3fc1ad92445d901ac28f28"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DataPatch</b> (<a class="el" href="class_a_z_1_1_data_patch.html">DataPatch</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a6c8f1bb3dd3fc1ad92445d901ac28f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1796dfc9692050007369e6dc3dbb530"><td class="memItemLeft" align="right" valign="top"><a id="ac1796dfc9692050007369e6dc3dbb530"></a>
<a class="el" href="class_a_z_1_1_data_patch.html">DataPatch</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_a_z_1_1_data_patch.html">DataPatch</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:ac1796dfc9692050007369e6dc3dbb530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17df5e1e2e8ac23b7b47367ec5bb0c9"><td class="memItemLeft" align="right" valign="top"><a id="ac17df5e1e2e8ac23b7b47367ec5bb0c9"></a>
<a class="el" href="class_a_z_1_1_data_patch.html">DataPatch</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_a_z_1_1_data_patch.html">DataPatch</a> &amp;rhs)</td></tr>
<tr class="separator:ac17df5e1e2e8ac23b7b47367ec5bb0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4fb05a064dad93ee2a9b486c034d98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_data_patch.html#a1f4fb05a064dad93ee2a9b486c034d98">Create</a> (const void *source, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;souceClassId, const void *target, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;targetClassId, const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a> &amp;sourceFlagsMap=<a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a>(), const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a> &amp;targetFlagsMap=<a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a>(), <a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> *context=nullptr)</td></tr>
<tr class="separator:a1f4fb05a064dad93ee2a9b486c034d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfe5246f05dcd7474a623e2094207a3"><td class="memTemplParams" colspan="2"><a id="a1dfe5246f05dcd7474a623e2094207a3"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a1dfe5246f05dcd7474a623e2094207a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_data_patch.html#a1dfe5246f05dcd7474a623e2094207a3">Create</a> (const T *source, const U *target, const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a> &amp;sourceFlagsMap=<a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a>(), const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a> &amp;targetFlagsMap=<a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a>(), <a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> *context=nullptr)</td></tr>
<tr class="memdesc:a1dfe5246f05dcd7474a623e2094207a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">T and U should either be the same type a common base class. <br /></td></tr>
<tr class="separator:a1dfe5246f05dcd7474a623e2094207a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb1021f7a8e59c9f635a5c54405bd6f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_data_patch.html#a0bb1021f7a8e59c9f635a5c54405bd6f">Apply</a> (const void *source, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;sourceClassId, <a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> *context=nullptr, const <a class="el" href="struct_a_z_1_1_object_stream_1_1_filter_descriptor.html">AZ::ObjectStream::FilterDescriptor</a> &amp;filterDesc=<a class="el" href="struct_a_z_1_1_object_stream_1_1_filter_descriptor.html">AZ::ObjectStream::FilterDescriptor</a>(), const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a> &amp;sourceFlagsMap=<a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a>(), const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a> &amp;targetFlagsMap=<a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a>()) const</td></tr>
<tr class="separator:a0bb1021f7a8e59c9f635a5c54405bd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea6724dddbff1205b3bdea3be756cb7"><td class="memTemplParams" colspan="2"><a id="acea6724dddbff1205b3bdea3be756cb7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:acea6724dddbff1205b3bdea3be756cb7"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Apply</b> (const T *source, <a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> *context=nullptr, const <a class="el" href="struct_a_z_1_1_object_stream_1_1_filter_descriptor.html">AZ::ObjectStream::FilterDescriptor</a> &amp;filterDesc=<a class="el" href="struct_a_z_1_1_object_stream_1_1_filter_descriptor.html">AZ::ObjectStream::FilterDescriptor</a>(), const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a> &amp;sourceFlagsMap=<a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a>(), const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a> &amp;targetFlagsMap=<a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a>()) const</td></tr>
<tr class="separator:acea6724dddbff1205b3bdea3be756cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545fb6779ea0e37a0ba2bb548b262de5"><td class="memTemplParams" colspan="2"><a id="a545fb6779ea0e37a0ba2bb548b262de5"></a>
template&lt;class U , class T &gt; </td></tr>
<tr class="memitem:a545fb6779ea0e37a0ba2bb548b262de5"><td class="memTemplItemLeft" align="right" valign="top">U *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Apply</b> (const T *source, <a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> *context=nullptr, const <a class="el" href="struct_a_z_1_1_object_stream_1_1_filter_descriptor.html">AZ::ObjectStream::FilterDescriptor</a> &amp;filterDesc=<a class="el" href="struct_a_z_1_1_object_stream_1_1_filter_descriptor.html">AZ::ObjectStream::FilterDescriptor</a>(), const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a> &amp;sourceFlagsMap=<a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a>(), const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a> &amp;targetFlagsMap=<a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a>()) const</td></tr>
<tr class="separator:a545fb6779ea0e37a0ba2bb548b262de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826d7166a7f1ee584907675b7c8576cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_data_patch.html#a826d7166a7f1ee584907675b7c8576cf">IsValid</a> () const</td></tr>
<tr class="separator:a826d7166a7f1ee584907675b7c8576cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce454e1de9acc92ebc51f962f6eabea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_data_patch.html#a3ce454e1de9acc92ebc51f962f6eabea">IsData</a> () const</td></tr>
<tr class="separator:a3ce454e1de9acc92ebc51f962f6eabea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6cf9daf6f1b0a90ab1f3e982cdffbbfd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">Flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_data_patch.html#a6cf9daf6f1b0a90ab1f3e982cdffbbfd">GetEffectOfParentFlagsOnThisAddress</a> (<a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">Flags</a> flagsAtParentAddress)</td></tr>
<tr class="separator:a6cf9daf6f1b0a90ab1f3e982cdffbbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d6e0ae767e5ea03db0c4fead472146"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">Flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_data_patch.html#a24d6e0ae767e5ea03db0c4fead472146">GetEffectOfSourceFlagsOnThisAddress</a> (<a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">Flags</a> flagsAtSourceAddress)</td></tr>
<tr class="separator:a24d6e0ae767e5ea03db0c4fead472146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757f085afcd16c172527bd17804b536b"><td class="memItemLeft" align="right" valign="top"><a id="a757f085afcd16c172527bd17804b536b"></a>
static <a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">Flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_data_patch.html#a757f085afcd16c172527bd17804b536b">GetEffectOfTargetFlagsOnThisAddress</a> (<a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">Flags</a> flagsAtTargetAddress)</td></tr>
<tr class="memdesc:a757f085afcd16c172527bd17804b536b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given data flags for target data at this address, return the effect on a <a class="el" href="class_a_z_1_1_data_patch.html">DataPatch</a>. <br /></td></tr>
<tr class="separator:a757f085afcd16c172527bd17804b536b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae99444d82eea80e45d3a4a546abb0c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_data_patch.html#a8ae99444d82eea80e45d3a4a546abb0c">Reflect</a> (<a class="el" href="class_a_z_1_1_reflect_context.html">ReflectContext</a> *context)</td></tr>
<tr class="separator:a8ae99444d82eea80e45d3a4a546abb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d5c6e447227923d4d9f2d60ca60235"><td class="memItemLeft" align="right" valign="top"><a id="a32d5c6e447227923d4d9f2d60ca60235"></a>
static const AZ_INLINE <a class="el" href="struct_a_z_1_1_uuid.html">AZ::Uuid</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetLegacyDataPatchTypeId</b> ()</td></tr>
<tr class="separator:a32d5c6e447227923d4d9f2d60ca60235"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2aad01833ced21b1da9cbd819a88dfd2"><td class="memItemLeft" align="right" valign="top"><a id="a2aad01833ced21b1da9cbd819a88dfd2"></a>
<a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_targetClassId</b></td></tr>
<tr class="separator:a2aad01833ced21b1da9cbd819a88dfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf3be525c09f5f725d047d9023ecbfd"><td class="memItemLeft" align="right" valign="top"><a id="a3cf3be525c09f5f725d047d9023ecbfd"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>m_targetClassVersion</b></td></tr>
<tr class="separator:a3cf3be525c09f5f725d047d9023ecbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb85cc9bea23489b3b63d5b16a0eb34"><td class="memItemLeft" align="right" valign="top"><a id="adbb85cc9bea23489b3b63d5b16a0eb34"></a>
<a class="el" href="class_a_z_std_1_1unordered__map.html">PatchMap</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_patch</b></td></tr>
<tr class="separator:adbb85cc9bea23489b3b63d5b16a0eb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Structure that contains patch data for a given class. The primary goal of this object is to help with tools (slices and undo/redo), this structure is not recommended to runtime due to efficiency. If you want dynamically configure objects, use data overlay which are more efficient and generic. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad7b129d80b658edd528260f2f79978be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b129d80b658edd528260f2f79978be">&#9670;&nbsp;</a></span>Flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">AZ::DataPatch::Flags</a> =  AZ::u8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data Patches have been updated to be human readable. For backwards compatibility the <a class="el" href="class_a_z_1_1_data_patch.html">DataPatch</a> type <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> has been modified and a deprecation converter is used to convert. Data addresses can be tagged with flags to affect how patches are created and applied. </p>

</div>
</div>
<a id="a3f4c0a62c0b6096b97217a05b31db07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4c0a62c0b6096b97217a05b31db07f">&#9670;&nbsp;</a></span>FlagsMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">AZ::DataPatch::FlagsMap</a> =  <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map</a>&lt;AddressType, <a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">Flags</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data flags, mapped by the address where the flags are set. When patching, an address is affected not only by the flags set AT that address, but also the flags set at any parent address. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a39e6073764052c3b6a1115d3dc0d44ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e6073764052c3b6a1115d3dc0d44ce">&#9670;&nbsp;</a></span>Flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_a_z_1_1_data_patch.html#a39e6073764052c3b6a1115d3dc0d44ce">AZ::DataPatch::Flag</a> : <a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">Flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bit fields for data flags. These options affect how patches are created and applied. There are two categories of flags:</p><ol type="1">
<li>Set: These flags are manually set by users at a specific address. They are serialized to disk.</li>
<li>Effect: These flags denote the addresses influenced by a "Set" flag. They are runtime-only and should not be serialized to disk. </li>
</ol>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a39e6073764052c3b6a1115d3dc0d44ceae830e298995c51fb245d124aba8f63c8"></a>ForceOverrideSet&#160;</td><td class="fielddoc"><p>Data at this address always overrides data from the source. </p>
</td></tr>
<tr><td class="fieldname"><a id="a39e6073764052c3b6a1115d3dc0d44cea06d7dddbd8b8c4a188796b8e878f2ab6"></a>PreventOverrideSet&#160;</td><td class="fielddoc"><p>Data at this address can't be overridden by a target. </p>
</td></tr>
<tr><td class="fieldname"><a id="a39e6073764052c3b6a1115d3dc0d44ceab496927b8a6ba358e7a4d70c747bb981"></a>HidePropertySet&#160;</td><td class="fielddoc"><p>The property associated with this address will be hidden when viewing a target. </p>
</td></tr>
<tr><td class="fieldname"><a id="a39e6073764052c3b6a1115d3dc0d44cead6c43a6693627d56d8d456adf0118fe7"></a>ForceOverrideEffect&#160;</td><td class="fielddoc"><p>Data at this address is affected by ForceOverride and always overrides its source. </p>
</td></tr>
<tr><td class="fieldname"><a id="a39e6073764052c3b6a1115d3dc0d44ceacf79bd5aae2d4d0f3c55442305b147f5"></a>PreventOverrideEffect&#160;</td><td class="fielddoc"><p>Data at this address is affected by PreventOverride and cannot override its source. </p>
</td></tr>
<tr><td class="fieldname"><a id="a39e6073764052c3b6a1115d3dc0d44ceae7d59ce4872786fc02af614d6ba80711"></a>HidePropertyEffect&#160;</td><td class="fielddoc"><p>Data at this address is affected by HideProperty and cannot be seen when viewing the target. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0bb1021f7a8e59c9f635a5c54405bd6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb1021f7a8e59c9f635a5c54405bd6f">&#9670;&nbsp;</a></span>Apply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* AZ::DataPatch::Apply </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceClassId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> *&#160;</td>
          <td class="paramname"><em>context</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_object_stream_1_1_filter_descriptor.html">AZ::ObjectStream::FilterDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>filterDesc</em> = <code><a class="el" href="struct_a_z_1_1_object_stream_1_1_filter_descriptor.html">AZ::ObjectStream::FilterDescriptor</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceFlagsMap</em> = <code><a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a> &amp;&#160;</td>
          <td class="paramname"><em>targetFlagsMap</em> = <code><a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the patch to a source instance and generate a patched instance, from a source instance. If patch can't be applied a null pointer is returned. Currently the only reason for that is if the resulting class ID doesn't match the stored root of the patch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>pointer to the source instance. </td></tr>
    <tr><td class="paramname">sourceClassID</td><td>id of the class source is pointing to. </td></tr>
    <tr><td class="paramname">context</td><td>if null we will grab the default serialize context. </td></tr>
    <tr><td class="paramname">filterDesc</td><td>customizable filter for data in patch (ex: filter out classes and assets) </td></tr>
    <tr><td class="paramname">sourceFlagsMap</td><td>flags for source data. These may affect how a patch is applied (ex: prevent patching of specific addresses) </td></tr>
    <tr><td class="paramname">targetFlagsMap</td><td>flags for target data. These may affect how a patch is applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f4fb05a064dad93ee2a9b486c034d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4fb05a064dad93ee2a9b486c034d98">&#9670;&nbsp;</a></span>Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::DataPatch::Create </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>souceClassId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>targetClassId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a> &amp;&#160;</td>
          <td class="paramname"><em>sourceFlagsMap</em> = <code><a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a> &amp;&#160;</td>
          <td class="paramname"><em>targetFlagsMap</em> = <code><a class="el" href="class_a_z_1_1_data_patch.html#a3f4c0a62c0b6096b97217a05b31db07f">FlagsMap</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> *&#160;</td>
          <td class="paramname"><em>context</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a patch structure which generate the delta (patcher) from source to the target type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>object we will use a base for the delta </td></tr>
    <tr><td class="paramname">souceClassId</td><td>class of the source type, either the same as targetClassId or a base class </td></tr>
    <tr><td class="paramname">target</td><td>object we want to have is we have source and apply the returned patcher. </td></tr>
    <tr><td class="paramname">targetClassId</td><td>class of the target type, either the same as sourceClassId or a base class </td></tr>
    <tr><td class="paramname">sourceFlagsMap</td><td>(optional) flags for source data. These may affect how the patch is created (ex: prevent patches at specific addresses) </td></tr>
    <tr><td class="paramname">targetFlagsMap</td><td>(optional) flags for target data. These may affect how the patch is created (ex: force patches at specific addresses) </td></tr>
    <tr><td class="paramname">context</td><td>if null we will grab the default serialize context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cf9daf6f1b0a90ab1f3e982cdffbbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf9daf6f1b0a90ab1f3e982cdffbbfd">&#9670;&nbsp;</a></span>GetEffectOfParentFlagsOnThisAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">Flags</a> AZ::DataPatch::GetEffectOfParentFlagsOnThisAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">Flags</a>&#160;</td>
          <td class="paramname"><em>flagsAtParentAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given data flags affecting the parent address, return the effect upon the child address. An example of a parent and child would be a vector and an element in that vector. </p>

</div>
</div>
<a id="a24d6e0ae767e5ea03db0c4fead472146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d6e0ae767e5ea03db0c4fead472146">&#9670;&nbsp;</a></span>GetEffectOfSourceFlagsOnThisAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">Flags</a> AZ::DataPatch::GetEffectOfSourceFlagsOnThisAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_data_patch.html#ad7b129d80b658edd528260f2f79978be">Flags</a>&#160;</td>
          <td class="paramname"><em>flagsAtSourceAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given data flags for source data at this address, return the effect on a <a class="el" href="class_a_z_1_1_data_patch.html">DataPatch</a>. An example of source data would be the slice upon which a slice-instance is based. </p>

</div>
</div>
<a id="a3ce454e1de9acc92ebc51f962f6eabea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce454e1de9acc92ebc51f962f6eabea">&#9670;&nbsp;</a></span>IsData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::DataPatch::IsData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true of the patch actually contains data for patching otherwise false. </dd></dl>

</div>
</div>
<a id="a826d7166a7f1ee584907675b7c8576cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826d7166a7f1ee584907675b7c8576cf">&#9670;&nbsp;</a></span>IsValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::DataPatch::IsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this is a valid patch. </dd></dl>

</div>
</div>
<a id="a8ae99444d82eea80e45d3a4a546abb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae99444d82eea80e45d3a4a546abb0c">&#9670;&nbsp;</a></span>Reflect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void AZ::DataPatch::Reflect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_reflect_context.html">ReflectContext</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reflect a patch for serialization. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Code/Framework/AzCore/AzCore/Serialization/DataPatch.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 5 2022 14:03:27 for Open 3D Engine AzCore API Reference by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
