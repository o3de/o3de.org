<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine AzCore API Reference: AZ::SerializeContext Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="/images/api-reference/api-ref-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine AzCore API Reference
   &#160;<span id="projectnumber">22.10.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_a_z_1_1_serialize_context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AZ::SerializeContext Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;SerializeContext.h&gt;</code></p>

<p>Inherits <a class="el" href="class_a_z_1_1_reflect_context.html">AZ::ReflectContext</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context_1_1_class_builder.html">ClassBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context_1_1_class_data.html">ClassData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_serialize_context_1_1_class_element.html">ClassElement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_serialize_context_1_1_data_element.html">DataElement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context_1_1_data_element_node.html">DataElementNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context_1_1_data_patch_name_upgrade.html">DataPatchNameUpgrade</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context_1_1_data_patch_type_upgrade.html">DataPatchTypeUpgrade</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context_1_1_data_patch_upgrade.html">DataPatchUpgrade</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context_1_1_data_patch_upgrade_handler.html">DataPatchUpgradeHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_serialize_context_1_1_dbg_stack_entry.html">DbgStackEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context_1_1_enum_builder.html">EnumBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_serialize_context_1_1_enumerate_instance_call_context.html">EnumerateInstanceCallContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_serialize_context_1_1_equality_compare_helper.html">EqualityCompareHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context_1_1_error_handler.html">ErrorHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context_1_1_i_data_container.html">IDataContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context_1_1_i_data_converter.html">IDataConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context_1_1_i_data_serializer.html">IDataSerializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context_1_1_i_event_handler.html">IEventHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context_1_1_i_object_factory.html">IObjectFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_serialize_context_1_1_node_upgrade_sort_functor.html">NodeUpgradeSortFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context_1_1_per_module_generic_class_info.html">PerModuleGenericClassInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aba1a0ffaf9ba8bad6605d4044bcc7b69"><td class="memItemLeft" align="right" valign="top"><a id="aba1a0ffaf9ba8bad6605d4044bcc7b69"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IRttiHelper</b> = <a class="el" href="class_a_z_1_1_i_rtti_helper.html">AZ::IRttiHelper</a></td></tr>
<tr class="separator:aba1a0ffaf9ba8bad6605d4044bcc7b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419238e68e09e321f7f8747b5f983ec2"><td class="memItemLeft" align="right" valign="top"><a id="a419238e68e09e321f7f8747b5f983ec2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IDataSerializerDeleter</b> = <a class="el" href="class_a_z_std_1_1function.html">AZStd::function</a>&lt; void(<a class="el" href="class_a_z_1_1_serialize_context_1_1_i_data_serializer.html">IDataSerializer</a> *ptr)&gt;</td></tr>
<tr class="separator:a419238e68e09e321f7f8747b5f983ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd6057ed47c3ab08bbe33c3e9e1f1ef"><td class="memItemLeft" align="right" valign="top"><a id="a1bd6057ed47c3ab08bbe33c3e9e1f1ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IDataSerializerPtr</b> = <a class="el" href="namespace_a_z_std.html#aeb4832383c83113340791a3ab3fe87f0">AZStd::unique_ptr</a>&lt; <a class="el" href="class_a_z_1_1_serialize_context_1_1_i_data_serializer.html">IDataSerializer</a>, <a class="el" href="class_a_z_std_1_1function.html">IDataSerializerDeleter</a> &gt;</td></tr>
<tr class="separator:a1bd6057ed47c3ab08bbe33c3e9e1f1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83071151391be9479cb7767f815c3139"><td class="memItemLeft" align="right" valign="top"><a id="a83071151391be9479cb7767f815c3139"></a>
typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#a83071151391be9479cb7767f815c3139">VersionConverter</a>) (<a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> &amp;, <a class="el" href="class_a_z_1_1_serialize_context_1_1_data_element_node.html">DataElementNode</a> &amp;)</td></tr>
<tr class="memdesc:a83071151391be9479cb7767f815c3139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to process data conversion. <br /></td></tr>
<tr class="separator:a83071151391be9479cb7767f815c3139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744fde9cdda7fab9939793a55efe4416"><td class="memItemLeft" align="right" valign="top">typedef u64(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#a744fde9cdda7fab9939793a55efe4416">ClassPersistentId</a>) (const void *)</td></tr>
<tr class="memdesc:a744fde9cdda7fab9939793a55efe4416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for persistent ID for an instance.  <a href="class_a_z_1_1_serialize_context.html#a744fde9cdda7fab9939793a55efe4416">More...</a><br /></td></tr>
<tr class="separator:a744fde9cdda7fab9939793a55efe4416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaeb2634ffe8b0975896f0cc06a5a340"><td class="memItemLeft" align="right" valign="top"><a id="aaaeb2634ffe8b0975896f0cc06a5a340"></a>
typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#aaaeb2634ffe8b0975896f0cc06a5a340">ClassDoSave</a>) (const void *)</td></tr>
<tr class="memdesc:aaaeb2634ffe8b0975896f0cc06a5a340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to manipulate entity saving on a yes/no base, otherwise you will need provide serializer for more advanced logic. <br /></td></tr>
<tr class="separator:aaaeb2634ffe8b0975896f0cc06a5a340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac277fe1a16871924502cf349c8ba0a2a"><td class="memItemLeft" align="right" valign="top"><a id="ac277fe1a16871924502cf349c8ba0a2a"></a>
typedef <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map</a>&lt; <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a>, <a class="el" href="class_a_z_1_1_serialize_context_1_1_class_data.html">ClassData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>UuidToClassMap</b></td></tr>
<tr class="separator:ac277fe1a16871924502cf349c8ba0a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac1fae2dd82f6a9954f507cd468035aa8"><td class="memItemLeft" align="right" valign="top"><a id="ac1fae2dd82f6a9954f507cd468035aa8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_CLASS_ALLOCATOR</b> (<a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a>, <a class="el" href="class_a_z_1_1_system_allocator.html">SystemAllocator</a>, 0)</td></tr>
<tr class="separator:ac1fae2dd82f6a9954f507cd468035aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45ed3b9e1e4a62b36ddaf28a61fc44b"><td class="memItemLeft" align="right" valign="top"><a id="ac45ed3b9e1e4a62b36ddaf28a61fc44b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AZ_RTTI</b> (<a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a>, &quot;{83482F97-84DA-4FD4-BF9E-7FE34C8E091F}&quot;, ReflectContext)</td></tr>
<tr class="separator:ac45ed3b9e1e4a62b36ddaf28a61fc44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0634d9e1dd8256fd706efc569c4d5481"><td class="memItemLeft" align="right" valign="top"><a id="a0634d9e1dd8256fd706efc569c4d5481"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#a0634d9e1dd8256fd706efc569c4d5481">SerializeContext</a> (bool registerIntegralTypes=true, bool createEditContext=false)</td></tr>
<tr class="memdesc:a0634d9e1dd8256fd706efc569c4d5481"><td class="mdescLeft">&#160;</td><td class="mdescRight">If registerIntegralTypes is true we will register the default serializer for all integral types. <br /></td></tr>
<tr class="separator:a0634d9e1dd8256fd706efc569c4d5481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7115c7abbb38f4b78e6be6f54417f81f"><td class="memItemLeft" align="right" valign="top"><a id="a7115c7abbb38f4b78e6be6f54417f81f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#a7115c7abbb38f4b78e6be6f54417f81f">SerializeContext</a> (const <a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> &amp;)=delete</td></tr>
<tr class="memdesc:a7115c7abbb38f4b78e6be6f54417f81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleting copy ctor because we own unique_ptr's of IDataContainers. <br /></td></tr>
<tr class="separator:a7115c7abbb38f4b78e6be6f54417f81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7542ec321d3b8dfab93181d366a82714"><td class="memItemLeft" align="right" valign="top"><a id="a7542ec321d3b8dfab93181d366a82714"></a>
<a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> &amp;)=delete</td></tr>
<tr class="separator:a7542ec321d3b8dfab93181d366a82714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8beb6050f3ceb2476611f0a7ff98286d"><td class="memItemLeft" align="right" valign="top"><a id="a8beb6050f3ceb2476611f0a7ff98286d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsTypeReflected</b> (<a class="el" href="struct_a_z_1_1_uuid.html">AZ::Uuid</a> typeId) const override</td></tr>
<tr class="separator:a8beb6050f3ceb2476611f0a7ff98286d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8359902a9aea583d05aadf26ff326c7e"><td class="memItemLeft" align="right" valign="top"><a id="a8359902a9aea583d05aadf26ff326c7e"></a>
<a class="el" href="class_a_z_1_1_edit_context.html">EditContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#a8359902a9aea583d05aadf26ff326c7e">CreateEditContext</a> ()</td></tr>
<tr class="memdesc:a8359902a9aea583d05aadf26ff326c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an edit context for this serialize context. If one already exist it will be returned. <br /></td></tr>
<tr class="separator:a8359902a9aea583d05aadf26ff326c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59bea4d40901d855417284964b2cda5"><td class="memItemLeft" align="right" valign="top"><a id="ac59bea4d40901d855417284964b2cda5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#ac59bea4d40901d855417284964b2cda5">DestroyEditContext</a> ()</td></tr>
<tr class="memdesc:ac59bea4d40901d855417284964b2cda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the internal edit context, all edit related data will be freed. You don't have call DestroyEditContext, it's called when you destroy the serialize context. <br /></td></tr>
<tr class="separator:ac59bea4d40901d855417284964b2cda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8713e91f3bfad464c4d95ca6cd3023f"><td class="memItemLeft" align="right" valign="top"><a id="ae8713e91f3bfad464c4d95ca6cd3023f"></a>
<a class="el" href="class_a_z_1_1_edit_context.html">EditContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#ae8713e91f3bfad464c4d95ca6cd3023f">GetEditContext</a> () const</td></tr>
<tr class="memdesc:ae8713e91f3bfad464c4d95ca6cd3023f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer to the current edit context or NULL if one was not created. <br /></td></tr>
<tr class="separator:ae8713e91f3bfad464c4d95ca6cd3023f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_a_z_1_1_reflect_context"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_a_z_1_1_reflect_context')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_a_z_1_1_reflect_context.html">AZ::ReflectContext</a></td></tr>
<tr class="memitem:a5fa96b445f9dac0af902d85e015a99af inherit pub_methods_class_a_z_1_1_reflect_context"><td class="memItemLeft" align="right" valign="top"><a id="a5fa96b445f9dac0af902d85e015a99af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EnableRemoveReflection</b> ()</td></tr>
<tr class="separator:a5fa96b445f9dac0af902d85e015a99af inherit pub_methods_class_a_z_1_1_reflect_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4357bc4c8024b462360d5cb37e1f92d2 inherit pub_methods_class_a_z_1_1_reflect_context"><td class="memItemLeft" align="right" valign="top"><a id="a4357bc4c8024b462360d5cb37e1f92d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DisableRemoveReflection</b> ()</td></tr>
<tr class="separator:a4357bc4c8024b462360d5cb37e1f92d2 inherit pub_methods_class_a_z_1_1_reflect_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf890fdba1467f92406d61fb6322894 inherit pub_methods_class_a_z_1_1_reflect_context"><td class="memItemLeft" align="right" valign="top"><a id="a5bf890fdba1467f92406d61fb6322894"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsRemovingReflection</b> () const</td></tr>
<tr class="separator:a5bf890fdba1467f92406d61fb6322894 inherit pub_methods_class_a_z_1_1_reflect_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fda7a544ac7f4db109a152a092fa88 inherit pub_methods_class_a_z_1_1_reflect_context"><td class="memItemLeft" align="right" valign="top"><a id="af5fda7a544ac7f4db109a152a092fa88"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_reflect_context.html#af5fda7a544ac7f4db109a152a092fa88">IsOnDemandTypeReflected</a> (<a class="el" href="struct_a_z_1_1_uuid.html">AZ::Uuid</a> typeId)</td></tr>
<tr class="memdesc:af5fda7a544ac7f4db109a152a092fa88 inherit pub_methods_class_a_z_1_1_reflect_context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an <a class="el" href="struct_a_z_1_1_on_demand_reflection.html">OnDemandReflection</a> type's typeid is already reflected. <br /></td></tr>
<tr class="separator:af5fda7a544ac7f4db109a152a092fa88 inherit pub_methods_class_a_z_1_1_reflect_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96830dcb64ecd0cacaf9e895b7b5ec43 inherit pub_methods_class_a_z_1_1_reflect_context"><td class="memItemLeft" align="right" valign="top"><a id="a96830dcb64ecd0cacaf9e895b7b5ec43"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_reflect_context.html#a96830dcb64ecd0cacaf9e895b7b5ec43">ExecuteQueuedOnDemandReflections</a> ()</td></tr>
<tr class="memdesc:a96830dcb64ecd0cacaf9e895b7b5ec43 inherit pub_methods_class_a_z_1_1_reflect_context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute all queued <a class="el" href="struct_a_z_1_1_on_demand_reflection.html">OnDemandReflection</a> calls. <br /></td></tr>
<tr class="separator:a96830dcb64ecd0cacaf9e895b7b5ec43 inherit pub_methods_class_a_z_1_1_reflect_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Code to bind classes and variables for serialization.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpefad122433dcafe566d9fbee21d3a8d5"></a><a class="anchor" id="SerializeBind"></a> For details about what can you expose in a class and what options you have <a class="el" href="class_a_z_1_1_serialize_context_1_1_class_builder.html">SerializeContext::ClassBuilder</a> </p>
</td></tr>
<tr class="memitem:a25e885376614e704e675a0f370c75c53"><td class="memItemLeft" align="right" valign="top"><a id="a25e885376614e704e675a0f370c75c53"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#a25e885376614e704e675a0f370c75c53">CreateAnyFunc</a> = <a class="el" href="class_a_z_std_1_1any.html">AZStd::any</a>(*)(<a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> *)</td></tr>
<tr class="memdesc:a25e885376614e704e675a0f370c75c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Pointer which is used to construct an <a class="el" href="class_a_z_std_1_1any.html">AZStd::any</a> for a registered type using the Serialize Context. <br /></td></tr>
<tr class="separator:a25e885376614e704e675a0f370c75c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569522bfcf00e608411799356c6a123d"><td class="memTemplParams" colspan="2"><a id="a569522bfcf00e608411799356c6a123d"></a>
template&lt;class T , class... TBaseClasses&gt; </td></tr>
<tr class="memitem:a569522bfcf00e608411799356c6a123d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_serialize_context_1_1_class_builder.html">ClassBuilder</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Class</b> ()</td></tr>
<tr class="separator:a569522bfcf00e608411799356c6a123d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae049372bce42f23c0e28bd431eb9e573"><td class="memTemplParams" colspan="2">template&lt;class T , class... TBaseClasses&gt; </td></tr>
<tr class="memitem:ae049372bce42f23c0e28bd431eb9e573"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_serialize_context_1_1_class_builder.html">ClassBuilder</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#ae049372bce42f23c0e28bd431eb9e573">Class</a> (<a class="el" href="class_a_z_1_1_serialize_context_1_1_i_object_factory.html">IObjectFactory</a> *factory)</td></tr>
<tr class="separator:ae049372bce42f23c0e28bd431eb9e573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950a471283d5bda64f8e496c367b8930"><td class="memTemplParams" colspan="2">template&lt;typename EnumType &gt; </td></tr>
<tr class="memitem:a950a471283d5bda64f8e496c367b8930"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_serialize_context_1_1_enum_builder.html">EnumBuilder</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#a950a471283d5bda64f8e496c367b8930">Enum</a> ()</td></tr>
<tr class="separator:a950a471283d5bda64f8e496c367b8930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75eb622abc9e1f9e1984100cb94eea15"><td class="memTemplParams" colspan="2"><a id="a75eb622abc9e1f9e1984100cb94eea15"></a>
template&lt;typename EnumType &gt; </td></tr>
<tr class="memitem:a75eb622abc9e1f9e1984100cb94eea15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_serialize_context_1_1_enum_builder.html">EnumBuilder</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Enum</b> (<a class="el" href="class_a_z_1_1_serialize_context_1_1_i_object_factory.html">IObjectFactory</a> *factory)</td></tr>
<tr class="separator:a75eb622abc9e1f9e1984100cb94eea15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7dda5cd60689645dd12643a78fe97a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_serialize_context_1_1_class_builder.html">ClassBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#ad7dda5cd60689645dd12643a78fe97a5">RegisterType</a> (const <a class="el" href="namespace_a_z.html#a5c1a2bfc05f03fd482d2fb55fbe82051">AZ::TypeId</a> &amp;typeId, <a class="el" href="class_a_z_1_1_serialize_context_1_1_class_data.html">AZ::SerializeContext::ClassData</a> &amp;&amp;classData, <a class="el" href="class_a_z_1_1_serialize_context.html#a25e885376614e704e675a0f370c75c53">CreateAnyFunc</a> createAnyFunc=[](<a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> *) -&gt; <a class="el" href="class_a_z_std_1_1any.html">AZStd::any</a> { return {};})</td></tr>
<tr class="separator:ad7dda5cd60689645dd12643a78fe97a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ada1d7665a6fb240e3eb9065dd6e61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#a85ada1d7665a6fb240e3eb9065dd6e61">UnregisterType</a> (const <a class="el" href="namespace_a_z.html#a5c1a2bfc05f03fd482d2fb55fbe82051">AZ::TypeId</a> &amp;typeId)</td></tr>
<tr class="separator:a85ada1d7665a6fb240e3eb9065dd6e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6316b42932376b7ec5b3d93a4555afa1"><td class="memTemplParams" colspan="2"><a id="a6316b42932376b7ec5b3d93a4555afa1"></a>
template&lt;class ValueType &gt; </td></tr>
<tr class="memitem:a6316b42932376b7ec5b3d93a4555afa1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RegisterGenericType</b> ()</td></tr>
<tr class="separator:a6316b42932376b7ec5b3d93a4555afa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e7e8513c4a6a4c1e89db85f880b7e5"><td class="memItemLeft" align="right" valign="top"><a id="ad8e7e8513c4a6a4c1e89db85f880b7e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ClassDeprecate</b> (const char *name, const <a class="el" href="struct_a_z_1_1_uuid.html">AZ::Uuid</a> &amp;typeUuid, <a class="el" href="class_a_z_1_1_serialize_context.html#a83071151391be9479cb7767f815c3139">VersionConverter</a> converter=nullptr)</td></tr>
<tr class="separator:ad8e7e8513c4a6a4c1e89db85f880b7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Function to enumerate the hierarchy of an instance using the serialization info.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp85e984686ad00b1ba9ddb94ae5c7f1b2"></a><a class="anchor" id="Enumeration"></a></p>
</td></tr>
<tr class="memitem:a3b913269607004cc008902f4a4dc03d5"><td class="memItemLeft" align="right" valign="top"><a id="a3b913269607004cc008902f4a4dc03d5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>EnumerationAccessFlags</b> { <b>ENUM_ACCESS_FOR_READ</b> = 0, 
<b>ENUM_ACCESS_FOR_WRITE</b> = 1 &lt;&lt; 0, 
<b>ENUM_ACCESS_HOLD</b> = 1 &lt;&lt; 1
 }</td></tr>
<tr class="separator:a3b913269607004cc008902f4a4dc03d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6138c4bd2f93c60e6f79fd26ed2ab968"><td class="memItemLeft" align="right" valign="top"><a id="a6138c4bd2f93c60e6f79fd26ed2ab968"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>DataPatchUpgradeType</b> { <b>TYPE_UPGRADE</b>, 
<b>NAME_UPGRADE</b>
 }</td></tr>
<tr class="separator:a6138c4bd2f93c60e6f79fd26ed2ab968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57fc155327e98f33433eadd4ca90d21"><td class="memItemLeft" align="right" valign="top"><a id="af57fc155327e98f33433eadd4ca90d21"></a>
typedef <a class="el" href="class_a_z_std_1_1function.html">AZStd::function</a>&lt; bool(void *, const <a class="el" href="class_a_z_1_1_serialize_context_1_1_class_data.html">ClassData</a> *, const <a class="el" href="struct_a_z_1_1_serialize_context_1_1_class_element.html">ClassElement</a> *) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#af57fc155327e98f33433eadd4ca90d21">BeginElemEnumCB</a></td></tr>
<tr class="memdesc:af57fc155327e98f33433eadd4ca90d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">EnumerateInstance() calls this callback for each node in the instance hierarchy. Return true to also enumerate the node's children, otherwise false. <br /></td></tr>
<tr class="separator:af57fc155327e98f33433eadd4ca90d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a800553516a2550d69819c74523274"><td class="memItemLeft" align="right" valign="top"><a id="a68a800553516a2550d69819c74523274"></a>
typedef <a class="el" href="class_a_z_std_1_1function.html">AZStd::function</a>&lt; bool() &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#a68a800553516a2550d69819c74523274">EndElemEnumCB</a></td></tr>
<tr class="memdesc:a68a800553516a2550d69819c74523274"><td class="mdescLeft">&#160;</td><td class="mdescRight">EnumerateInstance() calls this callback when enumeration of an element's sub-branch has completed. Return true to continue enumeration of the element's siblings, otherwise false. <br /></td></tr>
<tr class="separator:a68a800553516a2550d69819c74523274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7de1696d241d98d62f9d7d21c0f9826"><td class="memItemLeft" align="right" valign="top"><a id="ac7de1696d241d98d62f9d7d21c0f9826"></a>
typedef <a class="el" href="class_a_z_std_1_1function.html">AZStd::function</a>&lt; bool(const <a class="el" href="class_a_z_1_1_serialize_context_1_1_class_data.html">ClassData</a> *, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#ac7de1696d241d98d62f9d7d21c0f9826">TypeInfoCB</a></td></tr>
<tr class="memdesc:ac7de1696d241d98d62f9d7d21c0f9826"><td class="mdescLeft">&#160;</td><td class="mdescRight">TypeInfo enumeration callback. Return true to continue enumeration, otherwise false. <br /></td></tr>
<tr class="separator:ac7de1696d241d98d62f9d7d21c0f9826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af665ace55bb473557f7c8a1e429e4c66"><td class="memItemLeft" align="right" valign="top"><a id="af665ace55bb473557f7c8a1e429e4c66"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DataPatchUpgradeList</b> = <a class="el" href="class_a_z_std_1_1set.html">AZStd::set</a>&lt; <a class="el" href="class_a_z_1_1_serialize_context_1_1_data_patch_upgrade.html">DataPatchUpgrade</a> *, <a class="el" href="struct_a_z_1_1_serialize_context_1_1_node_upgrade_sort_functor.html">NodeUpgradeSortFunctor</a> &gt;</td></tr>
<tr class="separator:af665ace55bb473557f7c8a1e429e4c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0b703b6423c41c0ef379ca74626259"><td class="memItemLeft" align="right" valign="top"><a id="acd0b703b6423c41c0ef379ca74626259"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DataPatchUpgradeMap</b> = <a class="el" href="class_a_z_std_1_1map.html">AZStd::map</a>&lt; unsigned int, <a class="el" href="class_a_z_std_1_1set.html">DataPatchUpgradeList</a> &gt;</td></tr>
<tr class="separator:acd0b703b6423c41c0ef379ca74626259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40822265811dd52f08635292fbcaa1fb"><td class="memItemLeft" align="right" valign="top"><a id="a40822265811dd52f08635292fbcaa1fb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DataPatchFieldUpgrades</b> = <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map</a>&lt; <a class="el" href="class_a_z_1_1_crc32.html">AZ::Crc32</a>, <a class="el" href="class_a_z_std_1_1map.html">DataPatchUpgradeMap</a> &gt;</td></tr>
<tr class="separator:a40822265811dd52f08635292fbcaa1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c4867ad3af17029ab6655a27a31fdf"><td class="memItemLeft" align="right" valign="top"><a id="a98c4867ad3af17029ab6655a27a31fdf"></a>
typedef <a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="struct_a_z_1_1_serialize_context_1_1_class_element.html">ClassElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ClassElementArray</b></td></tr>
<tr class="separator:a98c4867ad3af17029ab6655a27a31fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da14d3f93af57a3750e3f4c6a9ee667"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#a7da14d3f93af57a3750e3f4c6a9ee667">EnumerateInstanceConst</a> (<a class="el" href="struct_a_z_1_1_serialize_context_1_1_enumerate_instance_call_context.html">EnumerateInstanceCallContext</a> *callContext, const void *ptr, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;classId, const <a class="el" href="class_a_z_1_1_serialize_context_1_1_class_data.html">ClassData</a> *classData, const <a class="el" href="struct_a_z_1_1_serialize_context_1_1_class_element.html">ClassElement</a> *classElement) const</td></tr>
<tr class="separator:a7da14d3f93af57a3750e3f4c6a9ee667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5404331ca23a05aa2761d5c875e3cc"><td class="memItemLeft" align="right" valign="top"><a id="aef5404331ca23a05aa2761d5c875e3cc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>EnumerateInstance</b> (<a class="el" href="struct_a_z_1_1_serialize_context_1_1_enumerate_instance_call_context.html">EnumerateInstanceCallContext</a> *callContext, void *ptr, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;classId, const <a class="el" href="class_a_z_1_1_serialize_context_1_1_class_data.html">ClassData</a> *classData, const <a class="el" href="struct_a_z_1_1_serialize_context_1_1_class_element.html">ClassElement</a> *classElement) const</td></tr>
<tr class="separator:aef5404331ca23a05aa2761d5c875e3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f41b3fcef899b83e5e384740f155999"><td class="memItemLeft" align="right" valign="top"><a id="a0f41b3fcef899b83e5e384740f155999"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>EnumerateInstanceConst</b> (const void *ptr, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;classId, const <a class="el" href="class_a_z_1_1_serialize_context.html#af57fc155327e98f33433eadd4ca90d21">BeginElemEnumCB</a> &amp;beginElemCB, const <a class="el" href="class_a_z_1_1_serialize_context.html#a68a800553516a2550d69819c74523274">EndElemEnumCB</a> &amp;endElemCB, unsigned int accessFlags, const <a class="el" href="class_a_z_1_1_serialize_context_1_1_class_data.html">ClassData</a> *classData, const <a class="el" href="struct_a_z_1_1_serialize_context_1_1_class_element.html">ClassElement</a> *classElement, <a class="el" href="class_a_z_1_1_serialize_context_1_1_error_handler.html">ErrorHandler</a> *errorHandler=nullptr) const</td></tr>
<tr class="separator:a0f41b3fcef899b83e5e384740f155999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1333c4c75be44fbe366b0a844cf220cd"><td class="memItemLeft" align="right" valign="top"><a id="a1333c4c75be44fbe366b0a844cf220cd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>EnumerateInstance</b> (void *ptr, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;classId, const <a class="el" href="class_a_z_1_1_serialize_context.html#af57fc155327e98f33433eadd4ca90d21">BeginElemEnumCB</a> &amp;beginElemCB, const <a class="el" href="class_a_z_1_1_serialize_context.html#a68a800553516a2550d69819c74523274">EndElemEnumCB</a> &amp;endElemCB, unsigned int accessFlags, const <a class="el" href="class_a_z_1_1_serialize_context_1_1_class_data.html">ClassData</a> *classData, const <a class="el" href="struct_a_z_1_1_serialize_context_1_1_class_element.html">ClassElement</a> *classElement, <a class="el" href="class_a_z_1_1_serialize_context_1_1_error_handler.html">ErrorHandler</a> *errorHandler=nullptr) const</td></tr>
<tr class="separator:a1333c4c75be44fbe366b0a844cf220cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae213af539141e5d10fbbba8d84c5c668"><td class="memTemplParams" colspan="2"><a id="ae213af539141e5d10fbbba8d84c5c668"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae213af539141e5d10fbbba8d84c5c668"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#ae213af539141e5d10fbbba8d84c5c668">EnumerateObject</a> (T *obj, const <a class="el" href="class_a_z_1_1_serialize_context.html#af57fc155327e98f33433eadd4ca90d21">BeginElemEnumCB</a> &amp;beginElemCB, const <a class="el" href="class_a_z_1_1_serialize_context.html#a68a800553516a2550d69819c74523274">EndElemEnumCB</a> &amp;endElemCB, unsigned int accessFlags, <a class="el" href="class_a_z_1_1_serialize_context_1_1_error_handler.html">ErrorHandler</a> *errorHandler=nullptr) const</td></tr>
<tr class="memdesc:ae213af539141e5d10fbbba8d84c5c668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses a give object EnumerateInstance assuming that object is a root element (not classData/classElement information). <br /></td></tr>
<tr class="separator:ae213af539141e5d10fbbba8d84c5c668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed042e7b540b0c9f1a0738f1f5ae5e2"><td class="memTemplParams" colspan="2"><a id="a6ed042e7b540b0c9f1a0738f1f5ae5e2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6ed042e7b540b0c9f1a0738f1f5ae5e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EnumerateObject</b> (const T *obj, const <a class="el" href="class_a_z_1_1_serialize_context.html#af57fc155327e98f33433eadd4ca90d21">BeginElemEnumCB</a> &amp;beginElemCB, const <a class="el" href="class_a_z_1_1_serialize_context.html#a68a800553516a2550d69819c74523274">EndElemEnumCB</a> &amp;endElemCB, unsigned int accessFlags, <a class="el" href="class_a_z_1_1_serialize_context_1_1_error_handler.html">ErrorHandler</a> *errorHandler=nullptr) const</td></tr>
<tr class="separator:a6ed042e7b540b0c9f1a0738f1f5ae5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1e5f9c996ca1b2b773e7a53354b82b"><td class="memItemLeft" align="right" valign="top"><a id="a2e1e5f9c996ca1b2b773e7a53354b82b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#a2e1e5f9c996ca1b2b773e7a53354b82b">EnumerateDerived</a> (const <a class="el" href="class_a_z_1_1_serialize_context.html#ac7de1696d241d98d62f9d7d21c0f9826">TypeInfoCB</a> &amp;callback, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;classId=Uuid::CreateNull(), const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;typeId=Uuid::CreateNull()) const</td></tr>
<tr class="memdesc:a2e1e5f9c996ca1b2b773e7a53354b82b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all derived classes of classId type in addition we use the typeId to check any rtti possible match. <br /></td></tr>
<tr class="separator:a2e1e5f9c996ca1b2b773e7a53354b82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fe9df1f344859756d0ca5a03236bf5"><td class="memItemLeft" align="right" valign="top"><a id="af1fe9df1f344859756d0ca5a03236bf5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#af1fe9df1f344859756d0ca5a03236bf5">EnumerateBase</a> (const <a class="el" href="class_a_z_1_1_serialize_context.html#ac7de1696d241d98d62f9d7d21c0f9826">TypeInfoCB</a> &amp;callback, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;classId)</td></tr>
<tr class="memdesc:af1fe9df1f344859756d0ca5a03236bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all base classes of classId type. <br /></td></tr>
<tr class="separator:af1fe9df1f344859756d0ca5a03236bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08f4913b8a820b015f7228af2e460c4"><td class="memTemplParams" colspan="2"><a id="ab08f4913b8a820b015f7228af2e460c4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab08f4913b8a820b015f7228af2e460c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EnumerateDerived</b> (const <a class="el" href="class_a_z_1_1_serialize_context.html#ac7de1696d241d98d62f9d7d21c0f9826">TypeInfoCB</a> &amp;callback)</td></tr>
<tr class="separator:ab08f4913b8a820b015f7228af2e460c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab970f27b412db6be45fd9fb41ca1143f"><td class="memTemplParams" colspan="2"><a id="ab970f27b412db6be45fd9fb41ca1143f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab970f27b412db6be45fd9fb41ca1143f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EnumerateBase</b> (const <a class="el" href="class_a_z_1_1_serialize_context.html#ac7de1696d241d98d62f9d7d21c0f9826">TypeInfoCB</a> &amp;callback)</td></tr>
<tr class="separator:ab970f27b412db6be45fd9fb41ca1143f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21557c88fb30efafd76b06e0708819e3"><td class="memItemLeft" align="right" valign="top"><a id="a21557c88fb30efafd76b06e0708819e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EnumerateAll</b> (const <a class="el" href="class_a_z_1_1_serialize_context.html#ac7de1696d241d98d62f9d7d21c0f9826">TypeInfoCB</a> &amp;callback, bool includeGenerics=false) const</td></tr>
<tr class="separator:a21557c88fb30efafd76b06e0708819e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ca8d2de7f59cc6edcc0cc1098ce814"><td class="memTemplParams" colspan="2"><a id="af4ca8d2de7f59cc6edcc0cc1098ce814"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af4ca8d2de7f59cc6edcc0cc1098ce814"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#af4ca8d2de7f59cc6edcc0cc1098ce814">CloneObject</a> (const T *obj)</td></tr>
<tr class="memdesc:af4ca8d2de7f59cc6edcc0cc1098ce814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a copy of obj. The behavior is the same as if obj was first serialized out and the copy was then created from the serialized data. <br /></td></tr>
<tr class="separator:af4ca8d2de7f59cc6edcc0cc1098ce814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbd2b3a9f38fbad12c511c12d9294d5"><td class="memItemLeft" align="right" valign="top"><a id="affbd2b3a9f38fbad12c511c12d9294d5"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>CloneObject</b> (const void *ptr, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;classId)</td></tr>
<tr class="separator:affbd2b3a9f38fbad12c511c12d9294d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3849c2c855351e3d5c66fc793063b542"><td class="memTemplParams" colspan="2"><a id="a3849c2c855351e3d5c66fc793063b542"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3849c2c855351e3d5c66fc793063b542"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CloneObjectInplace</b> (T &amp;dest, const T *obj)</td></tr>
<tr class="separator:a3849c2c855351e3d5c66fc793063b542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9b9bbb54d21245fda172e1c8bd4ca9"><td class="memItemLeft" align="right" valign="top"><a id="a1d9b9bbb54d21245fda172e1c8bd4ca9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CloneObjectInplace</b> (void *dest, const void *ptr, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;classId)</td></tr>
<tr class="separator:a1d9b9bbb54d21245fda172e1c8bd4ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Version Control</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp0b259705b755c4cbd672e6663ae31905"></a><a class="anchor" id="VersionControl"></a></p>
</td></tr>
<tr class="memitem:abc9d3ba80709e2a4eb5c19f06f7d2c31"><td class="memItemLeft" align="right" valign="top"><a id="abc9d3ba80709e2a4eb5c19f06f7d2c31"></a>
const <a class="el" href="class_a_z_1_1_serialize_context_1_1_class_data.html">ClassData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#abc9d3ba80709e2a4eb5c19f06f7d2c31">FindClassData</a> (const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;classId, const <a class="el" href="class_a_z_1_1_serialize_context_1_1_class_data.html">SerializeContext::ClassData</a> *parent=nullptr, u32 elementNameCrc=0) const</td></tr>
<tr class="memdesc:abc9d3ba80709e2a4eb5c19f06f7d2c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a class data (stored information) based on a class ID and possible parent class data. <br /></td></tr>
<tr class="separator:abc9d3ba80709e2a4eb5c19f06f7d2c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94935af171a45a922233cc0e94f64792"><td class="memItemLeft" align="right" valign="top"><a id="a94935af171a45a922233cc0e94f64792"></a>
<a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="struct_a_z_1_1_uuid.html">AZ::Uuid</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#a94935af171a45a922233cc0e94f64792">FindClassId</a> (const <a class="el" href="class_a_z_1_1_crc32.html">AZ::Crc32</a> &amp;classNameCrc) const</td></tr>
<tr class="memdesc:a94935af171a45a922233cc0e94f64792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a class data (stored information) based on a class name. <br /></td></tr>
<tr class="separator:a94935af171a45a922233cc0e94f64792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680ac72e2ee2f5a9b5f57075d93e0ed1"><td class="memItemLeft" align="right" valign="top"><a id="a680ac72e2ee2f5a9b5f57075d93e0ed1"></a>
<a class="el" href="class_a_z_1_1_generic_class_info.html">GenericClassInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#a680ac72e2ee2f5a9b5f57075d93e0ed1">FindGenericClassInfo</a> (const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;classId) const</td></tr>
<tr class="memdesc:a680ac72e2ee2f5a9b5f57075d93e0ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find GenericClassData data based on the supplied class ID. <br /></td></tr>
<tr class="separator:a680ac72e2ee2f5a9b5f57075d93e0ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c509f97af0dfa256bb6e789f581057"><td class="memItemLeft" align="right" valign="top"><a id="ac2c509f97af0dfa256bb6e789f581057"></a>
<a class="el" href="class_a_z_std_1_1any.html">AZStd::any</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#ac2c509f97af0dfa256bb6e789f581057">CreateAny</a> (const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;classId)</td></tr>
<tr class="memdesc:ac2c509f97af0dfa256bb6e789f581057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="class_a_z_std_1_1any.html">AZStd::any</a> based on the provided class <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a>, or returns an empty <a class="el" href="class_a_z_std_1_1any.html">AZStd::any</a> if no class data is found or the class is virtual. <br /></td></tr>
<tr class="separator:ac2c509f97af0dfa256bb6e789f581057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87c6b5421e817cff300b3942e0303b9"><td class="memItemLeft" align="right" valign="top"><a id="ab87c6b5421e817cff300b3942e0303b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#ab87c6b5421e817cff300b3942e0303b9">RegisterGenericClassInfo</a> (const <a class="el" href="struct_a_z_1_1_uuid.html">AZ::Uuid</a> &amp;typeId, <a class="el" href="class_a_z_1_1_generic_class_info.html">GenericClassInfo</a> *genericClassInfo, const <a class="el" href="class_a_z_1_1_serialize_context.html#a25e885376614e704e675a0f370c75c53">CreateAnyFunc</a> &amp;createAnyFunc)</td></tr>
<tr class="memdesc:ab87c6b5421e817cff300b3942e0303b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register <a class="el" href="class_a_z_1_1_generic_class_info.html">GenericClassInfo</a> with the <a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a>. <br /></td></tr>
<tr class="separator:ab87c6b5421e817cff300b3942e0303b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca3c04d0a777cdd2d4b896e05b5f973"><td class="memItemLeft" align="right" valign="top"><a id="adca3c04d0a777cdd2d4b896e05b5f973"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#adca3c04d0a777cdd2d4b896e05b5f973">CleanupModuleGenericClassInfo</a> ()</td></tr>
<tr class="memdesc:adca3c04d0a777cdd2d4b896e05b5f973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters all <a class="el" href="class_a_z_1_1_generic_class_info.html">GenericClassInfo</a> instances registered in the current module and deletes the <a class="el" href="class_a_z_1_1_generic_class_info.html">GenericClassInfo</a> instances. <br /></td></tr>
<tr class="separator:adca3c04d0a777cdd2d4b896e05b5f973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa974aa8525dc0a9db20c1d8a48402dad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#aa974aa8525dc0a9db20c1d8a48402dad">CanDowncast</a> (const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;fromClassId, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;toClassId, const <a class="el" href="class_a_z_1_1_i_rtti_helper.html">IRttiHelper</a> *fromClassHelper=nullptr, const <a class="el" href="class_a_z_1_1_i_rtti_helper.html">IRttiHelper</a> *toClassHelper=nullptr) const</td></tr>
<tr class="separator:aa974aa8525dc0a9db20c1d8a48402dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14a2e10ff97c408b34b2f801049bc32"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#ac14a2e10ff97c408b34b2f801049bc32">DownCast</a> (void *instance, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;fromClassId, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;toClassId, const <a class="el" href="class_a_z_1_1_i_rtti_helper.html">IRttiHelper</a> *fromClassHelper=nullptr, const <a class="el" href="class_a_z_1_1_i_rtti_helper.html">IRttiHelper</a> *toClassHelper=nullptr) const</td></tr>
<tr class="separator:ac14a2e10ff97c408b34b2f801049bc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e7fcc55e0af44f3d2ee7b93aa59be6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab4e7fcc55e0af44f3d2ee7b93aa59be6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_serialize_context.html#ab4e7fcc55e0af44f3d2ee7b93aa59be6">Cast</a> (void *instance, const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;instanceClassId) const</td></tr>
<tr class="separator:ab4e7fcc55e0af44f3d2ee7b93aa59be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc0037fc10edefe642edfc3ed59fd8b"><td class="memItemLeft" align="right" valign="top"><a id="a8fc0037fc10edefe642edfc3ed59fd8b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterDataContainer</b> (<a class="el" href="namespace_a_z_std.html#aeb4832383c83113340791a3ab3fe87f0">AZStd::unique_ptr</a>&lt; <a class="el" href="class_a_z_1_1_serialize_context_1_1_i_data_container.html">IDataContainer</a> &gt; dataContainer)</td></tr>
<tr class="separator:a8fc0037fc10edefe642edfc3ed59fd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038ccd391d94c7f582e268495b9d32a9"><td class="memItemLeft" align="right" valign="top"><a id="a038ccd391d94c7f582e268495b9d32a9"></a>
const <a class="el" href="namespace_a_z.html#a5c1a2bfc05f03fd482d2fb55fbe82051">TypeId</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetUnderlyingTypeId</b> (const <a class="el" href="namespace_a_z.html#a5c1a2bfc05f03fd482d2fb55fbe82051">TypeId</a> &amp;enumTypeId) const</td></tr>
<tr class="separator:a038ccd391d94c7f582e268495b9d32a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcca8e22bbfb0c4140e7f9ce2012ebe5"><td class="memItemLeft" align="right" valign="top"><a id="adcca8e22bbfb0c4140e7f9ce2012ebe5"></a>
<a class="el" href="class_a_z_1_1_serialize_context_1_1_per_module_generic_class_info.html">PerModuleGenericClassInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetCurrentSerializeContextModule</b> ()</td></tr>
<tr class="separator:adcca8e22bbfb0c4140e7f9ce2012ebe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_class_a_z_1_1_reflect_context"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_a_z_1_1_reflect_context')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_a_z_1_1_reflect_context.html">AZ::ReflectContext</a></td></tr>
<tr class="memitem:a0491c1dfd7b522a48850c12699345171 inherit pro_attribs_class_a_z_1_1_reflect_context"><td class="memItemLeft" align="right" valign="top"><a id="a0491c1dfd7b522a48850c12699345171"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_reflect_context.html#a0491c1dfd7b522a48850c12699345171">m_isRemoveReflection</a></td></tr>
<tr class="memdesc:a0491c1dfd7b522a48850c12699345171 inherit pro_attribs_class_a_z_1_1_reflect_context"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if all calls in the context should be considered to remove not to add reflection. <br /></td></tr>
<tr class="separator:a0491c1dfd7b522a48850c12699345171 inherit pro_attribs_class_a_z_1_1_reflect_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16791f48dd6ea3320b477b6c3f6bd663 inherit pro_attribs_class_a_z_1_1_reflect_context"><td class="memItemLeft" align="right" valign="top"><a id="a16791f48dd6ea3320b477b6c3f6bd663"></a>
<a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map</a>&lt; <a class="el" href="struct_a_z_1_1_uuid.html">AZ::Uuid</a>, <a class="el" href="class_a_z_std_1_1weak__ptr.html">AZStd::weak_ptr</a>&lt; Internal::ReflectionFunctionRef &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_reflect_context.html#a16791f48dd6ea3320b477b6c3f6bd663">m_onDemandReflection</a></td></tr>
<tr class="memdesc:a16791f48dd6ea3320b477b6c3f6bd663 inherit pro_attribs_class_a_z_1_1_reflect_context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the on demand reflect functions so we can avoid double-reflecting something. <br /></td></tr>
<tr class="separator:a16791f48dd6ea3320b477b6c3f6bd663 inherit pro_attribs_class_a_z_1_1_reflect_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cf243a447b9ceaa95ecb70a36744f3 inherit pro_attribs_class_a_z_1_1_reflect_context"><td class="memItemLeft" align="right" valign="top"><a id="ad6cf243a447b9ceaa95ecb70a36744f3"></a>
<a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="struct_a_z_1_1_uuid.html">AZ::Uuid</a>, <a class="el" href="namespace_a_z.html#a6332cfe277dbb34b8392a0f0015a0947">StaticReflectionFunctionPtr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_reflect_context.html#ad6cf243a447b9ceaa95ecb70a36744f3">m_toProcessOnDemandReflection</a></td></tr>
<tr class="memdesc:ad6cf243a447b9ceaa95ecb70a36744f3 inherit pro_attribs_class_a_z_1_1_reflect_context"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_a_z_1_1_on_demand_reflection.html">OnDemandReflection</a> functions that need to be called. <br /></td></tr>
<tr class="separator:ad6cf243a447b9ceaa95ecb70a36744f3 inherit pro_attribs_class_a_z_1_1_reflect_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b720c1a62aaf44b2f05f5c733abf638 inherit pro_attribs_class_a_z_1_1_reflect_context"><td class="memItemLeft" align="right" valign="top"><a id="a3b720c1a62aaf44b2f05f5c733abf638"></a>
<a class="el" href="class_a_z_std_1_1deque.html">AZStd::deque</a>&lt; <a class="el" href="struct_a_z_1_1_uuid.html">AZ::Uuid</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_reflect_context.html#a3b720c1a62aaf44b2f05f5c733abf638">m_currentlyProcessingTypeIds</a></td></tr>
<tr class="memdesc:a3b720c1a62aaf44b2f05f5c733abf638 inherit pro_attribs_class_a_z_1_1_reflect_context"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type ids of the currently reflecting type. Used to prevent circular references. Is a set to prevent recursive circular references. <br /></td></tr>
<tr class="separator:a3b720c1a62aaf44b2f05f5c733abf638 inherit pro_attribs_class_a_z_1_1_reflect_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c09841f41001a3cb7f0451e19b0629d inherit pro_attribs_class_a_z_1_1_reflect_context"><td class="memItemLeft" align="right" valign="top"><a id="a2c09841f41001a3cb7f0451e19b0629d"></a>
friend&#160;</td><td class="memItemRight" valign="bottom"><b>OnDemandReflectionOwner</b></td></tr>
<tr class="separator:a2c09841f41001a3cb7f0451e19b0629d inherit pro_attribs_class_a_z_1_1_reflect_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Serialize context is a class that manages information about all reflected data structures. You will use it for all related information when you declare you data for serialization. In addition it will handle data version control. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a744fde9cdda7fab9939793a55efe4416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744fde9cdda7fab9939793a55efe4416">&#9670;&nbsp;</a></span>ClassPersistentId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef u64(* AZ::SerializeContext::ClassPersistentId) (const void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for persistent ID for an instance. </p>
<dl class="section note"><dt>Note</dt><dd>: We should probably switch this to UUID </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa974aa8525dc0a9db20c1d8a48402dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa974aa8525dc0a9db20c1d8a48402dad">&#9670;&nbsp;</a></span>CanDowncast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SerializeContext::CanDowncast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>fromClassId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>toClassId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_i_rtti_helper.html">IRttiHelper</a> *&#160;</td>
          <td class="paramname"><em>fromClassHelper</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_i_rtti_helper.html">IRttiHelper</a> *&#160;</td>
          <td class="paramname"><em>toClassHelper</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a type can be downcast to another using <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> and AZ_RTTI. All classes must be registered with the system. </p>

</div>
</div>
<a id="ab4e7fcc55e0af44f3d2ee7b93aa59be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e7fcc55e0af44f3d2ee7b93aa59be6">&#9670;&nbsp;</a></span>Cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T AZ::SerializeContext::Cast </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>instanceClassId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Casts a pointer using the instance pointer and its class id. In order for the cast to succeed, both types must either support azrtti or be reflected with the serialization context. </p>

</div>
</div>
<a id="ae049372bce42f23c0e28bd431eb9e573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae049372bce42f23c0e28bd431eb9e573">&#9670;&nbsp;</a></span>Class()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... TBaseClasses&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_1_1_serialize_context_1_1_class_builder.html">SerializeContext::ClassBuilder</a> AZ::SerializeContext::Class </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_serialize_context_1_1_i_object_factory.html">IObjectFactory</a> *&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When a default object factory can't be used, example a singleton class with private constructors or non default constructors you will have to provide a custom factory. </p>

</div>
</div>
<a id="ac14a2e10ff97c408b34b2f801049bc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14a2e10ff97c408b34b2f801049bc32">&#9670;&nbsp;</a></span>DownCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* AZ::SerializeContext::DownCast </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>fromClassId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>toClassId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_i_rtti_helper.html">IRttiHelper</a> *&#160;</td>
          <td class="paramname"><em>fromClassHelper</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_i_rtti_helper.html">IRttiHelper</a> *&#160;</td>
          <td class="paramname"><em>toClassHelper</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offsets a pointer from a derived class to a common base class All classes must be registered with the system otherwise a NULL will be returned. </p>

</div>
</div>
<a id="a950a471283d5bda64f8e496c367b8930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950a471283d5bda64f8e496c367b8930">&#9670;&nbsp;</a></span>Enum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EnumType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_1_1_serialize_context_1_1_enum_builder.html">SerializeContext::EnumBuilder</a> AZ::SerializeContext::Enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exposes a C++ enum type to the <a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> The <a class="el" href="class_a_z_1_1_serialize_context_1_1_class_builder.html">SerializeContext::ClassBuilder</a> has the list of supported options for exposing Enum Type data The primary function on the <a class="el" href="class_a_z_1_1_serialize_context_1_1_enum_builder.html">EnumBuilder</a> class for adding an Enum value is <a class="el" href="class_a_z_1_1_serialize_context_1_1_enum_builder.html#a631fa1e3449dcf38d869dbec6685e2a3">EnumBuilder::Value()</a> </p>

</div>
</div>
<a id="a7da14d3f93af57a3750e3f4c6a9ee667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da14d3f93af57a3750e3f4c6a9ee667">&#9670;&nbsp;</a></span>EnumerateInstanceConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SerializeContext::EnumerateInstanceConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_serialize_context_1_1_enumerate_instance_call_context.html">EnumerateInstanceCallContext</a> *&#160;</td>
          <td class="paramname"><em>callContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_uuid.html">Uuid</a> &amp;&#160;</td>
          <td class="paramname"><em>classId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_serialize_context_1_1_class_data.html">ClassData</a> *&#160;</td>
          <td class="paramname"><em>classData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_a_z_1_1_serialize_context_1_1_class_element.html">ClassElement</a> *&#160;</td>
          <td class="paramname"><em>classElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call this function to traverse an instance's hierarchy by providing address and classId, if you have the typed pointer you can just call <a class="el" href="class_a_z_1_1_serialize_context.html#ae213af539141e5d10fbbba8d84c5c668">EnumerateObject</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to the object for traversal </td></tr>
    <tr><td class="paramname">classId</td><td>classId of object for traversal </td></tr>
    <tr><td class="paramname">beginElemCB</td><td>callback when we begin/open a child element </td></tr>
    <tr><td class="paramname">endElemCB</td><td>callback when we end/close a child element </td></tr>
    <tr><td class="paramname">accessFlags</td><td>EnumerationAccessFlags </td></tr>
    <tr><td class="paramname">classData</td><td>pointer to the class data for the traversed object to avoid calling FindClassData(classId) (can be null) </td></tr>
    <tr><td class="paramname">classElement</td><td>pointer to class element (null for root elements) </td></tr>
    <tr><td class="paramname">errorHandler</td><td>optional pointer to the error handler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7dda5cd60689645dd12643a78fe97a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7dda5cd60689645dd12643a78fe97a5">&#9670;&nbsp;</a></span>RegisterType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_1_1_serialize_context_1_1_class_builder.html">ClassBuilder</a> AZ::SerializeContext::RegisterType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_a_z.html#a5c1a2bfc05f03fd482d2fb55fbe82051">AZ::TypeId</a> &amp;&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_serialize_context_1_1_class_data.html">AZ::SerializeContext::ClassData</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>classData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_serialize_context.html#a25e885376614e704e675a0f370c75c53">CreateAnyFunc</a>&#160;</td>
          <td class="paramname"><em>createAnyFunc</em> = <code>[](<a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a>&#160;*)&#160;-&gt;&#160;<a class="el" href="class_a_z_std_1_1any.html">AZStd::any</a>&#160;{&#160;return&#160;{};}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows registration of a TypeId without the need to supply a C++ type If the type is not already registered, then the <a class="el" href="class_a_z_1_1_serialize_context_1_1_class_data.html">ClassData</a> is moved into the <a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> internal structure </p>

</div>
</div>
<a id="a85ada1d7665a6fb240e3eb9065dd6e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ada1d7665a6fb240e3eb9065dd6e61">&#9670;&nbsp;</a></span>UnregisterType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::SerializeContext::UnregisterType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_a_z.html#a5c1a2bfc05f03fd482d2fb55fbe82051">AZ::TypeId</a> &amp;&#160;</td>
          <td class="paramname"><em>typeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a type from the <a class="el" href="class_a_z_1_1_serialize_context.html">SerializeContext</a> and removes all internal mappings </p><dl class="section return"><dt>Returns</dt><dd>true if the type was previously registered </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Code/Framework/AzCore/AzCore/Serialization/SerializeContext.h</li>
<li>Code/Framework/AzCore/AzCore/Serialization/SerializeContextEnum.inl</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 5 2022 14:03:29 for Open 3D Engine AzCore API Reference by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
