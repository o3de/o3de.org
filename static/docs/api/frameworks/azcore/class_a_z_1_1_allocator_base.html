<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine AzCore API Reference: AZ::AllocatorBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="/images/api-reference/api-ref-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine AzCore API Reference
   &#160;<span id="projectnumber">22.10.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><a class="el" href="class_a_z_1_1_allocator_base.html">AllocatorBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_a_z_1_1_allocator_base-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AZ::AllocatorBase Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;AllocatorBase.h&gt;</code></p>

<p>Inherits <a class="el" href="class_a_z_1_1_i_allocator.html">AZ::IAllocator</a>.</p>

<p>Inherited by <a class="el" href="class_a_z_1_1_best_fit_external_map_allocator.html">AZ::BestFitExternalMapAllocator</a>, <a class="el" href="class_a_z_1_1_o_s_allocator.html">AZ::OSAllocator</a>, <a class="el" href="class_a_z_1_1_simple_schema_allocator.html">AZ::SimpleSchemaAllocator&lt; Schema, DescriptorType, ProfileAllocations, ReportOutOfMemory &gt;</a>, <a class="el" href="class_a_z_1_1_system_allocator.html">AZ::SystemAllocator</a>, <a class="el" href="class_a_z_1_1_simple_schema_allocator.html">AZ::SimpleSchemaAllocator&lt; AZ::HphaSchema, AZ::HphaSchema::Descriptor, false, false &gt;</a>, <a class="el" href="class_a_z_1_1_simple_schema_allocator.html">AZ::SimpleSchemaAllocator&lt; AZ::OverrunDetectionSchema &gt;</a>, <a class="el" href="class_a_z_1_1_simple_schema_allocator.html">AZ::SimpleSchemaAllocator&lt; PoolSchema, PoolSchema ::Descriptor, true, false &gt;</a>, and <a class="el" href="class_a_z_1_1_simple_schema_allocator.html">AZ::SimpleSchemaAllocator&lt; Schema, Schema::Descriptor, true, false &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4df1fa8684e8d251f813019af6061d72"><td class="memItemLeft" align="right" valign="top"><a id="a4df1fa8684e8d251f813019af6061d72"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>GetName</b> () const override</td></tr>
<tr class="separator:a4df1fa8684e8d251f813019af6061d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f81b666bc40af8c0bf5ba433053598"><td class="memItemLeft" align="right" valign="top"><a id="a61f81b666bc40af8c0bf5ba433053598"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>GetDescription</b> () const override</td></tr>
<tr class="separator:a61f81b666bc40af8c0bf5ba433053598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a05165309c18fcd9e00861b89d4299"><td class="memItemLeft" align="right" valign="top"><a id="ae4a05165309c18fcd9e00861b89d4299"></a>
<a class="el" href="class_a_z_1_1_debug_1_1_allocation_records.html">Debug::AllocationRecords</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#ae4a05165309c18fcd9e00861b89d4299">GetRecords</a> () final</td></tr>
<tr class="memdesc:ae4a05165309c18fcd9e00861b89d4299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the allocation records. They might be available or not depending on the build type. <a class="el" href="class_a_z_1_1_debug_1_1_allocation_records.html">Debug::AllocationRecords</a>. <br /></td></tr>
<tr class="separator:ae4a05165309c18fcd9e00861b89d4299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a030d903bb426f7a88bd2398b1eb191"><td class="memItemLeft" align="right" valign="top"><a id="a3a030d903bb426f7a88bd2398b1eb191"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a3a030d903bb426f7a88bd2398b1eb191">SetRecords</a> (<a class="el" href="class_a_z_1_1_debug_1_1_allocation_records.html">Debug::AllocationRecords</a> *records) final</td></tr>
<tr class="memdesc:a3a030d903bb426f7a88bd2398b1eb191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the allocation records. <br /></td></tr>
<tr class="separator:a3a030d903bb426f7a88bd2398b1eb191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b10cc083fcbbe17112c15604923dcb8"><td class="memItemLeft" align="right" valign="top"><a id="a3b10cc083fcbbe17112c15604923dcb8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a3b10cc083fcbbe17112c15604923dcb8">IsReady</a> () const final</td></tr>
<tr class="memdesc:a3b10cc083fcbbe17112c15604923dcb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this allocator is ready to use. <br /></td></tr>
<tr class="separator:a3b10cc083fcbbe17112c15604923dcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0a8e0d1826e5d68de7c48a54127c74"><td class="memItemLeft" align="right" valign="top"><a id="a4f0a8e0d1826e5d68de7c48a54127c74"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a4f0a8e0d1826e5d68de7c48a54127c74">PostCreate</a> () override</td></tr>
<tr class="memdesc:a4f0a8e0d1826e5d68de7c48a54127c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">All conforming allocators must call <a class="el" href="class_a_z_1_1_allocator_base.html#a4f0a8e0d1826e5d68de7c48a54127c74" title="All conforming allocators must call PostCreate() after their custom Create() method in order to be pr...">PostCreate()</a> after their custom Create() method in order to be properly registered. <br /></td></tr>
<tr class="separator:a4f0a8e0d1826e5d68de7c48a54127c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c706a1394df8e06a4ec118da0946fe"><td class="memItemLeft" align="right" valign="top"><a id="ab8c706a1394df8e06a4ec118da0946fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#ab8c706a1394df8e06a4ec118da0946fe">PreDestroy</a> () final</td></tr>
<tr class="memdesc:ab8c706a1394df8e06a4ec118da0946fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">All conforming allocators must call <a class="el" href="class_a_z_1_1_allocator_base.html#ab8c706a1394df8e06a4ec118da0946fe" title="All conforming allocators must call PreDestroy() before their custom Destroy() method in order to be ...">PreDestroy()</a> before their custom Destroy() method in order to be properly deregistered. <br /></td></tr>
<tr class="separator:ab8c706a1394df8e06a4ec118da0946fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2472cdf0a944b0657bfcbba28cfb64fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a2472cdf0a944b0657bfcbba28cfb64fa">SetLazilyCreated</a> (bool lazy) final</td></tr>
<tr class="separator:a2472cdf0a944b0657bfcbba28cfb64fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1888c05c8d2aa8ae3b305a81ca964121"><td class="memItemLeft" align="right" valign="top"><a id="a1888c05c8d2aa8ae3b305a81ca964121"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a1888c05c8d2aa8ae3b305a81ca964121">IsLazilyCreated</a> () const final</td></tr>
<tr class="memdesc:a1888c05c8d2aa8ae3b305a81ca964121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the allocator was lazily created. Exposed primarily for testing systems that need to verify the state of allocators. <br /></td></tr>
<tr class="separator:a1888c05c8d2aa8ae3b305a81ca964121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b5066e11564d2204e6cda0fe77a88d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#ad4b5066e11564d2204e6cda0fe77a88d">SetProfilingActive</a> (bool active) final</td></tr>
<tr class="separator:ad4b5066e11564d2204e6cda0fe77a88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c400ce989f21e09674ab4568f728097"><td class="memItemLeft" align="right" valign="top"><a id="a7c400ce989f21e09674ab4568f728097"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a7c400ce989f21e09674ab4568f728097">IsProfilingActive</a> () const final</td></tr>
<tr class="memdesc:a7c400ce989f21e09674ab4568f728097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if profiling calls will be made. <br /></td></tr>
<tr class="separator:a7c400ce989f21e09674ab4568f728097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_a_z_1_1_i_allocator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_a_z_1_1_i_allocator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_a_z_1_1_i_allocator.html">AZ::IAllocator</a></td></tr>
<tr class="memitem:a0d1f083cc342642760855863d6f43517 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="memItemLeft" align="right" valign="top"><a id="a0d1f083cc342642760855863d6f43517"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IAllocator</b> (<a class="el" href="class_a_z_1_1_i_allocator_schema.html">IAllocatorSchema</a> *schema=nullptr)</td></tr>
<tr class="separator:a0d1f083cc342642760855863d6f43517 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e04d13ba690652f1ce94e591bea243 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="memItemLeft" align="right" valign="top"><a id="a75e04d13ba690652f1ce94e591bea243"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_1_1_i_allocator_schema.html">IAllocatorSchema</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator.html#a75e04d13ba690652f1ce94e591bea243">GetSchema</a> () const</td></tr>
<tr class="memdesc:a75e04d13ba690652f1ce94e591bea243 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the schema. <br /></td></tr>
<tr class="separator:a75e04d13ba690652f1ce94e591bea243 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e085ec8fce3decb571034055e62309 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="memItemLeft" align="right" valign="top"><a id="ac4e085ec8fce3decb571034055e62309"></a>
virtual <a class="el" href="struct_a_z_1_1_allocator_debug_config.html">AllocatorDebugConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator.html#ac4e085ec8fce3decb571034055e62309">GetDebugConfig</a> ()=0</td></tr>
<tr class="memdesc:ac4e085ec8fce3decb571034055e62309 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug configuration for this allocator. <br /></td></tr>
<tr class="separator:ac4e085ec8fce3decb571034055e62309 inherit pub_methods_class_a_z_1_1_i_allocator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_a_z_1_1_i_allocator_schema"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_a_z_1_1_i_allocator_schema')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_a_z_1_1_i_allocator_schema.html">AZ::IAllocatorSchema</a></td></tr>
<tr class="memitem:a49762e634d0a03327fc1b2db87456d70 inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memItemLeft" align="right" valign="top"><a id="a49762e634d0a03327fc1b2db87456d70"></a>
virtual pointer_type&#160;</td><td class="memItemRight" valign="bottom"><b>Allocate</b> (size_type byteSize, size_type alignment, int flags=0, const char *name=nullptr, const char *fileName=nullptr, int lineNum=0, unsigned int suppressStackRecord=0)=0</td></tr>
<tr class="separator:a49762e634d0a03327fc1b2db87456d70 inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76037f8a2a269b7025e47833a77d851b inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memItemLeft" align="right" valign="top"><a id="a76037f8a2a269b7025e47833a77d851b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>DeAllocate</b> (pointer_type ptr, size_type byteSize=0, size_type alignment=0)=0</td></tr>
<tr class="separator:a76037f8a2a269b7025e47833a77d851b inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185b218b8b01bd490e30514eda2dc1ec inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memItemLeft" align="right" valign="top"><a id="a185b218b8b01bd490e30514eda2dc1ec"></a>
virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator_schema.html#a185b218b8b01bd490e30514eda2dc1ec">Resize</a> (pointer_type ptr, size_type newSize)=0</td></tr>
<tr class="memdesc:a185b218b8b01bd490e30514eda2dc1ec inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize an allocated memory block. Returns the new adjusted size (as close as possible or equal to the requested one) or 0 (if you don't support resize at all). <br /></td></tr>
<tr class="separator:a185b218b8b01bd490e30514eda2dc1ec inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abee5e6bea72fc951956afa9db2d3ed inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memItemLeft" align="right" valign="top"><a id="a6abee5e6bea72fc951956afa9db2d3ed"></a>
virtual pointer_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator_schema.html#a6abee5e6bea72fc951956afa9db2d3ed">ReAllocate</a> (pointer_type ptr, size_type newSize, size_type newAlignment)=0</td></tr>
<tr class="memdesc:a6abee5e6bea72fc951956afa9db2d3ed inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="mdescLeft">&#160;</td><td class="mdescRight">Realloc an allocate memory memory block. Similar to Resize except it will move the memory block if needed. Return NULL if realloc is not supported or run out of memory. <br /></td></tr>
<tr class="separator:a6abee5e6bea72fc951956afa9db2d3ed inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dee8c2a0cf36df08d9f9e6cb9fe237d inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memItemLeft" align="right" valign="top"><a id="a6dee8c2a0cf36df08d9f9e6cb9fe237d"></a>
virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator_schema.html#a6dee8c2a0cf36df08d9f9e6cb9fe237d">AllocationSize</a> (pointer_type ptr)=0</td></tr>
<tr class="memdesc:a6dee8c2a0cf36df08d9f9e6cb9fe237d inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns allocation size for given address. 0 if the address doesn't belong to the allocator. <br /></td></tr>
<tr class="separator:a6dee8c2a0cf36df08d9f9e6cb9fe237d inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658931300e37c3b156173907f54f9b33 inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator_schema.html#a658931300e37c3b156173907f54f9b33">GarbageCollect</a> ()</td></tr>
<tr class="separator:a658931300e37c3b156173907f54f9b33 inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4760bfa63888580685a8814f84d5141 inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memItemLeft" align="right" valign="top"><a id="aa4760bfa63888580685a8814f84d5141"></a>
virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><b>NumAllocatedBytes</b> () const =0</td></tr>
<tr class="separator:aa4760bfa63888580685a8814f84d5141 inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad491ba92a4e47efc17d6447a17642abe inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memItemLeft" align="right" valign="top"><a id="ad491ba92a4e47efc17d6447a17642abe"></a>
virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator_schema.html#ad491ba92a4e47efc17d6447a17642abe">Capacity</a> () const =0</td></tr>
<tr class="memdesc:ad491ba92a4e47efc17d6447a17642abe inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the capacity of the Allocator in bytes. If the return value is 0 the Capacity is undefined (usually depends on another allocator) <br /></td></tr>
<tr class="separator:ad491ba92a4e47efc17d6447a17642abe inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb07df6bb47d5cdcc908a3d980ce4023 inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memItemLeft" align="right" valign="top"><a id="adb07df6bb47d5cdcc908a3d980ce4023"></a>
virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator_schema.html#adb07df6bb47d5cdcc908a3d980ce4023">GetMaxAllocationSize</a> () const</td></tr>
<tr class="memdesc:adb07df6bb47d5cdcc908a3d980ce4023 inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max allocation size if possible. If not returned value is 0. <br /></td></tr>
<tr class="separator:adb07df6bb47d5cdcc908a3d980ce4023 inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a83d041cda92e3455229527676b4331 inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memItemLeft" align="right" valign="top"><a id="a4a83d041cda92e3455229527676b4331"></a>
virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator_schema.html#a4a83d041cda92e3455229527676b4331">GetMaxContiguousAllocationSize</a> () const</td></tr>
<tr class="memdesc:a4a83d041cda92e3455229527676b4331 inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum contiguous allocation size of a single allocation. <br /></td></tr>
<tr class="separator:a4a83d041cda92e3455229527676b4331 inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9293af0b203445c69974aad18760eb5 inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memItemLeft" align="right" valign="top">virtual size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_allocator_schema.html#ab9293af0b203445c69974aad18760eb5">GetUnAllocatedMemory</a> (bool isPrint=false) const</td></tr>
<tr class="separator:ab9293af0b203445c69974aad18760eb5 inherit pub_methods_class_a_z_1_1_i_allocator_schema"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6493cc5fdf8ee96f831dded9a0ab1954"><td class="memItemLeft" align="right" valign="top"><a id="a6493cc5fdf8ee96f831dded9a0ab1954"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AllocatorBase</b> (<a class="el" href="class_a_z_1_1_i_allocator_schema.html">IAllocatorSchema</a> *allocationSchema, const char *name, const char *desc)</td></tr>
<tr class="separator:a6493cc5fdf8ee96f831dded9a0ab1954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5bdb7646ca2cffc0241ac919335efb"><td class="memItemLeft" align="right" valign="top"><a id="aaf5bdb7646ca2cffc0241ac919335efb"></a>
AZ_FORCE_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#aaf5bdb7646ca2cffc0241ac919335efb">MemorySizeAdjustedUp</a> (size_t byteSize) const</td></tr>
<tr class="memdesc:aaf5bdb7646ca2cffc0241ac919335efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of a memory allocation after adjusting for tracking. <br /></td></tr>
<tr class="separator:aaf5bdb7646ca2cffc0241ac919335efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add248fc9ce272bb9673579d8aee7f4f0"><td class="memItemLeft" align="right" valign="top"><a id="add248fc9ce272bb9673579d8aee7f4f0"></a>
AZ_FORCE_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#add248fc9ce272bb9673579d8aee7f4f0">MemorySizeAdjustedDown</a> (size_t byteSize) const</td></tr>
<tr class="memdesc:add248fc9ce272bb9673579d8aee7f4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of a memory allocation, removing any tracking overhead. <br /></td></tr>
<tr class="separator:add248fc9ce272bb9673579d8aee7f4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db7f2fedbda2663e5b12434ab5b09a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a9db7f2fedbda2663e5b12434ab5b09a1">DisableRegistration</a> ()</td></tr>
<tr class="separator:a9db7f2fedbda2663e5b12434ab5b09a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fde2583165effaca7f0fce7b327830b"><td class="memItemLeft" align="right" valign="top"><a id="a3fde2583165effaca7f0fce7b327830b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a3fde2583165effaca7f0fce7b327830b">ProfileAllocation</a> (void *ptr, size_t byteSize, size_t alignment, const char *name, const char *fileName, int lineNum, int suppressStackRecord)</td></tr>
<tr class="memdesc:a3fde2583165effaca7f0fce7b327830b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records an allocation for profiling. <br /></td></tr>
<tr class="separator:a3fde2583165effaca7f0fce7b327830b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ad18ec2ce4cadbbc40979392a7a719"><td class="memItemLeft" align="right" valign="top"><a id="a01ad18ec2ce4cadbbc40979392a7a719"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a01ad18ec2ce4cadbbc40979392a7a719">ProfileDeallocation</a> (void *ptr, size_t byteSize, size_t alignment, <a class="el" href="struct_a_z_1_1_debug_1_1_allocation_info.html">Debug::AllocationInfo</a> *info)</td></tr>
<tr class="memdesc:a01ad18ec2ce4cadbbc40979392a7a719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a deallocation for profiling. <br /></td></tr>
<tr class="separator:a01ad18ec2ce4cadbbc40979392a7a719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8ebd8941d7dffdec13864008712f4d"><td class="memItemLeft" align="right" valign="top"><a id="aca8ebd8941d7dffdec13864008712f4d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#aca8ebd8941d7dffdec13864008712f4d">ProfileReallocationBegin</a> (void *ptr, size_t newSize)</td></tr>
<tr class="memdesc:aca8ebd8941d7dffdec13864008712f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a reallocation for profiling. <br /></td></tr>
<tr class="separator:aca8ebd8941d7dffdec13864008712f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578c5cbf30fa3027df60be7f038660c2"><td class="memItemLeft" align="right" valign="top"><a id="a578c5cbf30fa3027df60be7f038660c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a578c5cbf30fa3027df60be7f038660c2">ProfileReallocationEnd</a> (void *ptr, void *newPtr, size_t newSize, size_t newAlignment)</td></tr>
<tr class="memdesc:a578c5cbf30fa3027df60be7f038660c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records the beginning of a reallocation for profiling. <br /></td></tr>
<tr class="separator:a578c5cbf30fa3027df60be7f038660c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cde659f584df96b281b961cdb54566"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#ab8cde659f584df96b281b961cdb54566">ProfileReallocation</a> (void *ptr, void *newPtr, size_t newSize, size_t newAlignment)</td></tr>
<tr class="separator:ab8cde659f584df96b281b961cdb54566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9160e4e32dec84dee39e2421e1f7954"><td class="memItemLeft" align="right" valign="top"><a id="ac9160e4e32dec84dee39e2421e1f7954"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#ac9160e4e32dec84dee39e2421e1f7954">ProfileResize</a> (void *ptr, size_t newSize)</td></tr>
<tr class="memdesc:ac9160e4e32dec84dee39e2421e1f7954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a resize for profiling. <br /></td></tr>
<tr class="separator:ac9160e4e32dec84dee39e2421e1f7954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d190d6a079f57c4bacc3ef7ab505a33"><td class="memItemLeft" align="right" valign="top"><a id="a1d190d6a079f57c4bacc3ef7ab505a33"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_allocator_base.html#a1d190d6a079f57c4bacc3ef7ab505a33">OnOutOfMemory</a> (size_t byteSize, size_t alignment, int flags, const char *name, const char *fileName, int lineNum)</td></tr>
<tr class="memdesc:a1d190d6a079f57c4bacc3ef7ab505a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">User allocator should call this function when they run out of memory! <br /></td></tr>
<tr class="separator:a1d190d6a079f57c4bacc3ef7ab505a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_class_a_z_1_1_i_allocator_schema"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_a_z_1_1_i_allocator_schema')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_a_z_1_1_i_allocator_schema.html">AZ::IAllocatorSchema</a></td></tr>
<tr class="memitem:aa7fef126ec139697883165162908cd32 inherit pub_types_class_a_z_1_1_i_allocator_schema"><td class="memItemLeft" align="right" valign="top"><a id="aa7fef126ec139697883165162908cd32"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer_type</b></td></tr>
<tr class="separator:aa7fef126ec139697883165162908cd32 inherit pub_types_class_a_z_1_1_i_allocator_schema"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f16416b1c0092a5412eefecc0decb05 inherit pub_types_class_a_z_1_1_i_allocator_schema"><td class="memItemLeft" align="right" valign="top"><a id="a8f16416b1c0092a5412eefecc0decb05"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a8f16416b1c0092a5412eefecc0decb05 inherit pub_types_class_a_z_1_1_i_allocator_schema"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fe6efb5a6f0ca5c6821dd151916b4e inherit pub_types_class_a_z_1_1_i_allocator_schema"><td class="memItemLeft" align="right" valign="top"><a id="a32fe6efb5a6f0ca5c6821dd151916b4e"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a32fe6efb5a6f0ca5c6821dd151916b4e inherit pub_types_class_a_z_1_1_i_allocator_schema"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_a_z_1_1_i_allocator"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_a_z_1_1_i_allocator')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_a_z_1_1_i_allocator.html">AZ::IAllocator</a></td></tr>
<tr class="memitem:a105f2f37023878a8615a733d36998537 inherit pro_attribs_class_a_z_1_1_i_allocator"><td class="memItemLeft" align="right" valign="top"><a id="a105f2f37023878a8615a733d36998537"></a>
<a class="el" href="class_a_z_1_1_i_allocator_schema.html">IAllocatorSchema</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_schema</b></td></tr>
<tr class="separator:a105f2f37023878a8615a733d36998537 inherit pro_attribs_class_a_z_1_1_i_allocator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_a_z_1_1_allocator_base.html">AllocatorBase</a> - all AZ-compatible allocators should inherit from this implementation of <a class="el" href="class_a_z_1_1_i_allocator.html">IAllocator</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9db7f2fedbda2663e5b12434ab5b09a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db7f2fedbda2663e5b12434ab5b09a1">&#9670;&nbsp;</a></span>DisableRegistration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::AllocatorBase::DisableRegistration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call to disallow this allocator from being registered with the <a class="el" href="class_a_z_1_1_allocator_manager.html">AllocatorManager</a>. Only kernel-level allocators where it would be especially problematic for them to be registered with the <a class="el" href="class_a_z_1_1_allocator_manager.html">AllocatorManager</a> should do this. </p>

</div>
</div>
<a id="ab8cde659f584df96b281b961cdb54566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8cde659f584df96b281b961cdb54566">&#9670;&nbsp;</a></span>ProfileReallocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::AllocatorBase::ProfileReallocation </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>newPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newAlignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deprecated. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Please use ProfileReallocationBegin/ProfileReallocationEnd instead. </dd></dl>

</div>
</div>
<a id="a2472cdf0a944b0657bfcbba28cfb64fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2472cdf0a944b0657bfcbba28cfb64fa">&#9670;&nbsp;</a></span>SetLazilyCreated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::AllocatorBase::SetLazilyCreated </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines whether the allocator was lazily created, possibly at static initialization. This is primarily meant to support older allocation systems, such as those used by CryEngine. Newer systems should create and destroy their allocators deliberately at program start-up and shut-down. </p>

<p>Implements <a class="el" href="class_a_z_1_1_i_allocator.html">AZ::IAllocator</a>.</p>

</div>
</div>
<a id="ad4b5066e11564d2204e6cda0fe77a88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b5066e11564d2204e6cda0fe77a88d">&#9670;&nbsp;</a></span>SetProfilingActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::AllocatorBase::SetProfilingActive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets whether profiling calls should be made. This is primarily a performance compromise, as the profiling calls go out on an <a class="el" href="class_a_z_1_1_e_bus.html">EBus</a> that may not exist if not activated, and will result in an expensive hash lookup if that is the case. </p>

<p>Implements <a class="el" href="class_a_z_1_1_i_allocator.html">AZ::IAllocator</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Code/Framework/AzCore/AzCore/Memory/AllocatorBase.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 5 2022 14:03:26 for Open 3D Engine AzCore API Reference by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
